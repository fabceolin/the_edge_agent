{
  "version": 3,
  "sources": ["../../../../rust/tea-wasm-llm/js/model-cache.ts", "../../../../rust/tea-wasm-llm/js/index.ts", "../../../../rust/tea-wasm-llm/js/model-loader.ts", "../../../../rust/tea-wasm-llm/node_modules/@wllama/wllama/src/glue/messages.ts", "../../../../rust/tea-wasm-llm/node_modules/@wllama/wllama/src/glue/glue.ts", "../../../../rust/tea-wasm-llm/node_modules/@wllama/wllama/src/utils.ts", "../../../../rust/tea-wasm-llm/node_modules/@wllama/wllama/src/workers-code/generated.ts", "../../../../rust/tea-wasm-llm/node_modules/@wllama/wllama/src/worker.ts", "../../../../rust/tea-wasm-llm/node_modules/@wllama/wllama/src/cache-manager.ts", "../../../../rust/tea-wasm-llm/node_modules/@wllama/wllama/src/model-manager.ts", "../../../../rust/tea-wasm-llm/node_modules/@wllama/wllama/src/wllama.ts", "../../../../rust/tea-wasm-llm/js/wllama-loader.ts"],
  "sourcesContent": ["/**\n * TEA WASM LLM - Model Cache Module\n *\n * IndexedDB-based caching for GGUF model files.\n * Stores models after first load to avoid re-downloading on subsequent visits.\n *\n * Features:\n * - Version-based cache invalidation\n * - Automatic cache clearing on corruption\n * - Quota detection and error handling\n *\n * Browser Compatibility Notes:\n * - Chrome/Firefox: ~2GB IndexedDB limit (sufficient for Phi-4-mini 1.9GB)\n * - Safari: 1GB hard limit - model cannot be cached, will fall back to streaming\n */\n\n/**\n * Database constants\n */\nconst DB_NAME = 'tea-llm-cache';\nconst DB_VERSION = 1;\nconst STORE_NAME = 'models';\n\n/**\n * Cached model entry structure\n */\nexport interface CachedModel {\n  /** Version string for cache invalidation */\n  version: string;\n\n  /** Model data as Uint8Array */\n  data: Uint8Array;\n\n  /** Timestamp when cached (ms since epoch) */\n  timestamp: number;\n\n  /** Original model name */\n  modelName: string;\n\n  /** Size in bytes (for display/verification) */\n  size: number;\n}\n\n/**\n * Cache statistics\n */\nexport interface CacheStats {\n  /** Whether the cache database exists and is accessible */\n  available: boolean;\n\n  /** Number of cached models */\n  modelCount: number;\n\n  /** Total size of cached models in bytes */\n  totalSize: number;\n\n  /** Estimated available quota in bytes (if supported) */\n  estimatedQuota?: number;\n\n  /** Estimated used quota in bytes (if supported) */\n  estimatedUsage?: number;\n}\n\n/**\n * Open the IndexedDB database\n * Creates the object store on first open\n */\nasync function openDB(): Promise<IDBDatabase> {\n  return new Promise((resolve, reject) => {\n    const request = indexedDB.open(DB_NAME, DB_VERSION);\n\n    request.onerror = () => {\n      reject(new Error(`Failed to open cache database: ${request.error?.message}`));\n    };\n\n    request.onsuccess = () => {\n      resolve(request.result);\n    };\n\n    request.onupgradeneeded = (event) => {\n      const db = (event.target as IDBOpenDBRequest).result;\n\n      // Create object store if it doesn't exist\n      if (!db.objectStoreNames.contains(STORE_NAME)) {\n        const store = db.createObjectStore(STORE_NAME, { keyPath: 'version' });\n        // Index by modelName for potential future queries\n        store.createIndex('modelName', 'modelName', { unique: false });\n        store.createIndex('timestamp', 'timestamp', { unique: false });\n      }\n    };\n  });\n}\n\n/**\n * Check if the model cache is available in this browser\n *\n * @returns Promise resolving to true if IndexedDB is available\n */\nexport async function isModelCacheAvailable(): Promise<boolean> {\n  if (typeof indexedDB === 'undefined') {\n    return false;\n  }\n\n  try {\n    const db = await openDB();\n    db.close();\n    return true;\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Get a cached model by version\n *\n * @param version - Version string to look up\n * @returns Promise resolving to model data or null if not cached\n */\nexport async function getCachedModel(version: string): Promise<Uint8Array | null> {\n  try {\n    const db = await openDB();\n\n    return new Promise((resolve, reject) => {\n      const tx = db.transaction(STORE_NAME, 'readonly');\n      const store = tx.objectStore(STORE_NAME);\n      const request = store.get(version);\n\n      request.onerror = () => {\n        db.close();\n        reject(new Error(`Failed to read from cache: ${request.error?.message}`));\n      };\n\n      request.onsuccess = () => {\n        db.close();\n        const result = request.result as CachedModel | undefined;\n        resolve(result?.data || null);\n      };\n    });\n  } catch (e) {\n    console.warn('[TEA-LLM-Cache] Cache read failed:', e);\n    return null;\n  }\n}\n\n/**\n * Get full cached model entry with metadata\n *\n * @param version - Version string to look up\n * @returns Promise resolving to full CachedModel entry or null\n */\nexport async function getCachedModelEntry(version: string): Promise<CachedModel | null> {\n  try {\n    const db = await openDB();\n\n    return new Promise((resolve, reject) => {\n      const tx = db.transaction(STORE_NAME, 'readonly');\n      const store = tx.objectStore(STORE_NAME);\n      const request = store.get(version);\n\n      request.onerror = () => {\n        db.close();\n        reject(new Error(`Failed to read from cache: ${request.error?.message}`));\n      };\n\n      request.onsuccess = () => {\n        db.close();\n        // IndexedDB returns undefined for non-existent keys, normalize to null\n        resolve(request.result ?? null);\n      };\n    });\n  } catch (e) {\n    console.warn('[TEA-LLM-Cache] Cache read failed:', e);\n    return null;\n  }\n}\n\n/**\n * Store a model in the cache\n *\n * @param version - Version string (cache key)\n * @param data - Model data as Uint8Array\n * @param modelName - Model name for metadata\n */\nexport async function cacheModel(\n  version: string,\n  data: Uint8Array,\n  modelName: string = 'unknown'\n): Promise<void> {\n  try {\n    const db = await openDB();\n\n    return new Promise((resolve, reject) => {\n      const tx = db.transaction(STORE_NAME, 'readwrite');\n      const store = tx.objectStore(STORE_NAME);\n\n      const entry: CachedModel = {\n        version,\n        data,\n        timestamp: Date.now(),\n        modelName,\n        size: data.byteLength,\n      };\n\n      const request = store.put(entry);\n\n      request.onerror = () => {\n        db.close();\n        // Check for quota exceeded\n        if (request.error?.name === 'QuotaExceededError') {\n          reject(new Error(\n            'Storage quota exceeded. The model is too large for this browser\\'s IndexedDB limit.'\n          ));\n        } else {\n          reject(new Error(`Failed to write to cache: ${request.error?.message}`));\n        }\n      };\n\n      request.onsuccess = () => {\n        db.close();\n        resolve();\n      };\n    });\n  } catch (e) {\n    console.warn('[TEA-LLM-Cache] Cache write failed:', e);\n    // Don't throw - caching is optional\n  }\n}\n\n/**\n * Clear all cached models\n */\nexport async function clearCache(): Promise<void> {\n  try {\n    const db = await openDB();\n\n    return new Promise((resolve, reject) => {\n      const tx = db.transaction(STORE_NAME, 'readwrite');\n      const store = tx.objectStore(STORE_NAME);\n      const request = store.clear();\n\n      request.onerror = () => {\n        db.close();\n        reject(new Error(`Failed to clear cache: ${request.error?.message}`));\n      };\n\n      request.onsuccess = () => {\n        db.close();\n        resolve();\n      };\n    });\n  } catch (e) {\n    console.warn('[TEA-LLM-Cache] Cache clear failed:', e);\n    // Don't throw - clearing is optional\n  }\n}\n\n/**\n * Delete a specific cached model by version\n *\n * @param version - Version string to delete\n */\nexport async function deleteCachedModel(version: string): Promise<void> {\n  try {\n    const db = await openDB();\n\n    return new Promise((resolve, reject) => {\n      const tx = db.transaction(STORE_NAME, 'readwrite');\n      const store = tx.objectStore(STORE_NAME);\n      const request = store.delete(version);\n\n      request.onerror = () => {\n        db.close();\n        reject(new Error(`Failed to delete from cache: ${request.error?.message}`));\n      };\n\n      request.onsuccess = () => {\n        db.close();\n        resolve();\n      };\n    });\n  } catch (e) {\n    console.warn('[TEA-LLM-Cache] Cache delete failed:', e);\n  }\n}\n\n/**\n * Check if a specific version is cached\n *\n * @param version - Version string to check\n * @returns Promise resolving to true if cached\n */\nexport async function isCached(version: string): Promise<boolean> {\n  const entry = await getCachedModelEntry(version);\n  return entry !== null;\n}\n\n/**\n * Get cache statistics\n *\n * @returns Promise resolving to cache statistics\n */\nexport async function getCacheStats(): Promise<CacheStats> {\n  const stats: CacheStats = {\n    available: false,\n    modelCount: 0,\n    totalSize: 0,\n  };\n\n  // Check storage quota if available\n  if ('storage' in navigator && 'estimate' in navigator.storage) {\n    try {\n      const estimate = await navigator.storage.estimate();\n      stats.estimatedQuota = estimate.quota;\n      stats.estimatedUsage = estimate.usage;\n    } catch {\n      // Quota estimation not available\n    }\n  }\n\n  try {\n    const db = await openDB();\n    stats.available = true;\n\n    return new Promise((resolve) => {\n      const tx = db.transaction(STORE_NAME, 'readonly');\n      const store = tx.objectStore(STORE_NAME);\n      const request = store.getAll();\n\n      request.onsuccess = () => {\n        db.close();\n        const entries = request.result as CachedModel[];\n        stats.modelCount = entries.length;\n        stats.totalSize = entries.reduce((sum, entry) => sum + entry.size, 0);\n        resolve(stats);\n      };\n\n      request.onerror = () => {\n        db.close();\n        resolve(stats);\n      };\n    });\n  } catch {\n    return stats;\n  }\n}\n\n/**\n * List all cached model versions\n *\n * @returns Promise resolving to array of cached versions with metadata\n */\nexport async function listCachedModels(): Promise<Array<{\n  version: string;\n  modelName: string;\n  size: number;\n  timestamp: number;\n}>> {\n  try {\n    const db = await openDB();\n\n    return new Promise((resolve, reject) => {\n      const tx = db.transaction(STORE_NAME, 'readonly');\n      const store = tx.objectStore(STORE_NAME);\n      const request = store.getAll();\n\n      request.onerror = () => {\n        db.close();\n        reject(new Error(`Failed to list cache: ${request.error?.message}`));\n      };\n\n      request.onsuccess = () => {\n        db.close();\n        const entries = request.result as CachedModel[];\n        resolve(entries.map(({ version, modelName, size, timestamp }) => ({\n          version,\n          modelName,\n          size,\n          timestamp,\n        })));\n      };\n    });\n  } catch (e) {\n    console.warn('[TEA-LLM-Cache] Cache list failed:', e);\n    return [];\n  }\n}\n\n/**\n * Check if the model size can fit in IndexedDB\n * This is a heuristic check based on known browser limits.\n *\n * @param sizeBytes - Model size in bytes\n * @returns Object with canCache boolean and reason string\n */\nexport async function checkStorageCapacity(sizeBytes: number): Promise<{\n  canCache: boolean;\n  reason: string;\n}> {\n  // Safari has a hard 1GB limit\n  const isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);\n  if (isSafari && sizeBytes > 1024 * 1024 * 1024) {\n    return {\n      canCache: false,\n      reason: 'Safari has a 1GB IndexedDB limit. Model will be loaded via streaming without caching.',\n    };\n  }\n\n  // Check storage quota if available\n  if ('storage' in navigator && 'estimate' in navigator.storage) {\n    try {\n      const estimate = await navigator.storage.estimate();\n      const available = (estimate.quota || 0) - (estimate.usage || 0);\n\n      if (sizeBytes > available) {\n        return {\n          canCache: false,\n          reason: `Insufficient storage. Need ${formatBytes(sizeBytes)}, have ${formatBytes(available)}.`,\n        };\n      }\n    } catch {\n      // Fall through to optimistic return\n    }\n  }\n\n  return {\n    canCache: true,\n    reason: 'Storage capacity appears sufficient.',\n  };\n}\n\n/**\n * Format bytes for human-readable display\n */\nfunction formatBytes(bytes: number): string {\n  const units = ['B', 'KB', 'MB', 'GB', 'TB'];\n  let value = bytes;\n  let unitIndex = 0;\n\n  while (value >= 1024 && unitIndex < units.length - 1) {\n    value /= 1024;\n    unitIndex++;\n  }\n\n  return `${value.toFixed(unitIndex > 0 ? 1 : 0)} ${units[unitIndex]}`;\n}\n", "/**\n * TEA WASM LLM - Batteries-Included Browser LLM\n *\n * This module provides a high-level API for running LLM inference in the browser\n * with wllama bundled internally - zero external npm dependencies required.\n *\n * Features:\n * - Single import, zero external dependencies (\"batteries included\")\n * - Model loading with IndexedDB caching\n * - Progress tracking during model download\n * - Automatic multi-threading detection\n * - YAML workflow execution with LLM actions\n * - Backward compatible with legacy callback API\n *\n * ## Quick Start (New Batteries-Included API)\n *\n * @example\n * ```typescript\n * import { initLlm, chat, chatStream, embed } from 'tea-wasm-llm';\n *\n * // Initialize and load model (one-time)\n * await initLlm({\n *   modelUrl: 'https://huggingface.co/.../Phi-4-mini-Q3_K_S.gguf',\n *   onProgress: (loaded, total) => console.log(`${Math.round(loaded/total*100)}%`),\n * });\n *\n * // Simple chat\n * const response = await chat(\"What is 2+2?\", { maxTokens: 50 });\n * console.log(response.content);\n *\n * // Streaming chat\n * await chatStream(\"Tell me a story\", (token) => {\n *   process.stdout.write(token);\n * });\n *\n * // Generate embeddings\n * const embedding = await embed(\"Hello world\");\n * console.log(embedding.vector);\n * ```\n *\n * ## Legacy Callback API (Backward Compatible)\n *\n * @example\n * ```typescript\n * import { initTeaLlm, executeLlmYaml } from 'tea-wasm-llm';\n *\n * // Register custom LLM handler (e.g., external wllama instance)\n * await initTeaLlm({}, async (paramsJson) => {\n *     const params = JSON.parse(paramsJson);\n *     const result = await wllama.createCompletion(params.prompt, {...});\n *     return JSON.stringify({ content: result });\n * });\n *\n * // Execute YAML workflow\n * const result = await executeLlmYaml(yaml, {});\n * ```\n */\n\nimport init, {\n  execute_yaml,\n  set_llm_handler,\n  clear_llm_handler,\n  has_llm_handler,\n  llm_call_async,\n  llm_embed_async,\n  has_shared_array_buffer,\n  version,\n} from '../pkg/tea_wasm_llm.js';\n\n// Import model loading modules\nimport {\n  loadModel,\n  verifyChecksum,\n  calculateChecksum,\n  fetchManifest,\n  formatBytes,\n  loadBundledModel,\n  loadBundledModelSafe,\n  type ModelManifest,\n  type ProgressCallback,\n  type LoadModelOptions,\n  type BundledModelConfig,\n} from './model-loader';\n\nimport {\n  getCachedModel,\n  getCachedModelEntry,\n  cacheModel,\n  clearCache,\n  deleteCachedModel,\n  isCached,\n  getCacheStats,\n  listCachedModels,\n  checkStorageCapacity,\n  isModelCacheAvailable,\n  type CachedModel,\n  type CacheStats,\n} from './model-cache';\n\n/**\n * Configuration options for TEA LLM initialization\n */\nexport interface TeaLlmConfig {\n  /**\n   * URL to load the model from (optional, for future use)\n   */\n  modelUrl?: string;\n\n  /**\n   * Number of threads to use (0 = auto-detect)\n   */\n  threads?: number;\n\n  /**\n   * Whether to use verbose logging\n   */\n  verbose?: boolean;\n}\n\n// BundledModelConfig is imported from model-loader\n\n/**\n * LLM request parameters (OpenAI-compatible)\n */\nexport interface LlmParams {\n  /**\n   * The prompt to send to the model\n   */\n  prompt: string;\n\n  /**\n   * System prompt (optional)\n   */\n  system?: string;\n\n  /**\n   * Maximum tokens to generate\n   */\n  max_tokens?: number;\n\n  /**\n   * Temperature (0.0 - 2.0)\n   */\n  temperature?: number;\n\n  /**\n   * Top-p nucleus sampling\n   */\n  top_p?: number;\n\n  /**\n   * Top-k sampling (0 = disabled)\n   */\n  top_k?: number;\n\n  /**\n   * Model name (for logging/routing)\n   */\n  model?: string;\n\n  /**\n   * Stop sequences\n   */\n  stop?: string[];\n}\n\n/**\n * LLM response structure\n */\nexport interface LlmResponse {\n  /**\n   * Generated text content\n   */\n  content: string;\n\n  /**\n   * Model used (for logging)\n   */\n  model?: string;\n\n  /**\n   * Token usage (optional)\n   */\n  usage?: {\n    prompt_tokens: number;\n    completion_tokens: number;\n    total_tokens: number;\n  };\n}\n\n/**\n * Handler function type for LLM calls\n * Receives JSON string with LlmParams, returns Promise<JSON string with LlmResponse>\n */\nexport type LlmHandler = (paramsJson: string) => Promise<string>;\n\n// Track initialization state\nlet initialized = false;\n\n/**\n * Initialize TEA LLM with a wllama handler\n *\n * @deprecated Use initLlm() instead for the batteries-included API.\n * This function is maintained for backward compatibility with the callback pattern.\n *\n * @param config - Configuration options\n * @param llmHandler - Function to handle LLM calls (typically wraps wllama)\n *\n * @example\n * ```typescript\n * await initTeaLlm({}, async (paramsJson) => {\n *     const params = JSON.parse(paramsJson);\n *     const result = await wllama.createCompletion(params.prompt, {\n *         nPredict: params.max_tokens || 100,\n *     });\n *     return JSON.stringify({ content: result });\n * });\n * ```\n */\nexport async function initTeaLlm(\n  config: TeaLlmConfig = {},\n  llmHandler: LlmHandler\n): Promise<void> {\n  // Initialize WASM module if not already done\n  if (!initialized) {\n    await init();\n    initialized = true;\n\n    if (config.verbose) {\n      console.log('[TEA-WASM-LLM] WASM module initialized');\n      console.log('[TEA-WASM-LLM] Version:', version());\n      console.log('[TEA-WASM-LLM] SharedArrayBuffer:', has_shared_array_buffer());\n    }\n  }\n\n  // Register the LLM handler\n  set_llm_handler(llmHandler);\n\n  if (config.verbose) {\n    console.log('[TEA-WASM-LLM] LLM handler registered');\n  }\n}\n\n/**\n * Execute a YAML workflow with LLM actions\n *\n * @deprecated Use chat() or chatStream() instead for the batteries-included API.\n * This function is maintained for backward compatibility with the callback pattern.\n *\n * @param yaml - YAML workflow definition\n * @param initialState - Initial state object\n * @returns Promise resolving to the final state\n *\n * @example\n * ```typescript\n * const result = await executeLlmYaml(`\n * name: test\n * nodes:\n *   - name: gen\n *     action: llm.call\n *     with:\n *       prompt: \"Hello, world!\"\n *       max_tokens: 50\n * edges:\n *   - from: __start__\n *     to: gen\n *   - from: gen\n *     to: __end__\n * `, { input: \"test\" });\n * ```\n */\nexport async function executeLlmYaml(\n  yaml: string,\n  initialState: Record<string, unknown> = {}\n): Promise<Record<string, unknown>> {\n  if (!initialized) {\n    throw new Error('TEA LLM not initialized. Call initTeaLlm() first.');\n  }\n\n  const result = await execute_yaml(yaml, JSON.stringify(initialState));\n  return JSON.parse(result);\n}\n\n/**\n * Call the LLM directly (low-level API)\n *\n * @param params - LLM parameters\n * @param state - Current state object\n * @returns Promise resolving to updated state with llm_response\n */\nexport async function callLlm(\n  params: LlmParams,\n  state: Record<string, unknown> = {}\n): Promise<Record<string, unknown>> {\n  if (!has_llm_handler()) {\n    throw new Error('No LLM handler registered. Call initTeaLlm() first.');\n  }\n\n  const result = await llm_call_async(JSON.stringify(params), JSON.stringify(state));\n  return JSON.parse(result);\n}\n\n/**\n * Generate embeddings (low-level API)\n *\n * @param text - Text to embed\n * @param state - Current state object\n * @returns Promise resolving to updated state with embedding\n */\nexport async function embedText(\n  text: string,\n  state: Record<string, unknown> = {}\n): Promise<Record<string, unknown>> {\n  if (!has_llm_handler()) {\n    throw new Error('No LLM handler registered. Call initTeaLlm() first.');\n  }\n\n  const result = await llm_embed_async(text, JSON.stringify(state));\n  return JSON.parse(result);\n}\n\n/**\n * Check if an LLM handler is registered\n */\nexport function isHandlerRegistered(): boolean {\n  return has_llm_handler();\n}\n\n/**\n * Check if SharedArrayBuffer is available (for multi-threading)\n */\nexport function isMultiThreaded(): boolean {\n  return has_shared_array_buffer();\n}\n\n/**\n * Clear the registered LLM handler\n */\nexport function clearHandler(): void {\n  clear_llm_handler();\n}\n\n/**\n * Get the library version\n */\nexport function getVersion(): string {\n  return version();\n}\n\n// ============================================================================\n// Model Loading with Caching\n// ============================================================================\n// loadBundledModel and loadBundledModelSafe are imported from model-loader.ts\n\n/**\n * Check if a model is cached\n *\n * @param version - Version string to check\n * @returns Promise resolving to true if model is cached\n */\nexport async function isModelCached(version: string): Promise<boolean> {\n  return isCached(version);\n}\n\n/**\n * Get model cache statistics\n *\n * @returns Promise resolving to cache statistics\n */\nexport async function getModelCacheStats(): Promise<CacheStats> {\n  return getCacheStats();\n}\n\n/**\n * Clear the model cache\n */\nexport async function clearModelCache(): Promise<void> {\n  return clearCache();\n}\n\n/**\n * Re-export raw WASM bindings for advanced use.\n *\n * @deprecated For new projects, use the batteries-included API instead:\n * - initLlm() instead of init() + set_llm_handler()\n * - chat() / chatStream() instead of llm_call_async()\n * - embed() instead of llm_embed_async()\n *\n * The callback API (set_llm_handler) is maintained for backward compatibility\n * and for advanced use cases where you need a custom LLM handler.\n */\nexport {\n  init,\n  execute_yaml,\n  set_llm_handler,\n  clear_llm_handler,\n  has_llm_handler,\n  llm_call_async,\n  llm_embed_async,\n  has_shared_array_buffer,\n  version,\n};\n\n// Re-export model loading modules\nexport {\n  // Model loader\n  loadModel,\n  verifyChecksum,\n  calculateChecksum,\n  fetchManifest,\n  formatBytes,\n  type ModelManifest,\n  type ProgressCallback,\n  type LoadModelOptions,\n  // Model cache\n  getCachedModel,\n  getCachedModelEntry,\n  cacheModel,\n  clearCache,\n  deleteCachedModel,\n  isCached,\n  getCacheStats,\n  listCachedModels,\n  checkStorageCapacity,\n  isModelCacheAvailable,\n  type CachedModel,\n  type CacheStats,\n};\n\n// ============================================================================\n// NEW: Batteries-Included API (wllama bundled internally)\n// ============================================================================\n\n// Re-export from wllama-loader for the new simplified API\nexport {\n  // Core API\n  initLlm,\n  chat,\n  chatStream,\n  embed,\n  isLlmReady,\n  disposeLlm,\n  // Threading detection (renamed to avoid conflict with WASM export)\n  hasSharedArrayBuffer as hasSharedArrayBufferJs,\n  hasCoopCoep,\n  // Cache helpers\n  getLlmCacheStats,\n  clearLlmCache,\n  // Advanced\n  getWllamaInstance,\n  getDefaultAssetPaths,\n  // Types\n  type InitLlmConfig,\n  type ChatOptions,\n  type ChatResponse,\n  type EmbedResponse,\n  type TokenCallback,\n  type WllamaAssetPaths,\n} from './wllama-loader';\n\n// Note: initTeaLlm and executeLlmYaml are already exported above with @deprecated notices\n", "/**\n * TEA WASM LLM - Model Loader Module\n *\n * Handles loading of GGUF model files with progress tracking and checksum verification.\n * Designed for Phi-4-mini Q3_K_S (~1.9GB) which fits GitHub's 2GB limit as a single file.\n *\n * Note: No chunking required - this is a simplified implementation compared to\n * the original Gemma 3n E4B (4.54GB) plan.\n */\n\nimport {\n  isModelCacheAvailable,\n  getCachedModel,\n  checkStorageCapacity,\n  cacheModel,\n} from './model-cache';\n\n/**\n * Model manifest describing the model file and metadata\n */\nexport interface ModelManifest {\n  /** Model name/identifier */\n  model: string;\n\n  /** Version string for cache invalidation */\n  version: string;\n\n  /** Total file size in bytes */\n  totalSize: number;\n\n  /** Filename (single file, no chunks) */\n  file: string;\n\n  /** SHA256 checksum for verification */\n  sha256: string;\n\n  /** Optional description */\n  description?: string;\n\n  /** Optional source URL */\n  source?: string;\n\n  /** Optional download timestamp */\n  downloadedAt?: string;\n}\n\n/**\n * Progress callback type\n * @param loaded - Bytes loaded so far\n * @param total - Total bytes to load\n */\nexport type ProgressCallback = (loaded: number, total: number) => void;\n\n/**\n * Model loader options\n */\nexport interface LoadModelOptions {\n  /** Progress callback for tracking download */\n  onProgress?: ProgressCallback;\n\n  /** Skip checksum verification (not recommended for production) */\n  skipChecksum?: boolean;\n\n  /** Request timeout in milliseconds (default: 0 = no timeout) */\n  timeout?: number;\n}\n\n/**\n * Load a model file from a URL with progress tracking\n *\n * @param basePath - Base path/URL where the model file is located\n * @param manifest - Model manifest describing the file\n * @param options - Loading options\n * @returns Promise resolving to the model data as Uint8Array\n *\n * @example\n * ```typescript\n * const manifest = await fetchManifest('./models');\n * const modelData = await loadModel('./models', manifest, {\n *   onProgress: (loaded, total) => {\n *     console.log(`Loading: ${Math.round(loaded / total * 100)}%`);\n *   }\n * });\n * ```\n */\nexport async function loadModel(\n  basePath: string,\n  manifest: ModelManifest,\n  options: LoadModelOptions = {}\n): Promise<Uint8Array> {\n  const { onProgress, skipChecksum = false, timeout = 0 } = options;\n  const modelUrl = `${basePath}/${manifest.file}`;\n\n  // Create abort controller for timeout\n  const controller = new AbortController();\n  let timeoutId: ReturnType<typeof setTimeout> | undefined;\n\n  if (timeout > 0) {\n    timeoutId = setTimeout(() => controller.abort(), timeout);\n  }\n\n  try {\n    const response = await fetch(modelUrl, {\n      signal: controller.signal,\n    });\n\n    if (!response.ok) {\n      throw new Error(\n        `Failed to load model: ${manifest.file} (HTTP ${response.status})`\n      );\n    }\n\n    // Stream the response for progress tracking\n    const reader = response.body?.getReader();\n    if (!reader) {\n      throw new Error('Response body is not readable');\n    }\n\n    const chunks: Uint8Array[] = [];\n    let loadedSize = 0;\n\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n      const { done, value } = await reader.read();\n      if (done) break;\n\n      chunks.push(value);\n      loadedSize += value.length;\n\n      // Report progress\n      onProgress?.(loadedSize, manifest.totalSize);\n    }\n\n    // Combine chunks into single buffer\n    const combined = new Uint8Array(loadedSize);\n    let offset = 0;\n    for (const chunk of chunks) {\n      combined.set(chunk, offset);\n      offset += chunk.length;\n    }\n\n    // Verify checksum if not skipped\n    if (!skipChecksum && manifest.sha256) {\n      const isValid = await verifyChecksum(combined, manifest.sha256);\n      if (!isValid) {\n        throw new Error(\n          `Checksum verification failed for ${manifest.file}. ` +\n          'The file may be corrupted or incomplete.'\n        );\n      }\n    }\n\n    return combined;\n  } finally {\n    if (timeoutId !== undefined) {\n      clearTimeout(timeoutId);\n    }\n  }\n}\n\n/**\n * Verify SHA256 checksum of data\n *\n * @param data - Data to verify\n * @param expectedSha256 - Expected SHA256 hash (lowercase hex string)\n * @returns Promise resolving to true if checksum matches\n */\nexport async function verifyChecksum(\n  data: Uint8Array,\n  expectedSha256: string\n): Promise<boolean> {\n  // Use slice to get a copy that's definitely an ArrayBuffer\n  const buffer = data.buffer.slice(data.byteOffset, data.byteOffset + data.byteLength) as ArrayBuffer;\n  const hashBuffer = await crypto.subtle.digest('SHA-256', buffer);\n  const hashArray = Array.from(new Uint8Array(hashBuffer));\n  const hashHex = hashArray.map((b) => b.toString(16).padStart(2, '0')).join('');\n  return hashHex.toLowerCase() === expectedSha256.toLowerCase();\n}\n\n/**\n * Calculate SHA256 hash of data\n *\n * @param data - Data to hash\n * @returns Promise resolving to hex string of SHA256 hash\n */\nexport async function calculateChecksum(data: Uint8Array): Promise<string> {\n  // Use slice to get a copy that's definitely an ArrayBuffer\n  const buffer = data.buffer.slice(data.byteOffset, data.byteOffset + data.byteLength) as ArrayBuffer;\n  const hashBuffer = await crypto.subtle.digest('SHA-256', buffer);\n  const hashArray = Array.from(new Uint8Array(hashBuffer));\n  return hashArray.map((b) => b.toString(16).padStart(2, '0')).join('');\n}\n\n/**\n * Fetch and parse a model manifest file\n *\n * @param basePath - Base path/URL where manifest.json is located\n * @param manifestFileName - Manifest filename (default: 'model-manifest.json')\n * @returns Promise resolving to parsed ModelManifest\n */\nexport async function fetchManifest(\n  basePath: string,\n  manifestFileName: string = 'model-manifest.json'\n): Promise<ModelManifest> {\n  const manifestUrl = `${basePath}/${manifestFileName}`;\n  const response = await fetch(manifestUrl);\n\n  if (!response.ok) {\n    throw new Error(\n      `Failed to load manifest: ${manifestFileName} (HTTP ${response.status})`\n    );\n  }\n\n  const manifest: ModelManifest = await response.json();\n\n  // Validate required fields\n  if (!manifest.model || !manifest.version || !manifest.file) {\n    throw new Error(\n      'Invalid manifest: missing required fields (model, version, file)'\n    );\n  }\n\n  if (typeof manifest.totalSize !== 'number' || manifest.totalSize <= 0) {\n    throw new Error(\n      'Invalid manifest: totalSize must be a positive number'\n    );\n  }\n\n  return manifest;\n}\n\n/**\n * Format bytes for human-readable display\n *\n * @param bytes - Number of bytes\n * @returns Human-readable string (e.g., \"1.9 GB\")\n */\nexport function formatBytes(bytes: number): string {\n  const units = ['B', 'KB', 'MB', 'GB', 'TB'];\n  let value = bytes;\n  let unitIndex = 0;\n\n  while (value >= 1024 && unitIndex < units.length - 1) {\n    value /= 1024;\n    unitIndex++;\n  }\n\n  return `${value.toFixed(unitIndex > 0 ? 1 : 0)} ${units[unitIndex]}`;\n}\n\n/**\n * Configuration for loading bundled model\n */\nexport interface BundledModelConfig {\n  /** Base path where model files are located (default: './models') */\n  modelBasePath?: string;\n\n  /** Manifest filename (default: 'model-manifest.json') */\n  manifestFileName?: string;\n\n  /** Use IndexedDB cache (default: true) */\n  useCache?: boolean;\n\n  /** Progress callback during download */\n  onProgress?: ProgressCallback;\n\n  /** Skip checksum verification (not recommended) */\n  skipChecksum?: boolean;\n\n  /** Request timeout in milliseconds */\n  timeout?: number;\n\n  /** Verbose logging */\n  verbose?: boolean;\n}\n\n/**\n * Load a bundled model with IndexedDB caching\n *\n * This function:\n * 1. Loads the manifest file from the specified path\n * 2. Checks if the model is cached (by version)\n * 3. If cached: returns the cached model immediately\n * 4. If not cached: downloads the model, caches it, returns it\n *\n * @param config - Loading configuration options\n * @returns Promise resolving to the model data as Uint8Array\n *\n * @example\n * ```typescript\n * const modelData = await loadBundledModel({\n *   modelBasePath: './models',\n *   onProgress: (loaded, total) => {\n *     const percent = Math.round(loaded / total * 100);\n *     console.log(`Loading: ${percent}%`);\n *   }\n * });\n * ```\n */\nexport async function loadBundledModel(\n  config: BundledModelConfig = {}\n): Promise<Uint8Array> {\n  const {\n    modelBasePath = './models',\n    manifestFileName = 'model-manifest.json',\n    useCache = true,\n    onProgress,\n    skipChecksum = false,\n    timeout = 0,\n    verbose = false,\n  } = config;\n\n  const log = (msg: string) => {\n    if (verbose) console.log(`[TEA-LLM] ${msg}`);\n  };\n\n  // Load manifest\n  log(`Loading manifest from ${modelBasePath}/${manifestFileName}`);\n  const manifest = await fetchManifest(modelBasePath, manifestFileName);\n  log(`Manifest loaded: ${manifest.model} v${manifest.version} (${formatBytes(manifest.totalSize)})`);\n\n  // Check cache first\n  if (useCache) {\n    const cacheAvailable = await isModelCacheAvailable();\n    if (!cacheAvailable) {\n      log('IndexedDB not available, skipping cache');\n    } else {\n      log(`Checking cache for version: ${manifest.version}`);\n      const cached = await getCachedModel(manifest.version);\n\n      if (cached) {\n        log('Model loaded from cache (cache hit)');\n        return cached;\n      }\n\n      log('Cache miss, will download model');\n    }\n  }\n\n  // Load from network\n  log(`Downloading model: ${manifest.file}`);\n  const modelData = await loadModel(modelBasePath, manifest, {\n    onProgress,\n    skipChecksum,\n    timeout,\n  });\n  log(`Download complete: ${formatBytes(modelData.byteLength)}`);\n\n  // Cache for next time\n  if (useCache) {\n    const cacheAvailable = await isModelCacheAvailable();\n    if (cacheAvailable) {\n      // Check storage capacity first\n      const { canCache, reason } = await checkStorageCapacity(modelData.byteLength);\n\n      if (canCache) {\n        log('Caching model for future use');\n        try {\n          await cacheModel(manifest.version, modelData, manifest.model);\n          log('Model cached successfully');\n        } catch (e) {\n          log(`Cache write failed (non-fatal): ${e}`);\n        }\n      } else {\n        log(`Skipping cache: ${reason}`);\n      }\n    }\n  }\n\n  return modelData;\n}\n\n/**\n * Load a bundled model with automatic corrupted cache recovery\n *\n * If loading fails for any reason (including corrupted cache),\n * this function clears the cache and retries the download.\n *\n * @param config - Loading configuration options\n * @returns Promise resolving to the model data as Uint8Array\n */\nexport async function loadBundledModelSafe(\n  config: BundledModelConfig = {}\n): Promise<Uint8Array> {\n  const { clearCache } = await import('./model-cache');\n  const verbose = config.verbose ?? false;\n  const log = (msg: string) => {\n    if (verbose) console.log(`[TEA-LLM] ${msg}`);\n  };\n\n  try {\n    return await loadBundledModel(config);\n  } catch (e) {\n    log(`Model load failed, clearing cache and retrying: ${e}`);\n    await clearCache();\n    return await loadBundledModel({ ...config, useCache: false });\n  }\n}\n", "// This file is generated by cpp/generate_glue_prototype.js\n// Do not edit this file directly\n\nimport type { GlueMessageProto } from './glue';\n\nexport const GLUE_VERSION = 1;\n\nexport const GLUE_MESSAGE_PROTOTYPES: { [name: string]: GlueMessageProto } = {\n  \"erro_evt\": {\n    \"name\": \"erro_evt\",\n    \"structName\": \"glue_msg_error\",\n    \"className\": \"GlueMsgError\",\n    \"fields\": [\n      {\n        \"type\": \"str\",\n        \"name\": \"message\",\n        \"isNullable\": false\n      }\n    ]\n  },\n  \"load_req\": {\n    \"name\": \"load_req\",\n    \"structName\": \"glue_msg_load_req\",\n    \"className\": \"GlueMsgLoadReq\",\n    \"fields\": [\n      {\n        \"type\": \"arr_str\",\n        \"name\": \"model_paths\",\n        \"isNullable\": false\n      },\n      {\n        \"type\": \"bool\",\n        \"name\": \"n_ctx_auto\",\n        \"isNullable\": false\n      },\n      {\n        \"type\": \"bool\",\n        \"name\": \"use_mmap\",\n        \"isNullable\": false\n      },\n      {\n        \"type\": \"bool\",\n        \"name\": \"use_mlock\",\n        \"isNullable\": false\n      },\n      {\n        \"type\": \"int\",\n        \"name\": \"n_gpu_layers\",\n        \"isNullable\": false\n      },\n      {\n        \"type\": \"int\",\n        \"name\": \"seed\",\n        \"isNullable\": false\n      },\n      {\n        \"type\": \"int\",\n        \"name\": \"n_ctx\",\n        \"isNullable\": false\n      },\n      {\n        \"type\": \"int\",\n        \"name\": \"n_threads\",\n        \"isNullable\": false\n      },\n      {\n        \"type\": \"bool\",\n        \"name\": \"embeddings\",\n        \"isNullable\": true\n      },\n      {\n        \"type\": \"bool\",\n        \"name\": \"offload_kqv\",\n        \"isNullable\": true\n      },\n      {\n        \"type\": \"int\",\n        \"name\": \"n_batch\",\n        \"isNullable\": true\n      },\n      {\n        \"type\": \"int\",\n        \"name\": \"n_seq_max\",\n        \"isNullable\": true\n      },\n      {\n        \"type\": \"str\",\n        \"name\": \"pooling_type\",\n        \"isNullable\": true\n      },\n      {\n        \"type\": \"str\",\n        \"name\": \"rope_scaling_type\",\n        \"isNullable\": true\n      },\n      {\n        \"type\": \"float\",\n        \"name\": \"rope_freq_base\",\n        \"isNullable\": true\n      },\n      {\n        \"type\": \"float\",\n        \"name\": \"rope_freq_scale\",\n        \"isNullable\": true\n      },\n      {\n        \"type\": \"float\",\n        \"name\": \"yarn_ext_factor\",\n        \"isNullable\": true\n      },\n      {\n        \"type\": \"float\",\n        \"name\": \"yarn_attn_factor\",\n        \"isNullable\": true\n      },\n      {\n        \"type\": \"float\",\n        \"name\": \"yarn_beta_fast\",\n        \"isNullable\": true\n      },\n      {\n        \"type\": \"float\",\n        \"name\": \"yarn_beta_slow\",\n        \"isNullable\": true\n      },\n      {\n        \"type\": \"int\",\n        \"name\": \"yarn_orig_ctx\",\n        \"isNullable\": true\n      },\n      {\n        \"type\": \"str\",\n        \"name\": \"cache_type_k\",\n        \"isNullable\": true\n      },\n      {\n        \"type\": \"str\",\n        \"name\": \"cache_type_v\",\n        \"isNullable\": true\n      },\n      {\n        \"type\": \"bool\",\n        \"name\": \"flash_attn\",\n        \"isNullable\": true\n      },\n      {\n        \"type\": \"bool\",\n        \"name\": \"swa_full\",\n        \"isNullable\": true\n      }\n    ]\n  },\n  \"load_res\": {\n    \"name\": \"load_res\",\n    \"structName\": \"glue_msg_load_res\",\n    \"className\": \"GlueMsgLoadRes\",\n    \"fields\": [\n      {\n        \"type\": \"bool\",\n        \"name\": \"success\",\n        \"isNullable\": false\n      },\n      {\n        \"type\": \"int\",\n        \"name\": \"n_ctx\",\n        \"isNullable\": false\n      },\n      {\n        \"type\": \"int\",\n        \"name\": \"n_batch\",\n        \"isNullable\": false\n      },\n      {\n        \"type\": \"int\",\n        \"name\": \"n_ubatch\",\n        \"isNullable\": false\n      },\n      {\n        \"type\": \"int\",\n        \"name\": \"n_vocab\",\n        \"isNullable\": false\n      },\n      {\n        \"type\": \"int\",\n        \"name\": \"n_ctx_train\",\n        \"isNullable\": false\n      },\n      {\n        \"type\": \"int\",\n        \"name\": \"n_embd\",\n        \"isNullable\": false\n      },\n      {\n        \"type\": \"int\",\n        \"name\": \"n_layer\",\n        \"isNullable\": false\n      },\n      {\n        \"type\": \"arr_str\",\n        \"name\": \"metadata_key\",\n        \"isNullable\": false\n      },\n      {\n        \"type\": \"arr_str\",\n        \"name\": \"metadata_val\",\n        \"isNullable\": false\n      },\n      {\n        \"type\": \"int\",\n        \"name\": \"token_bos\",\n        \"isNullable\": false\n      },\n      {\n        \"type\": \"int\",\n        \"name\": \"token_eos\",\n        \"isNullable\": false\n      },\n      {\n        \"type\": \"int\",\n        \"name\": \"token_eot\",\n        \"isNullable\": false\n      },\n      {\n        \"type\": \"arr_int\",\n        \"name\": \"list_tokens_eog\",\n        \"isNullable\": false\n      },\n      {\n        \"type\": \"bool\",\n        \"name\": \"add_bos_token\",\n        \"isNullable\": false\n      },\n      {\n        \"type\": \"bool\",\n        \"name\": \"add_eos_token\",\n        \"isNullable\": false\n      },\n      {\n        \"type\": \"bool\",\n        \"name\": \"has_encoder\",\n        \"isNullable\": false\n      },\n      {\n        \"type\": \"int\",\n        \"name\": \"token_decoder_start\",\n        \"isNullable\": false\n      }\n    ]\n  },\n  \"opti_req\": {\n    \"name\": \"opti_req\",\n    \"structName\": \"glue_msg_set_options_req\",\n    \"className\": \"GlueMsgSetOptionsReq\",\n    \"fields\": [\n      {\n        \"type\": \"bool\",\n        \"name\": \"embeddings\",\n        \"isNullable\": false\n      }\n    ]\n  },\n  \"opti_res\": {\n    \"name\": \"opti_res\",\n    \"structName\": \"glue_msg_set_options_res\",\n    \"className\": \"GlueMsgSetOptionsRes\",\n    \"fields\": [\n      {\n        \"type\": \"bool\",\n        \"name\": \"success\",\n        \"isNullable\": false\n      }\n    ]\n  },\n  \"sint_req\": {\n    \"name\": \"sint_req\",\n    \"structName\": \"glue_msg_sampling_init_req\",\n    \"className\": \"GlueMsgSamplingInitReq\",\n    \"fields\": [\n      {\n        \"type\": \"int\",\n        \"name\": \"mirostat\",\n        \"isNullable\": true\n      },\n      {\n        \"type\": \"float\",\n        \"name\": \"mirostat_tau\",\n        \"isNullable\": true\n      },\n      {\n        \"type\": \"float\",\n        \"name\": \"mirostat_eta\",\n        \"isNullable\": true\n      },\n      {\n        \"type\": \"float\",\n        \"name\": \"temp\",\n        \"isNullable\": true\n      },\n      {\n        \"type\": \"float\",\n        \"name\": \"top_p\",\n        \"isNullable\": true\n      },\n      {\n        \"type\": \"int\",\n        \"name\": \"top_k\",\n        \"isNullable\": true\n      },\n      {\n        \"type\": \"int\",\n        \"name\": \"penalty_last_n\",\n        \"isNullable\": true\n      },\n      {\n        \"type\": \"float\",\n        \"name\": \"penalty_repeat\",\n        \"isNullable\": true\n      },\n      {\n        \"type\": \"float\",\n        \"name\": \"penalty_freq\",\n        \"isNullable\": true\n      },\n      {\n        \"type\": \"float\",\n        \"name\": \"penalty_present\",\n        \"isNullable\": true\n      },\n      {\n        \"type\": \"float\",\n        \"name\": \"dynatemp_range\",\n        \"isNullable\": true\n      },\n      {\n        \"type\": \"float\",\n        \"name\": \"dynatemp_exponent\",\n        \"isNullable\": true\n      },\n      {\n        \"type\": \"arr_str\",\n        \"name\": \"samplers_sequence\",\n        \"isNullable\": true\n      },\n      {\n        \"type\": \"str\",\n        \"name\": \"grammar\",\n        \"isNullable\": true\n      },\n      {\n        \"type\": \"int\",\n        \"name\": \"n_prev\",\n        \"isNullable\": true\n      },\n      {\n        \"type\": \"int\",\n        \"name\": \"n_probs\",\n        \"isNullable\": true\n      },\n      {\n        \"type\": \"float\",\n        \"name\": \"min_p\",\n        \"isNullable\": true\n      },\n      {\n        \"type\": \"float\",\n        \"name\": \"typical_p\",\n        \"isNullable\": true\n      },\n      {\n        \"type\": \"float\",\n        \"name\": \"typ_p\",\n        \"isNullable\": true\n      },\n      {\n        \"type\": \"arr_int\",\n        \"name\": \"logit_bias_toks\",\n        \"isNullable\": true\n      },\n      {\n        \"type\": \"arr_float\",\n        \"name\": \"logit_bias_vals\",\n        \"isNullable\": true\n      },\n      {\n        \"type\": \"arr_int\",\n        \"name\": \"tokens\",\n        \"isNullable\": true\n      }\n    ]\n  },\n  \"sint_res\": {\n    \"name\": \"sint_res\",\n    \"structName\": \"glue_msg_sampling_init_res\",\n    \"className\": \"GlueMsgSamplingInitRes\",\n    \"fields\": [\n      {\n        \"type\": \"bool\",\n        \"name\": \"success\",\n        \"isNullable\": false\n      }\n    ]\n  },\n  \"gvoc_req\": {\n    \"name\": \"gvoc_req\",\n    \"structName\": \"glue_msg_get_vocab_req\",\n    \"className\": \"GlueMsgGetVocabReq\",\n    \"fields\": []\n  },\n  \"gvoc_res\": {\n    \"name\": \"gvoc_res\",\n    \"structName\": \"glue_msg_get_vocab_res\",\n    \"className\": \"GlueMsgGetVocabRes\",\n    \"fields\": [\n      {\n        \"type\": \"bool\",\n        \"name\": \"success\",\n        \"isNullable\": false\n      },\n      {\n        \"type\": \"arr_raw\",\n        \"name\": \"vocab\",\n        \"isNullable\": false\n      }\n    ]\n  },\n  \"lkup_req\": {\n    \"name\": \"lkup_req\",\n    \"structName\": \"glue_msg_lookup_token_req\",\n    \"className\": \"GlueMsgLookupTokenReq\",\n    \"fields\": [\n      {\n        \"type\": \"str\",\n        \"name\": \"piece\",\n        \"isNullable\": false\n      }\n    ]\n  },\n  \"lkup_res\": {\n    \"name\": \"lkup_res\",\n    \"structName\": \"glue_msg_lookup_token_res\",\n    \"className\": \"GlueMsgLookupTokenRes\",\n    \"fields\": [\n      {\n        \"type\": \"bool\",\n        \"name\": \"success\",\n        \"isNullable\": false\n      },\n      {\n        \"type\": \"int\",\n        \"name\": \"token\",\n        \"isNullable\": false\n      }\n    ]\n  },\n  \"tokn_req\": {\n    \"name\": \"tokn_req\",\n    \"structName\": \"glue_msg_tokenize_req\",\n    \"className\": \"GlueMsgTokenizeReq\",\n    \"fields\": [\n      {\n        \"type\": \"str\",\n        \"name\": \"text\",\n        \"isNullable\": false\n      },\n      {\n        \"type\": \"bool\",\n        \"name\": \"special\",\n        \"isNullable\": false\n      }\n    ]\n  },\n  \"tokn_res\": {\n    \"name\": \"tokn_res\",\n    \"structName\": \"glue_msg_tokenize_res\",\n    \"className\": \"GlueMsgTokenizeRes\",\n    \"fields\": [\n      {\n        \"type\": \"bool\",\n        \"name\": \"success\",\n        \"isNullable\": false\n      },\n      {\n        \"type\": \"arr_int\",\n        \"name\": \"tokens\",\n        \"isNullable\": false\n      }\n    ]\n  },\n  \"dtkn_req\": {\n    \"name\": \"dtkn_req\",\n    \"structName\": \"glue_msg_detokenize_req\",\n    \"className\": \"GlueMsgDetokenizeReq\",\n    \"fields\": [\n      {\n        \"type\": \"arr_int\",\n        \"name\": \"tokens\",\n        \"isNullable\": false\n      }\n    ]\n  },\n  \"dtkn_res\": {\n    \"name\": \"dtkn_res\",\n    \"structName\": \"glue_msg_detokenize_res\",\n    \"className\": \"GlueMsgDetokenizeRes\",\n    \"fields\": [\n      {\n        \"type\": \"bool\",\n        \"name\": \"success\",\n        \"isNullable\": false\n      },\n      {\n        \"type\": \"raw\",\n        \"name\": \"buffer\",\n        \"isNullable\": false\n      }\n    ]\n  },\n  \"deco_req\": {\n    \"name\": \"deco_req\",\n    \"structName\": \"glue_msg_decode_req\",\n    \"className\": \"GlueMsgDecodeReq\",\n    \"fields\": [\n      {\n        \"type\": \"arr_int\",\n        \"name\": \"tokens\",\n        \"isNullable\": false\n      },\n      {\n        \"type\": \"bool\",\n        \"name\": \"skip_logits\",\n        \"isNullable\": false\n      }\n    ]\n  },\n  \"deco_res\": {\n    \"name\": \"deco_res\",\n    \"structName\": \"glue_msg_decode_res\",\n    \"className\": \"GlueMsgDecodeRes\",\n    \"fields\": [\n      {\n        \"type\": \"bool\",\n        \"name\": \"success\",\n        \"isNullable\": false\n      },\n      {\n        \"type\": \"str\",\n        \"name\": \"message\",\n        \"isNullable\": false\n      },\n      {\n        \"type\": \"int\",\n        \"name\": \"n_past\",\n        \"isNullable\": false\n      }\n    ]\n  },\n  \"enco_req\": {\n    \"name\": \"enco_req\",\n    \"structName\": \"glue_msg_encode_req\",\n    \"className\": \"GlueMsgEncodeReq\",\n    \"fields\": [\n      {\n        \"type\": \"arr_int\",\n        \"name\": \"tokens\",\n        \"isNullable\": false\n      }\n    ]\n  },\n  \"enco_res\": {\n    \"name\": \"enco_res\",\n    \"structName\": \"glue_msg_encode_res\",\n    \"className\": \"GlueMsgEncodeRes\",\n    \"fields\": [\n      {\n        \"type\": \"bool\",\n        \"name\": \"success\",\n        \"isNullable\": false\n      },\n      {\n        \"type\": \"str\",\n        \"name\": \"message\",\n        \"isNullable\": false\n      },\n      {\n        \"type\": \"int\",\n        \"name\": \"n_past\",\n        \"isNullable\": false\n      }\n    ]\n  },\n  \"ssam_req\": {\n    \"name\": \"ssam_req\",\n    \"structName\": \"glue_msg_sampling_sample_req\",\n    \"className\": \"GlueMsgSamplingSampleReq\",\n    \"fields\": []\n  },\n  \"ssam_res\": {\n    \"name\": \"ssam_res\",\n    \"structName\": \"glue_msg_sampling_sample_res\",\n    \"className\": \"GlueMsgSamplingSampleRes\",\n    \"fields\": [\n      {\n        \"type\": \"bool\",\n        \"name\": \"success\",\n        \"isNullable\": false\n      },\n      {\n        \"type\": \"raw\",\n        \"name\": \"piece\",\n        \"isNullable\": false\n      },\n      {\n        \"type\": \"int\",\n        \"name\": \"token\",\n        \"isNullable\": false\n      }\n    ]\n  },\n  \"sacc_req\": {\n    \"name\": \"sacc_req\",\n    \"structName\": \"glue_msg_sampling_accept_req\",\n    \"className\": \"GlueMsgSamplingAcceptReq\",\n    \"fields\": [\n      {\n        \"type\": \"arr_int\",\n        \"name\": \"tokens\",\n        \"isNullable\": false\n      }\n    ]\n  },\n  \"sacc_res\": {\n    \"name\": \"sacc_res\",\n    \"structName\": \"glue_msg_sampling_accept_res\",\n    \"className\": \"GlueMsgSamplingAcceptRes\",\n    \"fields\": [\n      {\n        \"type\": \"bool\",\n        \"name\": \"success\",\n        \"isNullable\": false\n      }\n    ]\n  },\n  \"glog_req\": {\n    \"name\": \"glog_req\",\n    \"structName\": \"glue_msg_get_logits_req\",\n    \"className\": \"GlueMsgGetLogitsReq\",\n    \"fields\": [\n      {\n        \"type\": \"int\",\n        \"name\": \"top_k\",\n        \"isNullable\": false\n      }\n    ]\n  },\n  \"glog_res\": {\n    \"name\": \"glog_res\",\n    \"structName\": \"glue_msg_get_logits_res\",\n    \"className\": \"GlueMsgGetLogitsRes\",\n    \"fields\": [\n      {\n        \"type\": \"bool\",\n        \"name\": \"success\",\n        \"isNullable\": false\n      },\n      {\n        \"type\": \"arr_int\",\n        \"name\": \"tokens\",\n        \"isNullable\": false\n      },\n      {\n        \"type\": \"arr_float\",\n        \"name\": \"probs\",\n        \"isNullable\": false\n      }\n    ]\n  },\n  \"gemb_req\": {\n    \"name\": \"gemb_req\",\n    \"structName\": \"glue_msg_get_embeddings_req\",\n    \"className\": \"GlueMsgGetEmbeddingsReq\",\n    \"fields\": [\n      {\n        \"type\": \"arr_int\",\n        \"name\": \"tokens\",\n        \"isNullable\": false\n      }\n    ]\n  },\n  \"gemb_res\": {\n    \"name\": \"gemb_res\",\n    \"structName\": \"glue_msg_get_embeddings_res\",\n    \"className\": \"GlueMsgGetEmbeddingsRes\",\n    \"fields\": [\n      {\n        \"type\": \"bool\",\n        \"name\": \"success\",\n        \"isNullable\": false\n      },\n      {\n        \"type\": \"str\",\n        \"name\": \"message\",\n        \"isNullable\": false\n      },\n      {\n        \"type\": \"arr_float\",\n        \"name\": \"embeddings\",\n        \"isNullable\": false\n      }\n    ]\n  },\n  \"kvcr_req\": {\n    \"name\": \"kvcr_req\",\n    \"structName\": \"glue_msg_get_kv_remove_req\",\n    \"className\": \"GlueMsgGetKvRemoveReq\",\n    \"fields\": [\n      {\n        \"type\": \"int\",\n        \"name\": \"n_keep\",\n        \"isNullable\": false\n      },\n      {\n        \"type\": \"int\",\n        \"name\": \"n_discard\",\n        \"isNullable\": false\n      }\n    ]\n  },\n  \"kvcr_res\": {\n    \"name\": \"kvcr_res\",\n    \"structName\": \"glue_msg_get_kv_remove_res\",\n    \"className\": \"GlueMsgGetKvRemoveRes\",\n    \"fields\": [\n      {\n        \"type\": \"int\",\n        \"name\": \"n_past\",\n        \"isNullable\": false\n      },\n      {\n        \"type\": \"bool\",\n        \"name\": \"success\",\n        \"isNullable\": false\n      }\n    ]\n  },\n  \"kvcc_req\": {\n    \"name\": \"kvcc_req\",\n    \"structName\": \"glue_msg_get_kv_clear_req\",\n    \"className\": \"GlueMsgGetKvClearReq\",\n    \"fields\": []\n  },\n  \"kvcc_res\": {\n    \"name\": \"kvcc_res\",\n    \"structName\": \"glue_msg_get_kv_clear_res\",\n    \"className\": \"GlueMsgGetKvClearRes\",\n    \"fields\": [\n      {\n        \"type\": \"int\",\n        \"name\": \"n_past\",\n        \"isNullable\": false\n      },\n      {\n        \"type\": \"bool\",\n        \"name\": \"success\",\n        \"isNullable\": false\n      }\n    ]\n  },\n  \"sesa_req\": {\n    \"name\": \"sesa_req\",\n    \"structName\": \"glue_msg_session_save_req\",\n    \"className\": \"GlueMsgSessionSaveReq\",\n    \"fields\": [\n      {\n        \"type\": \"str\",\n        \"name\": \"session_path\",\n        \"isNullable\": false\n      }\n    ]\n  },\n  \"sesa_res\": {\n    \"name\": \"sesa_res\",\n    \"structName\": \"glue_msg_session_save_res\",\n    \"className\": \"GlueMsgSessionSaveRes\",\n    \"fields\": [\n      {\n        \"type\": \"bool\",\n        \"name\": \"success\",\n        \"isNullable\": false\n      },\n      {\n        \"type\": \"arr_int\",\n        \"name\": \"tokens\",\n        \"isNullable\": false\n      }\n    ]\n  },\n  \"sesl_req\": {\n    \"name\": \"sesl_req\",\n    \"structName\": \"glue_msg_session_load_req\",\n    \"className\": \"GlueMsgSessionLoadReq\",\n    \"fields\": [\n      {\n        \"type\": \"str\",\n        \"name\": \"session_path\",\n        \"isNullable\": false\n      },\n      {\n        \"type\": \"arr_int\",\n        \"name\": \"tokens\",\n        \"isNullable\": false\n      }\n    ]\n  },\n  \"sesl_res\": {\n    \"name\": \"sesl_res\",\n    \"structName\": \"glue_msg_session_load_res\",\n    \"className\": \"GlueMsgSessionLoadRes\",\n    \"fields\": [\n      {\n        \"type\": \"bool\",\n        \"name\": \"success\",\n        \"isNullable\": false\n      }\n    ]\n  },\n  \"stat_req\": {\n    \"name\": \"stat_req\",\n    \"structName\": \"glue_msg_status_req\",\n    \"className\": \"GlueMsgStatusReq\",\n    \"fields\": []\n  },\n  \"stat_res\": {\n    \"name\": \"stat_res\",\n    \"structName\": \"glue_msg_status_res\",\n    \"className\": \"GlueMsgStatusRes\",\n    \"fields\": [\n      {\n        \"type\": \"bool\",\n        \"name\": \"success\",\n        \"isNullable\": false\n      },\n      {\n        \"type\": \"arr_int\",\n        \"name\": \"tokens\",\n        \"isNullable\": false\n      }\n    ]\n  },\n  \"tben_req\": {\n    \"name\": \"tben_req\",\n    \"structName\": \"glue_msg_test_benchmark_req\",\n    \"className\": \"GlueMsgTestBenchmarkReq\",\n    \"fields\": [\n      {\n        \"type\": \"str\",\n        \"name\": \"type\",\n        \"isNullable\": false\n      },\n      {\n        \"type\": \"int\",\n        \"name\": \"n_samples\",\n        \"isNullable\": false\n      }\n    ]\n  },\n  \"tben_res\": {\n    \"name\": \"tben_res\",\n    \"structName\": \"glue_msg_test_benchmark_res\",\n    \"className\": \"GlueMsgTestBenchmarkRes\",\n    \"fields\": [\n      {\n        \"type\": \"bool\",\n        \"name\": \"success\",\n        \"isNullable\": false\n      },\n      {\n        \"type\": \"str\",\n        \"name\": \"message\",\n        \"isNullable\": false\n      },\n      {\n        \"type\": \"int\",\n        \"name\": \"t_ms\",\n        \"isNullable\": false\n      }\n    ]\n  },\n  \"tper_req\": {\n    \"name\": \"tper_req\",\n    \"structName\": \"glue_msg_test_perplexity_req\",\n    \"className\": \"GlueMsgTestPerplexityReq\",\n    \"fields\": [\n      {\n        \"type\": \"arr_int\",\n        \"name\": \"tokens\",\n        \"isNullable\": false\n      }\n    ]\n  },\n  \"tper_res\": {\n    \"name\": \"tper_res\",\n    \"structName\": \"glue_msg_test_perplexity_res\",\n    \"className\": \"GlueMsgTestPerplexityRes\",\n    \"fields\": [\n      {\n        \"type\": \"bool\",\n        \"name\": \"success\",\n        \"isNullable\": false\n      },\n      {\n        \"type\": \"str\",\n        \"name\": \"message\",\n        \"isNullable\": false\n      },\n      {\n        \"type\": \"float\",\n        \"name\": \"ppl\",\n        \"isNullable\": false\n      },\n      {\n        \"type\": \"float\",\n        \"name\": \"nll\",\n        \"isNullable\": false\n      },\n      {\n        \"type\": \"float\",\n        \"name\": \"cross_entropy\",\n        \"isNullable\": false\n      },\n      {\n        \"type\": \"int\",\n        \"name\": \"n_tokens\",\n        \"isNullable\": false\n      },\n      {\n        \"type\": \"int\",\n        \"name\": \"t_ms\",\n        \"isNullable\": false\n      }\n    ]\n  },\n  \"cfmt_req\": {\n    \"name\": \"cfmt_req\",\n    \"structName\": \"glue_msg_chat_format_req\",\n    \"className\": \"GlueMsgChatFormatReq\",\n    \"fields\": [\n      {\n        \"type\": \"str\",\n        \"name\": \"tmpl\",\n        \"isNullable\": true\n      },\n      {\n        \"type\": \"bool\",\n        \"name\": \"add_ass\",\n        \"isNullable\": true\n      },\n      {\n        \"type\": \"arr_str\",\n        \"name\": \"roles\",\n        \"isNullable\": false\n      },\n      {\n        \"type\": \"arr_str\",\n        \"name\": \"contents\",\n        \"isNullable\": false\n      }\n    ]\n  },\n  \"cfmt_res\": {\n    \"name\": \"cfmt_res\",\n    \"structName\": \"glue_msg_chat_format_res\",\n    \"className\": \"GlueMsgChatFormatRes\",\n    \"fields\": [\n      {\n        \"type\": \"bool\",\n        \"name\": \"success\",\n        \"isNullable\": false\n      },\n      {\n        \"type\": \"str\",\n        \"name\": \"message\",\n        \"isNullable\": false\n      },\n      {\n        \"type\": \"str\",\n        \"name\": \"formatted_chat\",\n        \"isNullable\": false\n      }\n    ]\n  }\n};\n\n// struct glue_msg_error\nexport interface GlueMsgError {\n  _name: \"erro_evt\";\n  message: string;\n}\n\n// struct glue_msg_load_req\nexport interface GlueMsgLoadReq {\n  _name: \"load_req\";\n  model_paths: string[];\n  n_ctx_auto: boolean;\n  use_mmap: boolean;\n  use_mlock: boolean;\n  n_gpu_layers: number;\n  seed: number;\n  n_ctx: number;\n  n_threads: number;\n  embeddings?: boolean | undefined;\n  offload_kqv?: boolean | undefined;\n  n_batch?: number | undefined;\n  n_seq_max?: number | undefined;\n  pooling_type?: string | undefined;\n  rope_scaling_type?: string | undefined;\n  rope_freq_base?: number | undefined;\n  rope_freq_scale?: number | undefined;\n  yarn_ext_factor?: number | undefined;\n  yarn_attn_factor?: number | undefined;\n  yarn_beta_fast?: number | undefined;\n  yarn_beta_slow?: number | undefined;\n  yarn_orig_ctx?: number | undefined;\n  cache_type_k?: string | undefined;\n  cache_type_v?: string | undefined;\n  flash_attn?: boolean | undefined;\n  swa_full?: boolean | undefined;\n}\n\n// struct glue_msg_load_res\nexport interface GlueMsgLoadRes {\n  _name: \"load_res\";\n  success: boolean;\n  n_ctx: number;\n  n_batch: number;\n  n_ubatch: number;\n  n_vocab: number;\n  n_ctx_train: number;\n  n_embd: number;\n  n_layer: number;\n  metadata_key: string[];\n  metadata_val: string[];\n  token_bos: number;\n  token_eos: number;\n  token_eot: number;\n  list_tokens_eog: number[];\n  add_bos_token: boolean;\n  add_eos_token: boolean;\n  has_encoder: boolean;\n  token_decoder_start: number;\n}\n\n// struct glue_msg_set_options_req\nexport interface GlueMsgSetOptionsReq {\n  _name: \"opti_req\";\n  embeddings: boolean;\n}\n\n// struct glue_msg_set_options_res\nexport interface GlueMsgSetOptionsRes {\n  _name: \"opti_res\";\n  success: boolean;\n}\n\n// struct glue_msg_sampling_init_req\nexport interface GlueMsgSamplingInitReq {\n  _name: \"sint_req\";\n  mirostat?: number | undefined;\n  mirostat_tau?: number | undefined;\n  mirostat_eta?: number | undefined;\n  temp?: number | undefined;\n  top_p?: number | undefined;\n  top_k?: number | undefined;\n  penalty_last_n?: number | undefined;\n  penalty_repeat?: number | undefined;\n  penalty_freq?: number | undefined;\n  penalty_present?: number | undefined;\n  dynatemp_range?: number | undefined;\n  dynatemp_exponent?: number | undefined;\n  samplers_sequence?: string[] | undefined;\n  grammar?: string | undefined;\n  n_prev?: number | undefined;\n  n_probs?: number | undefined;\n  min_p?: number | undefined;\n  typical_p?: number | undefined;\n  typ_p?: number | undefined;\n  logit_bias_toks?: number[] | undefined;\n  logit_bias_vals?: number[] | undefined;\n  tokens?: number[] | undefined;\n}\n\n// struct glue_msg_sampling_init_res\nexport interface GlueMsgSamplingInitRes {\n  _name: \"sint_res\";\n  success: boolean;\n}\n\n// struct glue_msg_get_vocab_req\nexport interface GlueMsgGetVocabReq {\n  _name: \"gvoc_req\";\n}\n\n// struct glue_msg_get_vocab_res\nexport interface GlueMsgGetVocabRes {\n  _name: \"gvoc_res\";\n  success: boolean;\n  vocab: Uint8Array[];\n}\n\n// struct glue_msg_lookup_token_req\nexport interface GlueMsgLookupTokenReq {\n  _name: \"lkup_req\";\n  piece: string;\n}\n\n// struct glue_msg_lookup_token_res\nexport interface GlueMsgLookupTokenRes {\n  _name: \"lkup_res\";\n  success: boolean;\n  token: number;\n}\n\n// struct glue_msg_tokenize_req\nexport interface GlueMsgTokenizeReq {\n  _name: \"tokn_req\";\n  text: string;\n  special: boolean;\n}\n\n// struct glue_msg_tokenize_res\nexport interface GlueMsgTokenizeRes {\n  _name: \"tokn_res\";\n  success: boolean;\n  tokens: number[];\n}\n\n// struct glue_msg_detokenize_req\nexport interface GlueMsgDetokenizeReq {\n  _name: \"dtkn_req\";\n  tokens: number[];\n}\n\n// struct glue_msg_detokenize_res\nexport interface GlueMsgDetokenizeRes {\n  _name: \"dtkn_res\";\n  success: boolean;\n  buffer: Uint8Array;\n}\n\n// struct glue_msg_decode_req\nexport interface GlueMsgDecodeReq {\n  _name: \"deco_req\";\n  tokens: number[];\n  skip_logits: boolean;\n}\n\n// struct glue_msg_decode_res\nexport interface GlueMsgDecodeRes {\n  _name: \"deco_res\";\n  success: boolean;\n  message: string;\n  n_past: number;\n}\n\n// struct glue_msg_encode_req\nexport interface GlueMsgEncodeReq {\n  _name: \"enco_req\";\n  tokens: number[];\n}\n\n// struct glue_msg_encode_res\nexport interface GlueMsgEncodeRes {\n  _name: \"enco_res\";\n  success: boolean;\n  message: string;\n  n_past: number;\n}\n\n// struct glue_msg_sampling_sample_req\nexport interface GlueMsgSamplingSampleReq {\n  _name: \"ssam_req\";\n}\n\n// struct glue_msg_sampling_sample_res\nexport interface GlueMsgSamplingSampleRes {\n  _name: \"ssam_res\";\n  success: boolean;\n  piece: Uint8Array;\n  token: number;\n}\n\n// struct glue_msg_sampling_accept_req\nexport interface GlueMsgSamplingAcceptReq {\n  _name: \"sacc_req\";\n  tokens: number[];\n}\n\n// struct glue_msg_sampling_accept_res\nexport interface GlueMsgSamplingAcceptRes {\n  _name: \"sacc_res\";\n  success: boolean;\n}\n\n// struct glue_msg_get_logits_req\nexport interface GlueMsgGetLogitsReq {\n  _name: \"glog_req\";\n  top_k: number;\n}\n\n// struct glue_msg_get_logits_res\nexport interface GlueMsgGetLogitsRes {\n  _name: \"glog_res\";\n  success: boolean;\n  tokens: number[];\n  probs: number[];\n}\n\n// struct glue_msg_get_embeddings_req\nexport interface GlueMsgGetEmbeddingsReq {\n  _name: \"gemb_req\";\n  tokens: number[];\n}\n\n// struct glue_msg_get_embeddings_res\nexport interface GlueMsgGetEmbeddingsRes {\n  _name: \"gemb_res\";\n  success: boolean;\n  message: string;\n  embeddings: number[];\n}\n\n// struct glue_msg_get_kv_remove_req\nexport interface GlueMsgGetKvRemoveReq {\n  _name: \"kvcr_req\";\n  n_keep: number;\n  n_discard: number;\n}\n\n// struct glue_msg_get_kv_remove_res\nexport interface GlueMsgGetKvRemoveRes {\n  _name: \"kvcr_res\";\n  n_past: number;\n  success: boolean;\n}\n\n// struct glue_msg_get_kv_clear_req\nexport interface GlueMsgGetKvClearReq {\n  _name: \"kvcc_req\";\n}\n\n// struct glue_msg_get_kv_clear_res\nexport interface GlueMsgGetKvClearRes {\n  _name: \"kvcc_res\";\n  n_past: number;\n  success: boolean;\n}\n\n// struct glue_msg_session_save_req\nexport interface GlueMsgSessionSaveReq {\n  _name: \"sesa_req\";\n  session_path: string;\n}\n\n// struct glue_msg_session_save_res\nexport interface GlueMsgSessionSaveRes {\n  _name: \"sesa_res\";\n  success: boolean;\n  tokens: number[];\n}\n\n// struct glue_msg_session_load_req\nexport interface GlueMsgSessionLoadReq {\n  _name: \"sesl_req\";\n  session_path: string;\n  tokens: number[];\n}\n\n// struct glue_msg_session_load_res\nexport interface GlueMsgSessionLoadRes {\n  _name: \"sesl_res\";\n  success: boolean;\n}\n\n// struct glue_msg_status_req\nexport interface GlueMsgStatusReq {\n  _name: \"stat_req\";\n}\n\n// struct glue_msg_status_res\nexport interface GlueMsgStatusRes {\n  _name: \"stat_res\";\n  success: boolean;\n  tokens: number[];\n}\n\n// struct glue_msg_test_benchmark_req\nexport interface GlueMsgTestBenchmarkReq {\n  _name: \"tben_req\";\n  type: string;\n  n_samples: number;\n}\n\n// struct glue_msg_test_benchmark_res\nexport interface GlueMsgTestBenchmarkRes {\n  _name: \"tben_res\";\n  success: boolean;\n  message: string;\n  t_ms: number;\n}\n\n// struct glue_msg_test_perplexity_req\nexport interface GlueMsgTestPerplexityReq {\n  _name: \"tper_req\";\n  tokens: number[];\n}\n\n// struct glue_msg_test_perplexity_res\nexport interface GlueMsgTestPerplexityRes {\n  _name: \"tper_res\";\n  success: boolean;\n  message: string;\n  ppl: number;\n  nll: number;\n  cross_entropy: number;\n  n_tokens: number;\n  t_ms: number;\n}\n\n// struct glue_msg_chat_format_req\nexport interface GlueMsgChatFormatReq {\n  _name: \"cfmt_req\";\n  tmpl?: string | undefined;\n  add_ass?: boolean | undefined;\n  roles: string[];\n  contents: string[];\n}\n\n// struct glue_msg_chat_format_res\nexport interface GlueMsgChatFormatRes {\n  _name: \"cfmt_res\";\n  success: boolean;\n  message: string;\n  formatted_chat: string;\n}\n\n\nexport type GlueMsg = GlueMsgError | GlueMsgLoadReq | GlueMsgLoadRes | GlueMsgSetOptionsReq | GlueMsgSetOptionsRes | GlueMsgSamplingInitReq | GlueMsgSamplingInitRes | GlueMsgGetVocabReq | GlueMsgGetVocabRes | GlueMsgLookupTokenReq | GlueMsgLookupTokenRes | GlueMsgTokenizeReq | GlueMsgTokenizeRes | GlueMsgDetokenizeReq | GlueMsgDetokenizeRes | GlueMsgDecodeReq | GlueMsgDecodeRes | GlueMsgEncodeReq | GlueMsgEncodeRes | GlueMsgSamplingSampleReq | GlueMsgSamplingSampleRes | GlueMsgSamplingAcceptReq | GlueMsgSamplingAcceptRes | GlueMsgGetLogitsReq | GlueMsgGetLogitsRes | GlueMsgGetEmbeddingsReq | GlueMsgGetEmbeddingsRes | GlueMsgGetKvRemoveReq | GlueMsgGetKvRemoveRes | GlueMsgGetKvClearReq | GlueMsgGetKvClearRes | GlueMsgSessionSaveReq | GlueMsgSessionSaveRes | GlueMsgSessionLoadReq | GlueMsgSessionLoadRes | GlueMsgStatusReq | GlueMsgStatusRes | GlueMsgTestBenchmarkReq | GlueMsgTestBenchmarkRes | GlueMsgTestPerplexityReq | GlueMsgTestPerplexityRes | GlueMsgChatFormatReq | GlueMsgChatFormatRes;\n", "import {\n  GLUE_MESSAGE_PROTOTYPES,\n  GLUE_VERSION,\n  type GlueMsg,\n} from './messages';\n\n/**\n * Glue is a simple binary protocol for serializing and deserializing messages.\n * It is inspired by protobuf, but much simpler.\n *\n * Interested in extending Glue? Open an issue on GitHub!\n */\n\ntype GlueType =\n  | 'str'\n  | 'int'\n  | 'float'\n  | 'bool'\n  | 'raw'\n  | 'arr_str'\n  | 'arr_int'\n  | 'arr_float'\n  | 'arr_bool'\n  | 'arr_raw'\n  | 'null';\n\nconst GLUE_MAGIC = new Uint8Array([71, 76, 85, 69]);\n\nexport interface GlueField {\n  type: GlueType;\n  name: string;\n  isNullable: boolean;\n}\n\nexport interface GlueMessageProto {\n  name: string;\n  structName: string;\n  className: string;\n  fields: GlueField[];\n}\n\nconst GLUE_DTYPE_NULL = 0;\nconst GLUE_DTYPE_BOOL = 1;\nconst GLUE_DTYPE_INT = 2;\nconst GLUE_DTYPE_FLOAT = 3;\nconst GLUE_DTYPE_STRING = 4;\nconst GLUE_DTYPE_RAW = 5;\nconst GLUE_DTYPE_ARRAY_BOOL = 6;\nconst GLUE_DTYPE_ARRAY_INT = 7;\nconst GLUE_DTYPE_ARRAY_FLOAT = 8;\nconst GLUE_DTYPE_ARRAY_STRING = 9;\nconst GLUE_DTYPE_ARRAY_RAW = 10;\n\nconst TYPE_MAP: Record<GlueType, number> = {\n  str: GLUE_DTYPE_STRING,\n  int: GLUE_DTYPE_INT,\n  float: GLUE_DTYPE_FLOAT,\n  bool: GLUE_DTYPE_BOOL,\n  raw: GLUE_DTYPE_RAW,\n  arr_str: GLUE_DTYPE_ARRAY_STRING,\n  arr_int: GLUE_DTYPE_ARRAY_INT,\n  arr_float: GLUE_DTYPE_ARRAY_FLOAT,\n  arr_bool: GLUE_DTYPE_ARRAY_BOOL,\n  arr_raw: GLUE_DTYPE_ARRAY_RAW,\n  null: GLUE_DTYPE_NULL,\n};\n\nexport function glueDeserialize(buf: Uint8Array): GlueMsg {\n  let offset = 0;\n  const view = new DataView(buf.buffer);\n  const readUint32 = () => {\n    const value = view.getUint32(offset, true);\n    offset += 4;\n    return value;\n  };\n  const readInt32 = () => {\n    const value = view.getInt32(offset, true);\n    offset += 4;\n    return value;\n  };\n  const readFloat = () => {\n    const value = view.getFloat32(offset, true);\n    offset += 4;\n    return value;\n  };\n  const readBool = () => {\n    return readUint32() !== 0;\n  };\n  const readString = (customLen?: number) => {\n    const length = customLen ?? readUint32();\n    const value = new TextDecoder().decode(buf.slice(offset, offset + length));\n    offset += length;\n    return value;\n  };\n  const readRaw = () => {\n    const length = readUint32();\n    const value = buf.slice(offset, offset + length);\n    offset += length;\n    return value;\n  };\n  const readArray = (readItem: () => any) => {\n    const length = readUint32();\n    const value = new Array(length);\n    for (let i = 0; i < length; i++) {\n      value[i] = readItem();\n    }\n    return value;\n  };\n  const readNull = () => null;\n\n  const readField = (field: GlueField) => {\n    switch (field.type) {\n      case 'str':\n        return readString();\n      case 'int':\n        return readInt32();\n      case 'float':\n        return readFloat();\n      case 'bool':\n        return readBool();\n      case 'raw':\n        return readRaw();\n      case 'arr_str':\n        return readArray(readString);\n      case 'arr_int':\n        return readArray(readInt32);\n      case 'arr_float':\n        return readArray(readFloat);\n      case 'arr_bool':\n        return readArray(readBool);\n      case 'arr_raw':\n        return readArray(readRaw);\n      case 'null':\n        return readNull();\n    }\n  };\n\n  const magicValid =\n    buf[0] === GLUE_MAGIC[0] &&\n    buf[1] === GLUE_MAGIC[1] &&\n    buf[2] === GLUE_MAGIC[2] &&\n    buf[3] === GLUE_MAGIC[3];\n  offset += 4;\n  if (!magicValid) {\n    throw new Error('Invalid magic number');\n  }\n\n  const version = readUint32();\n  if (version !== GLUE_VERSION) {\n    throw new Error('Invalid version number');\n  }\n\n  const name = readString(8);\n  const msgProto = GLUE_MESSAGE_PROTOTYPES[name];\n  if (!msgProto) {\n    throw new Error(`Unknown message name: ${name}`);\n  }\n\n  const output: any = { _name: name };\n  for (const field of msgProto.fields) {\n    const readType = readUint32();\n    if (readType === GLUE_DTYPE_NULL) {\n      if (!field.isNullable) {\n        throw new Error(\n          `${name}: Expect field ${field.name} to be non-nullable`\n        );\n      }\n      output[field.name] = null;\n      continue;\n    }\n    if (readType !== TYPE_MAP[field.type]) {\n      throw new Error(\n        `${name}: Expect field ${field.name} to have type ${field.type}`\n      );\n    }\n    output[field.name] = readField(field);\n  }\n\n  return output;\n}\n\nexport function glueSerialize(msg: GlueMsg): Uint8Array {\n  const msgProto = GLUE_MESSAGE_PROTOTYPES[msg._name];\n  if (!msgProto) {\n    throw new Error(`Unknown message name: ${msg._name}`);\n  }\n\n  const bufs: Uint8Array[] = [];\n\n  const writeUint32 = (value: number) => {\n    const buf = new ArrayBuffer(4);\n    new DataView(buf).setUint32(0, value, true);\n    bufs.push(new Uint8Array(buf));\n  };\n  const writeInt32 = (value: number) => {\n    const buf = new ArrayBuffer(4);\n    new DataView(buf).setInt32(0, value, true);\n    bufs.push(new Uint8Array(buf));\n  };\n  const writeFloat = (value: number) => {\n    const buf = new ArrayBuffer(4);\n    new DataView(buf).setFloat32(0, value, true);\n    bufs.push(new Uint8Array(buf));\n  };\n  const writeBool = (value: boolean) => {\n    writeUint32(value ? 1 : 0);\n  };\n  const writeString = (value: string) => {\n    const utf8 = new TextEncoder().encode(value);\n    writeUint32(utf8.byteLength);\n    bufs.push(utf8);\n  };\n  const writeRaw = (value: Uint8Array) => {\n    writeUint32(value.byteLength);\n    bufs.push(value);\n  };\n  const writeArray = (value: any[], writeItem: (item: any) => void) => {\n    writeUint32(value.length);\n    for (const item of value) {\n      writeItem(item);\n    }\n  };\n  const writeNull = () => {};\n\n  //////////////////\n\n  bufs.push(GLUE_MAGIC);\n  writeUint32(GLUE_VERSION);\n  {\n    // write proto ID\n    const utf8 = new TextEncoder().encode(msg._name);\n    bufs.push(utf8);\n  }\n  for (const field of msgProto.fields) {\n    const val = (msg as any)[field.name];\n    if (!field.isNullable && (val === null || val === undefined)) {\n      throw new Error(\n        `${msg._name}: Expect field ${field.name} to be non-nullable`\n      );\n    }\n    if (val === null || val === undefined) {\n      writeUint32(GLUE_DTYPE_NULL);\n      continue;\n    }\n    writeUint32(TYPE_MAP[field.type]);\n    switch (field.type) {\n      case 'str':\n        writeString(val);\n        break;\n      case 'int':\n        writeInt32(val);\n        break;\n      case 'float':\n        writeFloat(val);\n        break;\n      case 'bool':\n        writeBool(val);\n        break;\n      case 'raw':\n        writeRaw(val);\n        break;\n      case 'arr_str':\n        writeArray(val, writeString);\n        break;\n      case 'arr_int':\n        writeArray(val, writeInt32);\n        break;\n      case 'arr_float':\n        writeArray(val, writeFloat);\n        break;\n      case 'arr_bool':\n        writeArray(val, writeBool);\n        break;\n      case 'arr_raw':\n        writeArray(val, writeRaw);\n        break;\n      case 'null':\n        writeNull();\n        break;\n    }\n  }\n\n  const totalLength = bufs.reduce((acc, buf) => acc + buf.byteLength, 0);\n  const output = new Uint8Array(totalLength);\n  let offset = 0;\n  for (const buf of bufs) {\n    output.set(buf, offset);\n    offset += buf.byteLength;\n  }\n  return output;\n}\n", "export const joinBuffers = (buffers: Uint8Array[]): Uint8Array => {\n  const totalSize = buffers.reduce((acc, buf) => acc + buf.length, 0);\n  const output = new Uint8Array(totalSize);\n  output.set(buffers[0], 0);\n  for (let i = 1; i < buffers.length; i++) {\n    output.set(buffers[i], buffers[i - 1].length);\n  }\n  return output;\n};\n\nconst textDecoder = new TextDecoder();\n\n/**\n * Convert list of bytes (number) to text\n * @param buffer\n * @returns a string\n */\nexport const bufToText = (buffer: ArrayBuffer | Uint8Array): string => {\n  return textDecoder.decode(buffer);\n};\n\n/**\n * Get default stdout/stderr config for wasm module\n */\nexport const getWModuleConfig = (pathConfig: {\n  [filename: string]: string;\n}) => {\n  return {\n    noInitialRun: true,\n    print: function (text: any) {\n      if (arguments.length > 1)\n        text = Array.prototype.slice.call(arguments).join(' ');\n      console.log(text);\n    },\n    printErr: function (text: any) {\n      if (arguments.length > 1)\n        text = Array.prototype.slice.call(arguments).join(' ');\n      console.warn(text);\n    },\n    // @ts-ignore\n    locateFile: function (filename: string, basePath: string) {\n      const p = pathConfig[filename];\n      console.log(`Loading \"${filename}\" from \"${p}\"`);\n      return p;\n    },\n  };\n};\n\nexport interface ShardInfo {\n  baseURL: string;\n  current: number;\n  total: number;\n}\n\nconst URL_PARTS_REGEX = /-(\\d{5})-of-(\\d{5})\\.gguf(?:\\?.*)?$/;\n\n/**\n * Parse shard number and total from a file name or URL\n */\nexport const parseShardNumber = (fnameOrUrl: string): ShardInfo => {\n  const matches = fnameOrUrl.match(URL_PARTS_REGEX);\n  if (!matches) {\n    return {\n      baseURL: fnameOrUrl,\n      current: 1,\n      total: 1,\n    };\n  } else {\n    return {\n      baseURL: fnameOrUrl.replace(URL_PARTS_REGEX, ''),\n      current: parseInt(matches[1]),\n      total: parseInt(matches[2]),\n    };\n  }\n};\n\n/**\n * Parses a model URL and returns an array of URLs based on the following patterns:\n * - If the input URL is an array, it returns the array itself.\n * - If the input URL is a string in the `gguf-split` format, it returns an array containing the URL of each shard in ascending order.\n * - Otherwise, it returns an array containing the input URL as a single element array.\n * @param modelUrl URL or list of URLs\n */\nexport const parseModelUrl = (modelUrl: string): string[] => {\n  const { baseURL, current, total } = parseShardNumber(modelUrl);\n  if (current == total && total == 1) {\n    return [modelUrl];\n  } else {\n    const queryMatch = modelUrl.match(/\\.gguf(\\?.*)?$/);\n    const queryParams = queryMatch?.[1] ?? '';\n    const paddedShardIds = Array.from({ length: total }, (_, index) =>\n      (index + 1).toString().padStart(5, '0')\n    );\n    return paddedShardIds.map(\n      (current) =>\n        `${baseURL}-${current}-of-${total.toString().padStart(5, '0')}.gguf${queryParams}`\n    );\n  }\n};\n\n/**\n * Check if the given blobs are files or not, then sort them by shard number\n */\nexport const sortFileByShard = (blobs: Blob[]): void => {\n  const isFiles = blobs.every((b) => !!(b as File).name);\n  if (isFiles && blobs.length > 1) {\n    const files = blobs as File[];\n    files.sort((a, b) => {\n      const infoA = parseShardNumber(a.name);\n      const infoB = parseShardNumber(b.name);\n      return infoA.current - infoB.current;\n    });\n  }\n};\n\nexport const delay = (ms: number) => new Promise((r) => setTimeout(r, ms));\n\nexport const absoluteUrl = (relativePath: string) =>\n  new URL(relativePath, document.baseURI).href;\n\nexport const padDigits = (number: number, digits: number) => {\n  return (\n    Array(Math.max(digits - String(number).length + 1, 0)).join('0') + number\n  );\n};\n\nexport const sumArr = (arr: number[]) =>\n  arr.reduce((prev, curr) => prev + curr, 0);\n\nexport const isString = (value: any): boolean => !!value?.startsWith;\n\n/**\n * Browser feature detection\n * Copied from https://unpkg.com/wasm-feature-detect?module (Apache License)\n */\n\n/**\n * @returns true if browser support multi-threads\n */\nexport const isSupportMultiThread = () =>\n  (async (e) => {\n    try {\n      return (\n        'undefined' != typeof MessageChannel &&\n          new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),\n        WebAssembly.validate(e)\n      );\n    } catch (e) {\n      return !1;\n    }\n  })(\n    new Uint8Array([\n      0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 2, 1, 0, 5, 4, 1, 3, 1,\n      1, 10, 11, 1, 9, 0, 65, 0, 254, 16, 2, 0, 26, 11,\n    ])\n  );\n\n/**\n * @returns true if browser support wasm \"native\" exception handler\n */\nconst isSupportExceptions = async () =>\n  WebAssembly.validate(\n    new Uint8Array([\n      0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 2, 1, 0, 10, 8, 1, 6,\n      0, 6, 64, 25, 11, 11,\n    ])\n  );\n\n/**\n * @returns true if browser support wasm SIMD\n */\nconst isSupportSIMD = async () =>\n  WebAssembly.validate(\n    new Uint8Array([\n      0, 97, 115, 109, 1, 0, 0, 0, 1, 5, 1, 96, 0, 1, 123, 3, 2, 1, 0, 10, 10,\n      1, 8, 0, 65, 0, 253, 15, 253, 98, 11,\n    ])\n  );\n\n/**\n * Throws an error if the environment is not compatible\n */\nexport const checkEnvironmentCompatible = async (): Promise<void> => {\n  if (!(await isSupportExceptions())) {\n    throw new Error('WebAssembly runtime does not support exception handling');\n  }\n  if (!(await isSupportSIMD())) {\n    throw new Error('WebAssembly runtime does not support SIMD');\n  }\n};\n\n/**\n * Check if browser is Safari\n * Source: https://github.com/DamonOehlman/detect-browser/blob/master/src/index.ts\n */\nexport const isSafari = (): boolean => {\n  return (\n    isSafariMobile() ||\n    !!navigator.userAgent.match(/Version\\/([0-9\\._]+).*Safari/)\n  ); // safari\n};\n\n/**\n * Regular expression to validate GGUF file paths/URLs\n * Matches paths ending with .gguf and optional query parameters\n */\nexport const GGUF_FILE_REGEX = /^.*\\.gguf(?:\\?.*)?$/;\n\n/**\n * Validates if a given string is a valid GGUF file path/URL\n * @param path The file path or URL to validate\n * @returns true if the path is a valid GGUF file path/URL\n */\nexport const isValidGgufFile = (path: string): boolean => {\n  return GGUF_FILE_REGEX.test(path);\n};\n\n/**\n * Check if browser is Safari iOS / iPad / iPhone\n * Source: https://github.com/DamonOehlman/detect-browser/blob/master/src/index.ts\n */\nexport const isSafariMobile = (): boolean => {\n  return !!navigator.userAgent.match(/Version\\/([0-9\\._]+).*Mobile.*Safari.*/); // ios\n};\n\n/**\n * Create a worker from a string\n */\nexport const createWorker = (workerCode: string | Blob): Worker => {\n  const workerURL = URL.createObjectURL(\n    isString(workerCode)\n      ? new Blob([workerCode], { type: 'text/javascript' })\n      : (workerCode as Blob)\n  );\n  return new Worker(workerURL, { type: 'module' });\n};\n\n/**\n * Convert callback to async iterator\n */\nexport const cbToAsyncIter =\n  <A extends any[], T>(\n    fn: (\n      ...args: [...args: A, callback: (val?: T, done?: boolean) => void]\n    ) => void\n  ) =>\n  (...args: A): AsyncIterable<T> => {\n    let values: Promise<[T, boolean]>[] = [];\n    let resolve: (x: [T, boolean]) => void;\n    values.push(\n      new Promise((r) => {\n        resolve = r;\n      })\n    );\n    fn(...args, (val?: T, done?: boolean) => {\n      resolve([val!, done!]);\n      values.push(\n        new Promise((r) => {\n          resolve = r;\n        })\n      );\n    });\n    return (async function* () {\n      let val: T;\n      for (let i = 0, done = false; !done; i++) {\n        [val, done] = await values[i];\n        delete values[i];\n        if (val !== undefined) yield val;\n      }\n    })();\n  };\n", "// This file is auto-generated\n// To re-generate it, run: npm run build:worker\n\nexport const LIBLLAMA_VERSION = 'b7179-4abef75';\n\nexport const LLAMA_CPP_WORKER_CODE = \"// Start the main llama.cpp\\nlet wllamaMalloc;\\nlet wllamaStart;\\nlet wllamaAction;\\nlet wllamaExit;\\nlet wllamaDebug;\\n\\nlet Module = null;\\n\\n//////////////////////////////////////////////////////////////\\n// UTILS\\n//////////////////////////////////////////////////////////////\\n\\n// send message back to main thread\\nconst msg = (data, transfer) => postMessage(data, transfer);\\n\\n// Convert CPP log into JS log\\nconst cppLogToJSLog = (line) => {\\n  const matched = line.match(/@@(DEBUG|INFO|WARN|ERROR)@@(.*)/);\\n  return !!matched\\n    ? {\\n        level: (matched[1] === 'INFO' ? 'debug' : matched[1]).toLowerCase(),\\n        text: matched[2],\\n      }\\n    : { level: 'log', text: line };\\n};\\n\\n// Get module config that forwards stdout/err to main thread\\nconst getWModuleConfig = (_argMainScriptBlob) => {\\n  var pathConfig = RUN_OPTIONS.pathConfig;\\n  var pthreadPoolSize = RUN_OPTIONS.nbThread;\\n  var argMainScriptBlob = _argMainScriptBlob;\\n\\n  if (!pathConfig['wllama.wasm']) {\\n    throw new Error('\\\"wllama.wasm\\\" is missing in pathConfig');\\n  }\\n  return {\\n    noInitialRun: true,\\n    print: function (text) {\\n      if (arguments.length > 1)\\n        text = Array.prototype.slice.call(arguments).join(' ');\\n      msg({ verb: 'console.log', args: [text] });\\n    },\\n    printErr: function (text) {\\n      if (arguments.length > 1)\\n        text = Array.prototype.slice.call(arguments).join(' ');\\n      const logLine = cppLogToJSLog(text);\\n      msg({ verb: 'console.' + logLine.level, args: [logLine.text] });\\n    },\\n    locateFile: function (filename, basePath) {\\n      const p = pathConfig[filename];\\n      const truncate = (str) =>\\n        str.length > 128 ? `${str.substr(0, 128)}...` : str;\\n      if (filename.match(/wllama\\\\.worker\\\\.js/)) {\\n        msg({\\n          verb: 'console.error',\\n          args: [\\n            '\\\"wllama.worker.js\\\" is removed from v2.2.1. Hint: make sure to clear browser\\\\'s cache.',\\n          ],\\n        });\\n      } else {\\n        msg({\\n          verb: 'console.debug',\\n          args: [`Loading \\\"${filename}\\\" from \\\"${truncate(p)}\\\"`],\\n        });\\n        return p;\\n      }\\n    },\\n    mainScriptUrlOrBlob: argMainScriptBlob,\\n    pthreadPoolSize,\\n    wasmMemory: pthreadPoolSize > 1 ? getWasmMemory() : null,\\n    onAbort: function (text) {\\n      msg({ verb: 'signal.abort', args: [text] });\\n    },\\n  };\\n};\\n\\n// Get the memory to be used by wasm. (Only used in multi-thread mode)\\n// Because we have a weird OOM issue on iOS, we need to try some values\\n// See: https://github.com/emscripten-core/emscripten/issues/19144\\n//      https://github.com/godotengine/godot/issues/70621\\nconst getWasmMemory = () => {\\n  let minBytes = 128 * 1024 * 1024;\\n  let maxBytes = 4096 * 1024 * 1024;\\n  let stepBytes = 128 * 1024 * 1024;\\n  while (maxBytes > minBytes) {\\n    try {\\n      const wasmMemory = new WebAssembly.Memory({\\n        initial: minBytes / 65536,\\n        maximum: maxBytes / 65536,\\n        shared: true,\\n      });\\n      return wasmMemory;\\n    } catch (e) {\\n      maxBytes -= stepBytes;\\n      continue; // retry\\n    }\\n  }\\n  throw new Error('Cannot allocate WebAssembly.Memory');\\n};\\n\\n//////////////////////////////////////////////////////////////\\n// MEMFS PATCH\\n//////////////////////////////////////////////////////////////\\n\\n/**\\n * By default, emscripten uses memfs. The way it works is by\\n * allocating new Uint8Array in javascript heap. This is not good\\n * because it requires files to be copied to wasm heap each time\\n * a file is read.\\n *\\n * HeapFS is an alternative, which resolves this problem by\\n * allocating space for file directly inside wasm heap. This\\n * allows us to mmap without doing any copy.\\n *\\n * For llama.cpp, this is great because we use MAP_SHARED\\n *\\n * Ref: https://github.com/ngxson/wllama/pull/39\\n * Ref: https://github.com/emscripten-core/emscripten/blob/main/src/library_memfs.js\\n *\\n * Note 29/05/2024 @ngxson\\n * Due to ftell() being limited to MAX_LONG, we cannot load files bigger than 2^31 bytes (or 2GB)\\n * Ref: https://github.com/emscripten-core/emscripten/blob/main/system/lib/libc/musl/src/stdio/ftell.c\\n */\\n\\nconst fsNameToFile = {}; // map Name => File\\nconst fsIdToFile = {}; // map ID => File\\nlet currFileId = 0;\\n\\n// Patch and redirect memfs calls to wllama\\nconst patchMEMFS = () => {\\n  const m = Module;\\n  // save functions\\n  m.MEMFS.stream_ops._read = m.MEMFS.stream_ops.read;\\n  m.MEMFS.stream_ops._write = m.MEMFS.stream_ops.write;\\n  m.MEMFS.stream_ops._llseek = m.MEMFS.stream_ops.llseek;\\n  m.MEMFS.stream_ops._allocate = m.MEMFS.stream_ops.allocate;\\n  m.MEMFS.stream_ops._mmap = m.MEMFS.stream_ops.mmap;\\n  m.MEMFS.stream_ops._msync = m.MEMFS.stream_ops.msync;\\n\\n  const patchStream = (stream) => {\\n    const name = stream.node.name;\\n    if (fsNameToFile[name]) {\\n      const f = fsNameToFile[name];\\n      stream.node.contents = m.HEAPU8.subarray(f.ptr, f.ptr + f.size);\\n      stream.node.usedBytes = f.size;\\n    }\\n  };\\n\\n  // replace \\\"read\\\" functions\\n  m.MEMFS.stream_ops.read = function (\\n    stream,\\n    buffer,\\n    offset,\\n    length,\\n    position\\n  ) {\\n    patchStream(stream);\\n    return m.MEMFS.stream_ops._read(stream, buffer, offset, length, position);\\n  };\\n  m.MEMFS.ops_table.file.stream.read = m.MEMFS.stream_ops.read;\\n\\n  // replace \\\"llseek\\\" functions\\n  m.MEMFS.stream_ops.llseek = function (stream, offset, whence) {\\n    patchStream(stream);\\n    return m.MEMFS.stream_ops._llseek(stream, offset, whence);\\n  };\\n  m.MEMFS.ops_table.file.stream.llseek = m.MEMFS.stream_ops.llseek;\\n\\n  // replace \\\"mmap\\\" functions\\n  m.MEMFS.stream_ops.mmap = function (stream, length, position, prot, flags) {\\n    patchStream(stream);\\n    const name = stream.node.name;\\n    if (fsNameToFile[name]) {\\n      const f = fsNameToFile[name];\\n      return {\\n        ptr: f.ptr + position,\\n        allocated: false,\\n      };\\n    } else {\\n      return m.MEMFS.stream_ops._mmap(stream, length, position, prot, flags);\\n    }\\n  };\\n  m.MEMFS.ops_table.file.stream.mmap = m.MEMFS.stream_ops.mmap;\\n\\n  // mount FS\\n  m.FS.mkdir('/models');\\n  m.FS.mount(m.MEMFS, { root: '.' }, '/models');\\n};\\n\\n// Allocate a new file in wllama heapfs, returns file ID\\nconst heapfsAlloc = (name, size) => {\\n  if (size < 1) {\\n    throw new Error('File size must be bigger than 0');\\n  }\\n  const m = Module;\\n  const ptr = m.mmapAlloc(size);\\n  const file = {\\n    ptr: ptr,\\n    size: size,\\n    id: currFileId++,\\n  };\\n  fsIdToFile[file.id] = file;\\n  fsNameToFile[name] = file;\\n  return file.id;\\n};\\n\\n// Add new file to wllama heapfs, return number of written bytes\\nconst heapfsWrite = (id, buffer, offset) => {\\n  const m = Module;\\n  if (fsIdToFile[id]) {\\n    const { ptr, size } = fsIdToFile[id];\\n    const afterWriteByte = offset + buffer.byteLength;\\n    if (afterWriteByte > size) {\\n      throw new Error(\\n        `File ID ${id} write out of bound, afterWriteByte = ${afterWriteByte} while size = ${size}`\\n      );\\n    }\\n    m.HEAPU8.set(buffer, ptr + offset);\\n    return buffer.byteLength;\\n  } else {\\n    throw new Error(`File ID ${id} not found in heapfs`);\\n  }\\n};\\n\\n//////////////////////////////////////////////////////////////\\n// MAIN CODE\\n//////////////////////////////////////////////////////////////\\n\\nconst callWrapper = (name, ret, args) => {\\n  const fn = Module.cwrap(name, ret, args);\\n  return async (action, req) => {\\n    let result;\\n    try {\\n      if (args.length === 2) {\\n        result = await fn(action, req);\\n      } else {\\n        result = fn();\\n      }\\n    } catch (ex) {\\n      console.error(ex);\\n      throw ex;\\n    }\\n    return result;\\n  };\\n};\\n\\nonmessage = async (e) => {\\n  if (!e.data) return;\\n  const { verb, args, callbackId } = e.data;\\n\\n  if (!callbackId) {\\n    msg({ verb: 'console.error', args: ['callbackId is required', e.data] });\\n    return;\\n  }\\n\\n  if (verb === 'module.init') {\\n    const argMainScriptBlob = args[0];\\n    try {\\n      Module = getWModuleConfig(argMainScriptBlob);\\n      Module.onRuntimeInitialized = () => {\\n        // async call once module is ready\\n        // init FS\\n        patchMEMFS();\\n        // init cwrap\\n        const pointer = 'number';\\n        // TODO: note sure why emscripten cannot bind if there is only 1 argument\\n        wllamaMalloc = callWrapper('wllama_malloc', pointer, [\\n          'number',\\n          pointer,\\n        ]);\\n        wllamaStart = callWrapper('wllama_start', 'string', []);\\n        wllamaAction = callWrapper('wllama_action', pointer, [\\n          'string',\\n          pointer,\\n        ]);\\n        wllamaExit = callWrapper('wllama_exit', 'string', []);\\n        wllamaDebug = callWrapper('wllama_debug', 'string', []);\\n        msg({ callbackId, result: null });\\n      };\\n      wModuleInit();\\n    } catch (err) {\\n      msg({ callbackId, err });\\n    }\\n    return;\\n  }\\n\\n  if (verb === 'fs.alloc') {\\n    const argFilename = args[0];\\n    const argSize = args[1];\\n    try {\\n      // create blank file\\n      const emptyBuffer = new ArrayBuffer(0);\\n      Module['FS_createDataFile'](\\n        '/models',\\n        argFilename,\\n        emptyBuffer,\\n        true,\\n        true,\\n        true\\n      );\\n      // alloc data on heap\\n      const fileId = heapfsAlloc(argFilename, argSize);\\n      msg({ callbackId, result: { fileId } });\\n    } catch (err) {\\n      msg({ callbackId, err });\\n    }\\n    return;\\n  }\\n\\n  if (verb === 'fs.write') {\\n    const argFileId = args[0];\\n    const argBuffer = args[1];\\n    const argOffset = args[2];\\n    try {\\n      const writtenBytes = heapfsWrite(argFileId, argBuffer, argOffset);\\n      msg({ callbackId, result: { writtenBytes } });\\n    } catch (err) {\\n      msg({ callbackId, err });\\n    }\\n    return;\\n  }\\n\\n  if (verb === 'wllama.start') {\\n    try {\\n      const result = await wllamaStart();\\n      msg({ callbackId, result });\\n    } catch (err) {\\n      msg({ callbackId, err });\\n    }\\n    return;\\n  }\\n\\n  if (verb === 'wllama.action') {\\n    const argAction = args[0];\\n    const argEncodedMsg = args[1];\\n    try {\\n      const inputPtr = await wllamaMalloc(argEncodedMsg.byteLength, 0);\\n      // copy data to wasm heap\\n      const inputBuffer = new Uint8Array(\\n        Module.HEAPU8.buffer,\\n        inputPtr,\\n        argEncodedMsg.byteLength\\n      );\\n      inputBuffer.set(argEncodedMsg, 0);\\n      const outputPtr = await wllamaAction(argAction, inputPtr);\\n      // length of output buffer is written at the first 4 bytes of input buffer\\n      const outputLen = new Uint32Array(Module.HEAPU8.buffer, inputPtr, 1)[0];\\n      // copy the output buffer to JS heap\\n      const outputBuffer = new Uint8Array(outputLen);\\n      const outputSrcView = new Uint8Array(\\n        Module.HEAPU8.buffer,\\n        outputPtr,\\n        outputLen\\n      );\\n      outputBuffer.set(outputSrcView, 0); // copy it\\n      msg({ callbackId, result: outputBuffer }, [outputBuffer.buffer]);\\n    } catch (err) {\\n      msg({ callbackId, err });\\n    }\\n    return;\\n  }\\n\\n  if (verb === 'wllama.exit') {\\n    try {\\n      const result = await wllamaExit();\\n      msg({ callbackId, result });\\n    } catch (err) {\\n      msg({ callbackId, err });\\n    }\\n    return;\\n  }\\n\\n  if (verb === 'wllama.debug') {\\n    try {\\n      const result = await wllamaDebug();\\n      msg({ callbackId, result });\\n    } catch (err) {\\n      msg({ callbackId, err });\\n    }\\n    return;\\n  }\\n};\\n\";\n\nexport const OPFS_UTILS_WORKER_CODE = \"let accessHandle;\\nlet abortController = new AbortController();\\n\\nasync function openFile(filename) {\\n  const opfsRoot = await navigator.storage.getDirectory();\\n  const cacheDir = await opfsRoot.getDirectoryHandle('cache', { create: true });\\n  const fileHandler = await cacheDir.getFileHandle(filename, { create: true });\\n  accessHandle = await fileHandler.createSyncAccessHandle();\\n  accessHandle.truncate(0); // clear file content\\n}\\n\\nasync function writeFile(buf) {\\n  accessHandle.write(buf);\\n}\\n\\nasync function closeFile() {\\n  accessHandle.flush();\\n  accessHandle.close();\\n}\\n\\nasync function writeTextFile(filename, str) {\\n  await openFile(filename);\\n  await writeFile(new TextEncoder().encode(str));\\n  await closeFile();\\n}\\n\\nconst throttled = (func, delay) => {\\n  let lastRun = 0;\\n  return (...args) => {\\n    const now = Date.now();\\n    if (now - lastRun > delay) {\\n      lastRun = now;\\n      func.apply(null, args);\\n    }\\n  };\\n};\\n\\nconst assertNonNull = (val) => {\\n  if (val === null || val === undefined) {\\n    throw new Error('OPFS Worker: Assertion failed');\\n  }\\n};\\n\\n// respond to main thread\\nconst resOK = () => postMessage({ ok: true });\\nconst resProgress = (loaded, total) =>\\n  postMessage({ progress: { loaded, total } });\\nconst resErr = (err) => postMessage({ err });\\n\\nonmessage = async (e) => {\\n  try {\\n    if (!e.data) return;\\n\\n    /**\\n     * @param {Object} e.data\\n     *\\n     * Fine-control FS actions:\\n     * - { action: 'open', filename: 'string' }\\n     * - { action: 'write', buf: ArrayBuffer }\\n     * - { action: 'close' }\\n     *\\n     * Simple write API:\\n     * - { action: 'write-simple', filename: 'string', buf: ArrayBuffer }\\n     *\\n     * Download API:\\n     * - { action: 'download', url: 'string', filename: 'string', options: Object, metadataFileName: 'string' }\\n     * - { action: 'download-abort' }\\n     */\\n    const { action, filename, buf, url, options, metadataFileName } = e.data;\\n\\n    if (action === 'open') {\\n      assertNonNull(filename);\\n      await openFile(filename);\\n      return resOK();\\n    } else if (action === 'write') {\\n      assertNonNull(buf);\\n      await writeFile(buf);\\n      return resOK();\\n    } else if (action === 'close') {\\n      await closeFile();\\n      return resOK();\\n    } else if (action === 'write-simple') {\\n      assertNonNull(filename);\\n      assertNonNull(buf);\\n      await openFile(filename);\\n      await writeFile(buf);\\n      await closeFile();\\n      return resOK();\\n    } else if (action === 'download') {\\n      assertNonNull(url);\\n      assertNonNull(filename);\\n      assertNonNull(metadataFileName);\\n      assertNonNull(options);\\n      assertNonNull(options.aborted);\\n      abortController = new AbortController();\\n      if (options.aborted) abortController.abort();\\n      const response = await fetch(url, {\\n        ...options,\\n        signal: abortController.signal,\\n      });\\n      const contentLength = response.headers.get('content-length');\\n      const etag = (response.headers.get('etag') || '').replace(\\n        /[^A-Za-z0-9]/g,\\n        ''\\n      );\\n      const total = parseInt(contentLength, 10);\\n      const reader = response.body.getReader();\\n      await openFile(filename);\\n      let loaded = 0;\\n      const throttledProgress = throttled(resProgress, 100);\\n      while (true) {\\n        const { done, value } = await reader.read();\\n        if (done) break;\\n        loaded += value.byteLength;\\n        await writeFile(value);\\n        throttledProgress(loaded, total);\\n      }\\n      resProgress(total, total); // 100% done\\n      await closeFile();\\n      // make sure this is in-sync with CacheEntryMetadata\\n      await writeTextFile(\\n        metadataFileName,\\n        JSON.stringify({\\n          originalURL: url,\\n          originalSize: total,\\n          etag,\\n        })\\n      );\\n      return resOK();\\n    } else if (action === 'download-abort') {\\n      if (abortController) {\\n        abortController.abort();\\n      }\\n      return;\\n    }\\n\\n    throw new Error('OPFS Worker: Invalid action', e.data);\\n  } catch (err) {\\n    return resErr(err);\\n  }\\n};\\n\";\n\nexport const WLLAMA_MULTI_THREAD_CODE = \"var Module=typeof Module!=\\\"undefined\\\"?Module:{};var ENVIRONMENT_IS_WEB=typeof window==\\\"object\\\";var ENVIRONMENT_IS_WORKER=typeof WorkerGlobalScope!=\\\"undefined\\\";var ENVIRONMENT_IS_NODE=typeof process==\\\"object\\\"&&typeof process.versions==\\\"object\\\"&&typeof process.versions.node==\\\"string\\\"&&process.type!=\\\"renderer\\\";var ENVIRONMENT_IS_PTHREAD=ENVIRONMENT_IS_WORKER&&self.name?.startsWith(\\\"em-pthread\\\");if(ENVIRONMENT_IS_NODE){var worker_threads=require(\\\"worker_threads\\\");global.Worker=worker_threads.Worker;ENVIRONMENT_IS_WORKER=!worker_threads.isMainThread;ENVIRONMENT_IS_PTHREAD=ENVIRONMENT_IS_WORKER&&worker_threads[\\\"workerData\\\"]==\\\"em-pthread\\\"}var moduleOverrides=Object.assign({},Module);var arguments_=[];var thisProgram=\\\"./this.program\\\";var quit_=(status,toThrow)=>{throw toThrow};var _scriptName=typeof document!=\\\"undefined\\\"?document.currentScript?.src:undefined;if(ENVIRONMENT_IS_NODE){_scriptName=__filename}else if(ENVIRONMENT_IS_WORKER){_scriptName=self.location.href}var scriptDirectory=\\\"\\\";function locateFile(path){if(Module[\\\"locateFile\\\"]){return Module[\\\"locateFile\\\"](path,scriptDirectory)}return scriptDirectory+path}var readAsync,readBinary;if(ENVIRONMENT_IS_NODE){var fs=require(\\\"fs\\\");var nodePath=require(\\\"path\\\");scriptDirectory=__dirname+\\\"/\\\";readBinary=filename=>{filename=isFileURI(filename)?new URL(filename):filename;var ret=fs.readFileSync(filename);return ret};readAsync=async(filename,binary=true)=>{filename=isFileURI(filename)?new URL(filename):filename;var ret=fs.readFileSync(filename,binary?undefined:\\\"utf8\\\");return ret};if(!Module[\\\"thisProgram\\\"]&&process.argv.length>1){thisProgram=process.argv[1].replace(/\\\\\\\\/g,\\\"/\\\")}arguments_=process.argv.slice(2);if(typeof module!=\\\"undefined\\\"){module[\\\"exports\\\"]=Module}quit_=(status,toThrow)=>{process.exitCode=status;throw toThrow}}else if(ENVIRONMENT_IS_WEB||ENVIRONMENT_IS_WORKER){if(ENVIRONMENT_IS_WORKER){scriptDirectory=self.location.href}else if(typeof document!=\\\"undefined\\\"&&document.currentScript){scriptDirectory=document.currentScript.src}if(scriptDirectory.startsWith(\\\"blob:\\\")){scriptDirectory=\\\"\\\"}else{scriptDirectory=scriptDirectory.slice(0,scriptDirectory.replace(/[?#].*/,\\\"\\\").lastIndexOf(\\\"/\\\")+1)}if(!ENVIRONMENT_IS_NODE){if(ENVIRONMENT_IS_WORKER){readBinary=url=>{var xhr=new XMLHttpRequest;xhr.open(\\\"GET\\\",url,false);xhr.responseType=\\\"arraybuffer\\\";xhr.send(null);return new Uint8Array(xhr.response)}}readAsync=async url=>{if(isFileURI(url)){return new Promise((resolve,reject)=>{var xhr=new XMLHttpRequest;xhr.open(\\\"GET\\\",url,true);xhr.responseType=\\\"arraybuffer\\\";xhr.onload=()=>{if(xhr.status==200||xhr.status==0&&xhr.response){resolve(xhr.response);return}reject(xhr.status)};xhr.onerror=reject;xhr.send(null)})}var response=await fetch(url,{credentials:\\\"same-origin\\\"});if(response.ok){return response.arrayBuffer()}throw new Error(response.status+\\\" : \\\"+response.url)}}}else{}var defaultPrint=console.log.bind(console);var defaultPrintErr=console.error.bind(console);if(ENVIRONMENT_IS_NODE){defaultPrint=(...args)=>fs.writeSync(1,args.join(\\\" \\\")+\\\"\\\\n\\\");defaultPrintErr=(...args)=>fs.writeSync(2,args.join(\\\" \\\")+\\\"\\\\n\\\")}var out=Module[\\\"print\\\"]||defaultPrint;var err=Module[\\\"printErr\\\"]||defaultPrintErr;Object.assign(Module,moduleOverrides);moduleOverrides=null;if(Module[\\\"arguments\\\"])arguments_=Module[\\\"arguments\\\"];if(Module[\\\"thisProgram\\\"])thisProgram=Module[\\\"thisProgram\\\"];var wasmBinary=Module[\\\"wasmBinary\\\"];var wasmMemory;var wasmModule;var ABORT=false;var EXITSTATUS;var HEAP8,HEAPU8,HEAP16,HEAPU16,HEAP32,HEAPU32,HEAPF32,HEAP64,HEAPU64,HEAPF64;var runtimeInitialized=false;var isFileURI=filename=>filename.startsWith(\\\"file://\\\");function GROWABLE_HEAP_I8(){if(wasmMemory.buffer!=HEAP8.buffer){updateMemoryViews()}return HEAP8}function GROWABLE_HEAP_U8(){if(wasmMemory.buffer!=HEAP8.buffer){updateMemoryViews()}return HEAPU8}function GROWABLE_HEAP_I16(){if(wasmMemory.buffer!=HEAP8.buffer){updateMemoryViews()}return HEAP16}function GROWABLE_HEAP_I32(){if(wasmMemory.buffer!=HEAP8.buffer){updateMemoryViews()}return HEAP32}function GROWABLE_HEAP_U32(){if(wasmMemory.buffer!=HEAP8.buffer){updateMemoryViews()}return HEAPU32}function GROWABLE_HEAP_F32(){if(wasmMemory.buffer!=HEAP8.buffer){updateMemoryViews()}return HEAPF32}function GROWABLE_HEAP_F64(){if(wasmMemory.buffer!=HEAP8.buffer){updateMemoryViews()}return HEAPF64}if(ENVIRONMENT_IS_PTHREAD){var wasmModuleReceived;if(ENVIRONMENT_IS_NODE){var parentPort=worker_threads[\\\"parentPort\\\"];parentPort.on(\\\"message\\\",msg=>onmessage({data:msg}));Object.assign(globalThis,{self:global,postMessage:msg=>parentPort.postMessage(msg)})}var initializedJS=false;function threadPrintErr(...args){var text=args.join(\\\" \\\");if(ENVIRONMENT_IS_NODE){fs.writeSync(2,text+\\\"\\\\n\\\");return}console.error(text)}if(!Module[\\\"printErr\\\"])err=threadPrintErr;function threadAlert(...args){var text=args.join(\\\" \\\");postMessage({cmd:\\\"alert\\\",text,threadId:_pthread_self()})}self.alert=threadAlert;self.onunhandledrejection=e=>{throw e.reason||e};function handleMessage(e){try{var msgData=e[\\\"data\\\"];var cmd=msgData.cmd;if(cmd===\\\"load\\\"){let messageQueue=[];self.onmessage=e=>messageQueue.push(e);self.startWorker=instance=>{postMessage({cmd:\\\"loaded\\\"});for(let msg of messageQueue){handleMessage(msg)}self.onmessage=handleMessage};for(const handler of msgData.handlers){if(!Module[handler]||Module[handler].proxy){Module[handler]=(...args)=>{postMessage({cmd:\\\"callHandler\\\",handler,args})};if(handler==\\\"print\\\")out=Module[handler];if(handler==\\\"printErr\\\")err=Module[handler]}}wasmMemory=msgData.wasmMemory;updateMemoryViews();wasmModuleReceived(msgData.wasmModule)}else if(cmd===\\\"run\\\"){establishStackSpace(msgData.pthread_ptr);__emscripten_thread_init(msgData.pthread_ptr,0,0,1,0,0);PThread.receiveObjectTransfer(msgData);PThread.threadInitTLS();__emscripten_thread_mailbox_await(msgData.pthread_ptr);if(!initializedJS){initializedJS=true}try{invokeEntryPoint(msgData.start_routine,msgData.arg)}catch(ex){if(ex!=\\\"unwind\\\"){throw ex}}}else if(msgData.target===\\\"setimmediate\\\"){}else if(cmd===\\\"checkMailbox\\\"){if(initializedJS){checkMailbox()}}else if(cmd){err(`worker: received unknown command ${cmd}`);err(msgData)}}catch(ex){__emscripten_thread_crashed();throw ex}}self.onmessage=handleMessage}function updateMemoryViews(){var b=wasmMemory.buffer;Module[\\\"HEAP8\\\"]=HEAP8=new Int8Array(b);Module[\\\"HEAP16\\\"]=HEAP16=new Int16Array(b);Module[\\\"HEAPU8\\\"]=HEAPU8=new Uint8Array(b);Module[\\\"HEAPU16\\\"]=HEAPU16=new Uint16Array(b);Module[\\\"HEAP32\\\"]=HEAP32=new Int32Array(b);Module[\\\"HEAPU32\\\"]=HEAPU32=new Uint32Array(b);Module[\\\"HEAPF32\\\"]=HEAPF32=new Float32Array(b);Module[\\\"HEAPF64\\\"]=HEAPF64=new Float64Array(b);Module[\\\"HEAP64\\\"]=HEAP64=new BigInt64Array(b);Module[\\\"HEAPU64\\\"]=HEAPU64=new BigUint64Array(b)}if(!ENVIRONMENT_IS_PTHREAD){if(Module[\\\"wasmMemory\\\"]){wasmMemory=Module[\\\"wasmMemory\\\"]}else{var INITIAL_MEMORY=Module[\\\"INITIAL_MEMORY\\\"]||134217728;wasmMemory=new WebAssembly.Memory({initial:INITIAL_MEMORY/65536,maximum:65536,shared:true})}updateMemoryViews()}function preRun(){if(Module[\\\"preRun\\\"]){if(typeof Module[\\\"preRun\\\"]==\\\"function\\\")Module[\\\"preRun\\\"]=[Module[\\\"preRun\\\"]];while(Module[\\\"preRun\\\"].length){addOnPreRun(Module[\\\"preRun\\\"].shift())}}callRuntimeCallbacks(onPreRuns)}function initRuntime(){runtimeInitialized=true;if(ENVIRONMENT_IS_PTHREAD)return startWorker(Module);if(!Module[\\\"noFSInit\\\"]&&!FS.initialized)FS.init();TTY.init();wasmExports[\\\"I\\\"]();FS.ignorePermissions=false}function preMain(){}function postRun(){if(ENVIRONMENT_IS_PTHREAD)return;if(Module[\\\"postRun\\\"]){if(typeof Module[\\\"postRun\\\"]==\\\"function\\\")Module[\\\"postRun\\\"]=[Module[\\\"postRun\\\"]];while(Module[\\\"postRun\\\"].length){addOnPostRun(Module[\\\"postRun\\\"].shift())}}callRuntimeCallbacks(onPostRuns)}var runDependencies=0;var dependenciesFulfilled=null;function getUniqueRunDependency(id){return id}function addRunDependency(id){runDependencies++;Module[\\\"monitorRunDependencies\\\"]?.(runDependencies)}function removeRunDependency(id){runDependencies--;Module[\\\"monitorRunDependencies\\\"]?.(runDependencies);if(runDependencies==0){if(dependenciesFulfilled){var callback=dependenciesFulfilled;dependenciesFulfilled=null;callback()}}}function abort(what){Module[\\\"onAbort\\\"]?.(what);what=\\\"Aborted(\\\"+what+\\\")\\\";err(what);ABORT=true;what+=\\\". Build with -sASSERTIONS for more info.\\\";if(runtimeInitialized){___trap()}var e=new WebAssembly.RuntimeError(what);throw e}var wasmBinaryFile;function findWasmBinary(){return locateFile(\\\"wllama.wasm\\\")}function getBinarySync(file){if(file==wasmBinaryFile&&wasmBinary){return new Uint8Array(wasmBinary)}if(readBinary){return readBinary(file)}throw\\\"both async and sync fetching of the wasm failed\\\"}async function getWasmBinary(binaryFile){if(!wasmBinary){try{var response=await readAsync(binaryFile);return new Uint8Array(response)}catch{}}return getBinarySync(binaryFile)}async function instantiateArrayBuffer(binaryFile,imports){try{var binary=await getWasmBinary(binaryFile);var instance=await WebAssembly.instantiate(binary,imports);return instance}catch(reason){err(`failed to asynchronously prepare wasm: ${reason}`);abort(reason)}}async function instantiateAsync(binary,binaryFile,imports){if(!binary&&typeof WebAssembly.instantiateStreaming==\\\"function\\\"&&!isFileURI(binaryFile)&&!ENVIRONMENT_IS_NODE){try{var response=fetch(binaryFile,{credentials:\\\"same-origin\\\"});var instantiationResult=await WebAssembly.instantiateStreaming(response,imports);return instantiationResult}catch(reason){err(`wasm streaming compile failed: ${reason}`);err(\\\"falling back to ArrayBuffer instantiation\\\")}}return instantiateArrayBuffer(binaryFile,imports)}function getWasmImports(){assignWasmImports();return{a:wasmImports}}async function createWasm(){function receiveInstance(instance,module){wasmExports=instance.exports;wasmExports=applySignatureConversions(wasmExports);registerTLSInit(wasmExports[\\\"P\\\"]);wasmTable=wasmExports[\\\"S\\\"];wasmModule=module;removeRunDependency(\\\"wasm-instantiate\\\");return wasmExports}addRunDependency(\\\"wasm-instantiate\\\");function receiveInstantiationResult(result){return receiveInstance(result[\\\"instance\\\"],result[\\\"module\\\"])}var info=getWasmImports();if(Module[\\\"instantiateWasm\\\"]){return new Promise((resolve,reject)=>{Module[\\\"instantiateWasm\\\"](info,(mod,inst)=>{receiveInstance(mod,inst);resolve(mod.exports)})})}if(ENVIRONMENT_IS_PTHREAD){return new Promise(resolve=>{wasmModuleReceived=module=>{var instance=new WebAssembly.Instance(module,getWasmImports());resolve(receiveInstance(instance,module))}})}wasmBinaryFile??=findWasmBinary();var result=await instantiateAsync(wasmBinary,wasmBinaryFile,info);var exports=receiveInstantiationResult(result);return exports}class ExitStatus{name=\\\"ExitStatus\\\";constructor(status){this.message=`Program terminated with exit(${status})`;this.status=status}}Module[\\\"ExitStatus\\\"]=ExitStatus;var terminateWorker=worker=>{worker.terminate();worker.onmessage=e=>{}};Module[\\\"terminateWorker\\\"]=terminateWorker;var cleanupThread=pthread_ptr=>{var worker=PThread.pthreads[pthread_ptr];PThread.returnWorkerToPool(worker)};Module[\\\"cleanupThread\\\"]=cleanupThread;var callRuntimeCallbacks=callbacks=>{while(callbacks.length>0){callbacks.shift()(Module)}};Module[\\\"callRuntimeCallbacks\\\"]=callRuntimeCallbacks;var onPreRuns=[];Module[\\\"onPreRuns\\\"]=onPreRuns;var addOnPreRun=cb=>onPreRuns.unshift(cb);Module[\\\"addOnPreRun\\\"]=addOnPreRun;var spawnThread=threadParams=>{var worker=PThread.getNewWorker();if(!worker){return 6}PThread.runningWorkers.push(worker);PThread.pthreads[threadParams.pthread_ptr]=worker;worker.pthread_ptr=threadParams.pthread_ptr;var msg={cmd:\\\"run\\\",start_routine:threadParams.startRoutine,arg:threadParams.arg,pthread_ptr:threadParams.pthread_ptr};if(ENVIRONMENT_IS_NODE){worker.unref()}worker.postMessage(msg,threadParams.transferList);return 0};Module[\\\"spawnThread\\\"]=spawnThread;var runtimeKeepaliveCounter=0;Module[\\\"runtimeKeepaliveCounter\\\"]=runtimeKeepaliveCounter;var keepRuntimeAlive=()=>noExitRuntime||runtimeKeepaliveCounter>0;Module[\\\"keepRuntimeAlive\\\"]=keepRuntimeAlive;var stackSave=()=>_emscripten_stack_get_current();Module[\\\"stackSave\\\"]=stackSave;var stackRestore=val=>__emscripten_stack_restore(val);Module[\\\"stackRestore\\\"]=stackRestore;var stackAlloc=sz=>__emscripten_stack_alloc(sz);Module[\\\"stackAlloc\\\"]=stackAlloc;var INT53_MAX=9007199254740992;Module[\\\"INT53_MAX\\\"]=INT53_MAX;var INT53_MIN=-9007199254740992;Module[\\\"INT53_MIN\\\"]=INT53_MIN;var bigintToI53Checked=num=>num<INT53_MIN||num>INT53_MAX?NaN:Number(num);Module[\\\"bigintToI53Checked\\\"]=bigintToI53Checked;var proxyToMainThread=(funcIndex,emAsmAddr,sync,...callArgs)=>{var serializedNumCallArgs=callArgs.length*2;var sp=stackSave();var args=stackAlloc(serializedNumCallArgs*8);var b=args>>>3;for(var i=0;i<callArgs.length;i++){var arg=callArgs[i];if(typeof arg==\\\"bigint\\\"){HEAP64[b+2*i]=1n;HEAP64[b+2*i+1]=arg}else{HEAP64[b+2*i]=0n;GROWABLE_HEAP_F64()[b+2*i+1>>>0]=arg}}var rtn=__emscripten_run_on_main_thread_js(funcIndex,emAsmAddr,serializedNumCallArgs,args,sync);stackRestore(sp);return rtn};Module[\\\"proxyToMainThread\\\"]=proxyToMainThread;function _proc_exit(code){if(ENVIRONMENT_IS_PTHREAD)return proxyToMainThread(0,0,1,code);EXITSTATUS=code;if(!keepRuntimeAlive()){PThread.terminateAllThreads();Module[\\\"onExit\\\"]?.(code);ABORT=true}quit_(code,new ExitStatus(code))}Module[\\\"_proc_exit\\\"]=_proc_exit;var handleException=e=>{if(e instanceof ExitStatus||e==\\\"unwind\\\"){return EXITSTATUS}quit_(1,e)};Module[\\\"handleException\\\"]=handleException;function exitOnMainThread(returnCode){if(ENVIRONMENT_IS_PTHREAD)return proxyToMainThread(1,0,0,returnCode);_exit(returnCode)}Module[\\\"exitOnMainThread\\\"]=exitOnMainThread;var exitJS=(status,implicit)=>{EXITSTATUS=status;if(ENVIRONMENT_IS_PTHREAD){exitOnMainThread(status);throw\\\"unwind\\\"}_proc_exit(status)};Module[\\\"exitJS\\\"]=exitJS;var _exit=exitJS;Module[\\\"_exit\\\"]=_exit;var PThread={unusedWorkers:[],runningWorkers:[],tlsInitFunctions:[],pthreads:{},init(){if(!ENVIRONMENT_IS_PTHREAD){PThread.initMainThread()}},initMainThread(){var pthreadPoolSize=Module[\\\"pthreadPoolSize\\\"];while(pthreadPoolSize--){PThread.allocateUnusedWorker()}addOnPreRun(()=>{addRunDependency(\\\"loading-workers\\\");PThread.loadWasmModuleToAllWorkers(()=>removeRunDependency(\\\"loading-workers\\\"))})},terminateAllThreads:()=>{for(var worker of PThread.runningWorkers){terminateWorker(worker)}for(var worker of PThread.unusedWorkers){terminateWorker(worker)}PThread.unusedWorkers=[];PThread.runningWorkers=[];PThread.pthreads={}},returnWorkerToPool:worker=>{var pthread_ptr=worker.pthread_ptr;delete PThread.pthreads[pthread_ptr];PThread.unusedWorkers.push(worker);PThread.runningWorkers.splice(PThread.runningWorkers.indexOf(worker),1);worker.pthread_ptr=0;__emscripten_thread_free_data(pthread_ptr)},receiveObjectTransfer(data){},threadInitTLS(){PThread.tlsInitFunctions.forEach(f=>f())},loadWasmModuleToWorker:worker=>new Promise(onFinishedLoading=>{worker.onmessage=e=>{var d=e[\\\"data\\\"];var cmd=d.cmd;if(d.targetThread&&d.targetThread!=_pthread_self()){var targetWorker=PThread.pthreads[d.targetThread];if(targetWorker){targetWorker.postMessage(d,d.transferList)}else{err(`Internal error! Worker sent a message \\\"${cmd}\\\" to target pthread ${d.targetThread}, but that thread no longer exists!`)}return}if(cmd===\\\"checkMailbox\\\"){checkMailbox()}else if(cmd===\\\"spawnThread\\\"){spawnThread(d)}else if(cmd===\\\"cleanupThread\\\"){cleanupThread(d.thread)}else if(cmd===\\\"loaded\\\"){worker.loaded=true;if(ENVIRONMENT_IS_NODE&&!worker.pthread_ptr){worker.unref()}onFinishedLoading(worker)}else if(cmd===\\\"alert\\\"){alert(`Thread ${d.threadId}: ${d.text}`)}else if(d.target===\\\"setimmediate\\\"){worker.postMessage(d)}else if(cmd===\\\"callHandler\\\"){Module[d.handler](...d.args)}else if(cmd){err(`worker sent an unknown command ${cmd}`)}};worker.onerror=e=>{var message=\\\"worker sent an error!\\\";err(`${message} ${e.filename}:${e.lineno}: ${e.message}`);throw e};if(ENVIRONMENT_IS_NODE){worker.on(\\\"message\\\",data=>worker.onmessage({data}));worker.on(\\\"error\\\",e=>worker.onerror(e))}var handlers=[];var knownHandlers=[\\\"onExit\\\",\\\"onAbort\\\",\\\"print\\\",\\\"printErr\\\"];for(var handler of knownHandlers){if(Module.propertyIsEnumerable(handler)){handlers.push(handler)}}worker.postMessage({cmd:\\\"load\\\",handlers,wasmMemory,wasmModule})}),loadWasmModuleToAllWorkers(onMaybeReady){if(ENVIRONMENT_IS_PTHREAD){return onMaybeReady()}let pthreadPoolReady=Promise.all(PThread.unusedWorkers.map(PThread.loadWasmModuleToWorker));pthreadPoolReady.then(onMaybeReady)},allocateUnusedWorker(){var worker;var workerOptions={workerData:\\\"em-pthread\\\",name:\\\"em-pthread\\\"};var pthreadMainJs=_scriptName;if(Module[\\\"mainScriptUrlOrBlob\\\"]){pthreadMainJs=Module[\\\"mainScriptUrlOrBlob\\\"];if(typeof pthreadMainJs!=\\\"string\\\"){pthreadMainJs=URL.createObjectURL(pthreadMainJs)}}worker=new Worker(pthreadMainJs,workerOptions);PThread.unusedWorkers.push(worker)},getNewWorker(){if(PThread.unusedWorkers.length==0){PThread.allocateUnusedWorker();PThread.loadWasmModuleToWorker(PThread.unusedWorkers[0])}return PThread.unusedWorkers.pop()}};Module[\\\"PThread\\\"]=PThread;var onPostRuns=[];Module[\\\"onPostRuns\\\"]=onPostRuns;var addOnPostRun=cb=>onPostRuns.unshift(cb);Module[\\\"addOnPostRun\\\"]=addOnPostRun;var establishStackSpace=pthread_ptr=>{updateMemoryViews();var stackHigh=GROWABLE_HEAP_U32()[pthread_ptr+52>>>2>>>0];var stackSize=GROWABLE_HEAP_U32()[pthread_ptr+56>>>2>>>0];var stackLow=stackHigh-stackSize;_emscripten_stack_set_limits(stackHigh,stackLow);stackRestore(stackHigh)};Module[\\\"establishStackSpace\\\"]=establishStackSpace;function getValue(ptr,type=\\\"i8\\\"){if(type.endsWith(\\\"*\\\"))type=\\\"*\\\";switch(type){case\\\"i1\\\":return GROWABLE_HEAP_I8()[ptr>>>0];case\\\"i8\\\":return GROWABLE_HEAP_I8()[ptr>>>0];case\\\"i16\\\":return GROWABLE_HEAP_I16()[ptr>>>1>>>0];case\\\"i32\\\":return GROWABLE_HEAP_I32()[ptr>>>2>>>0];case\\\"i64\\\":return HEAP64[ptr>>>3];case\\\"float\\\":return GROWABLE_HEAP_F32()[ptr>>>2>>>0];case\\\"double\\\":return GROWABLE_HEAP_F64()[ptr>>>3>>>0];case\\\"*\\\":return GROWABLE_HEAP_U32()[ptr>>>2>>>0];default:abort(`invalid type for getValue: ${type}`)}}Module[\\\"getValue\\\"]=getValue;var wasmTableMirror=[];Module[\\\"wasmTableMirror\\\"]=wasmTableMirror;var wasmTable;Module[\\\"wasmTable\\\"]=wasmTable;var getWasmTableEntry=funcPtr=>{var func=wasmTableMirror[funcPtr];if(!func){if(funcPtr>=wasmTableMirror.length)wasmTableMirror.length=funcPtr+1;wasmTableMirror[funcPtr]=func=wasmTable.get(funcPtr)}return func};Module[\\\"getWasmTableEntry\\\"]=getWasmTableEntry;var invokeEntryPoint=(ptr,arg)=>{runtimeKeepaliveCounter=0;noExitRuntime=0;var result=getWasmTableEntry(ptr)(arg);function finish(result){if(keepRuntimeAlive()){EXITSTATUS=result}else{__emscripten_thread_exit(result)}}finish(result)};Module[\\\"invokeEntryPoint\\\"]=invokeEntryPoint;var noExitRuntime=Module[\\\"noExitRuntime\\\"]||true;Module[\\\"noExitRuntime\\\"]=noExitRuntime;var registerTLSInit=tlsInitFunc=>PThread.tlsInitFunctions.push(tlsInitFunc);Module[\\\"registerTLSInit\\\"]=registerTLSInit;function setValue(ptr,value,type=\\\"i8\\\"){if(type.endsWith(\\\"*\\\"))type=\\\"*\\\";switch(type){case\\\"i1\\\":GROWABLE_HEAP_I8()[ptr>>>0]=value;break;case\\\"i8\\\":GROWABLE_HEAP_I8()[ptr>>>0]=value;break;case\\\"i16\\\":GROWABLE_HEAP_I16()[ptr>>>1>>>0]=value;break;case\\\"i32\\\":GROWABLE_HEAP_I32()[ptr>>>2>>>0]=value;break;case\\\"i64\\\":HEAP64[ptr>>>3]=BigInt(value);break;case\\\"float\\\":GROWABLE_HEAP_F32()[ptr>>>2>>>0]=value;break;case\\\"double\\\":GROWABLE_HEAP_F64()[ptr>>>3>>>0]=value;break;case\\\"*\\\":GROWABLE_HEAP_U32()[ptr>>>2>>>0]=value;break;default:abort(`invalid type for setValue: ${type}`)}}Module[\\\"setValue\\\"]=setValue;function pthreadCreateProxied(pthread_ptr,attr,startRoutine,arg){if(ENVIRONMENT_IS_PTHREAD)return proxyToMainThread(2,0,1,pthread_ptr,attr,startRoutine,arg);return ___pthread_create_js(pthread_ptr,attr,startRoutine,arg)}Module[\\\"pthreadCreateProxied\\\"]=pthreadCreateProxied;var _emscripten_has_threading_support=()=>typeof SharedArrayBuffer!=\\\"undefined\\\";Module[\\\"_emscripten_has_threading_support\\\"]=_emscripten_has_threading_support;function ___pthread_create_js(pthread_ptr,attr,startRoutine,arg){pthread_ptr>>>=0;attr>>>=0;startRoutine>>>=0;arg>>>=0;if(!_emscripten_has_threading_support()){return 6}var transferList=[];var error=0;if(ENVIRONMENT_IS_PTHREAD&&(transferList.length===0||error)){return pthreadCreateProxied(pthread_ptr,attr,startRoutine,arg)}if(error)return error;var threadParams={startRoutine,pthread_ptr,arg,transferList};if(ENVIRONMENT_IS_PTHREAD){threadParams.cmd=\\\"spawnThread\\\";postMessage(threadParams,transferList);return 0}return spawnThread(threadParams)}Module[\\\"___pthread_create_js\\\"]=___pthread_create_js;var syscallGetVarargI=()=>{var ret=GROWABLE_HEAP_I32()[+SYSCALLS.varargs>>>2>>>0];SYSCALLS.varargs+=4;return ret};Module[\\\"syscallGetVarargI\\\"]=syscallGetVarargI;var syscallGetVarargP=syscallGetVarargI;Module[\\\"syscallGetVarargP\\\"]=syscallGetVarargP;var PATH={isAbs:path=>path.charAt(0)===\\\"/\\\",splitPath:filename=>{var splitPathRe=/^(\\\\/?|)([\\\\s\\\\S]*?)((?:\\\\.{1,2}|[^\\\\/]+?|)(\\\\.[^.\\\\/]*|))(?:[\\\\/]*)$/;return splitPathRe.exec(filename).slice(1)},normalizeArray:(parts,allowAboveRoot)=>{var up=0;for(var i=parts.length-1;i>=0;i--){var last=parts[i];if(last===\\\".\\\"){parts.splice(i,1)}else if(last===\\\"..\\\"){parts.splice(i,1);up++}else if(up){parts.splice(i,1);up--}}if(allowAboveRoot){for(;up;up--){parts.unshift(\\\"..\\\")}}return parts},normalize:path=>{var isAbsolute=PATH.isAbs(path),trailingSlash=path.slice(-1)===\\\"/\\\";path=PATH.normalizeArray(path.split(\\\"/\\\").filter(p=>!!p),!isAbsolute).join(\\\"/\\\");if(!path&&!isAbsolute){path=\\\".\\\"}if(path&&trailingSlash){path+=\\\"/\\\"}return(isAbsolute?\\\"/\\\":\\\"\\\")+path},dirname:path=>{var result=PATH.splitPath(path),root=result[0],dir=result[1];if(!root&&!dir){return\\\".\\\"}if(dir){dir=dir.slice(0,-1)}return root+dir},basename:path=>path&&path.match(/([^\\\\/]+|\\\\/)\\\\/*$/)[1],join:(...paths)=>PATH.normalize(paths.join(\\\"/\\\")),join2:(l,r)=>PATH.normalize(l+\\\"/\\\"+r)};Module[\\\"PATH\\\"]=PATH;var initRandomFill=()=>{if(ENVIRONMENT_IS_NODE){var nodeCrypto=require(\\\"crypto\\\");return view=>nodeCrypto.randomFillSync(view)}return view=>view.set(crypto.getRandomValues(new Uint8Array(view.byteLength)))};Module[\\\"initRandomFill\\\"]=initRandomFill;var randomFill=view=>{(randomFill=initRandomFill())(view)};Module[\\\"randomFill\\\"]=randomFill;var PATH_FS={resolve:(...args)=>{var resolvedPath=\\\"\\\",resolvedAbsolute=false;for(var i=args.length-1;i>=-1&&!resolvedAbsolute;i--){var path=i>=0?args[i]:FS.cwd();if(typeof path!=\\\"string\\\"){throw new TypeError(\\\"Arguments to path.resolve must be strings\\\")}else if(!path){return\\\"\\\"}resolvedPath=path+\\\"/\\\"+resolvedPath;resolvedAbsolute=PATH.isAbs(path)}resolvedPath=PATH.normalizeArray(resolvedPath.split(\\\"/\\\").filter(p=>!!p),!resolvedAbsolute).join(\\\"/\\\");return(resolvedAbsolute?\\\"/\\\":\\\"\\\")+resolvedPath||\\\".\\\"},relative:(from,to)=>{from=PATH_FS.resolve(from).slice(1);to=PATH_FS.resolve(to).slice(1);function trim(arr){var start=0;for(;start<arr.length;start++){if(arr[start]!==\\\"\\\")break}var end=arr.length-1;for(;end>=0;end--){if(arr[end]!==\\\"\\\")break}if(start>end)return[];return arr.slice(start,end-start+1)}var fromParts=trim(from.split(\\\"/\\\"));var toParts=trim(to.split(\\\"/\\\"));var length=Math.min(fromParts.length,toParts.length);var samePartsLength=length;for(var i=0;i<length;i++){if(fromParts[i]!==toParts[i]){samePartsLength=i;break}}var outputParts=[];for(var i=samePartsLength;i<fromParts.length;i++){outputParts.push(\\\"..\\\")}outputParts=outputParts.concat(toParts.slice(samePartsLength));return outputParts.join(\\\"/\\\")}};Module[\\\"PATH_FS\\\"]=PATH_FS;var UTF8Decoder=typeof TextDecoder!=\\\"undefined\\\"?new TextDecoder:undefined;Module[\\\"UTF8Decoder\\\"]=UTF8Decoder;var UTF8ArrayToString=(heapOrArray,idx=0,maxBytesToRead=NaN)=>{idx>>>=0;var endIdx=idx+maxBytesToRead;var endPtr=idx;while(heapOrArray[endPtr]&&!(endPtr>=endIdx))++endPtr;if(endPtr-idx>16&&heapOrArray.buffer&&UTF8Decoder){return UTF8Decoder.decode(heapOrArray.buffer instanceof ArrayBuffer?heapOrArray.subarray(idx,endPtr):heapOrArray.slice(idx,endPtr))}var str=\\\"\\\";while(idx<endPtr){var u0=heapOrArray[idx++];if(!(u0&128)){str+=String.fromCharCode(u0);continue}var u1=heapOrArray[idx++]&63;if((u0&224)==192){str+=String.fromCharCode((u0&31)<<6|u1);continue}var u2=heapOrArray[idx++]&63;if((u0&240)==224){u0=(u0&15)<<12|u1<<6|u2}else{u0=(u0&7)<<18|u1<<12|u2<<6|heapOrArray[idx++]&63}if(u0<65536){str+=String.fromCharCode(u0)}else{var ch=u0-65536;str+=String.fromCharCode(55296|ch>>10,56320|ch&1023)}}return str};Module[\\\"UTF8ArrayToString\\\"]=UTF8ArrayToString;var FS_stdin_getChar_buffer=[];Module[\\\"FS_stdin_getChar_buffer\\\"]=FS_stdin_getChar_buffer;var lengthBytesUTF8=str=>{var len=0;for(var i=0;i<str.length;++i){var c=str.charCodeAt(i);if(c<=127){len++}else if(c<=2047){len+=2}else if(c>=55296&&c<=57343){len+=4;++i}else{len+=3}}return len};Module[\\\"lengthBytesUTF8\\\"]=lengthBytesUTF8;var stringToUTF8Array=(str,heap,outIdx,maxBytesToWrite)=>{outIdx>>>=0;if(!(maxBytesToWrite>0))return 0;var startIdx=outIdx;var endIdx=outIdx+maxBytesToWrite-1;for(var i=0;i<str.length;++i){var u=str.charCodeAt(i);if(u>=55296&&u<=57343){var u1=str.charCodeAt(++i);u=65536+((u&1023)<<10)|u1&1023}if(u<=127){if(outIdx>=endIdx)break;heap[outIdx++>>>0]=u}else if(u<=2047){if(outIdx+1>=endIdx)break;heap[outIdx++>>>0]=192|u>>6;heap[outIdx++>>>0]=128|u&63}else if(u<=65535){if(outIdx+2>=endIdx)break;heap[outIdx++>>>0]=224|u>>12;heap[outIdx++>>>0]=128|u>>6&63;heap[outIdx++>>>0]=128|u&63}else{if(outIdx+3>=endIdx)break;heap[outIdx++>>>0]=240|u>>18;heap[outIdx++>>>0]=128|u>>12&63;heap[outIdx++>>>0]=128|u>>6&63;heap[outIdx++>>>0]=128|u&63}}heap[outIdx>>>0]=0;return outIdx-startIdx};Module[\\\"stringToUTF8Array\\\"]=stringToUTF8Array;var intArrayFromString=(stringy,dontAddNull,length)=>{var len=length>0?length:lengthBytesUTF8(stringy)+1;var u8array=new Array(len);var numBytesWritten=stringToUTF8Array(stringy,u8array,0,u8array.length);if(dontAddNull)u8array.length=numBytesWritten;return u8array};Module[\\\"intArrayFromString\\\"]=intArrayFromString;var FS_stdin_getChar=()=>{if(!FS_stdin_getChar_buffer.length){var result=null;if(ENVIRONMENT_IS_NODE){var BUFSIZE=256;var buf=Buffer.alloc(BUFSIZE);var bytesRead=0;var fd=process.stdin.fd;try{bytesRead=fs.readSync(fd,buf,0,BUFSIZE)}catch(e){if(e.toString().includes(\\\"EOF\\\"))bytesRead=0;else throw e}if(bytesRead>0){result=buf.slice(0,bytesRead).toString(\\\"utf-8\\\")}}else if(typeof window!=\\\"undefined\\\"&&typeof window.prompt==\\\"function\\\"){result=window.prompt(\\\"Input: \\\");if(result!==null){result+=\\\"\\\\n\\\"}}else{}if(!result){return null}FS_stdin_getChar_buffer=intArrayFromString(result,true)}return FS_stdin_getChar_buffer.shift()};Module[\\\"FS_stdin_getChar\\\"]=FS_stdin_getChar;var TTY={ttys:[],init(){},shutdown(){},register(dev,ops){TTY.ttys[dev]={input:[],output:[],ops};FS.registerDevice(dev,TTY.stream_ops)},stream_ops:{open(stream){var tty=TTY.ttys[stream.node.rdev];if(!tty){throw new FS.ErrnoError(43)}stream.tty=tty;stream.seekable=false},close(stream){stream.tty.ops.fsync(stream.tty)},fsync(stream){stream.tty.ops.fsync(stream.tty)},read(stream,buffer,offset,length,pos){if(!stream.tty||!stream.tty.ops.get_char){throw new FS.ErrnoError(60)}var bytesRead=0;for(var i=0;i<length;i++){var result;try{result=stream.tty.ops.get_char(stream.tty)}catch(e){throw new FS.ErrnoError(29)}if(result===undefined&&bytesRead===0){throw new FS.ErrnoError(6)}if(result===null||result===undefined)break;bytesRead++;buffer[offset+i]=result}if(bytesRead){stream.node.atime=Date.now()}return bytesRead},write(stream,buffer,offset,length,pos){if(!stream.tty||!stream.tty.ops.put_char){throw new FS.ErrnoError(60)}try{for(var i=0;i<length;i++){stream.tty.ops.put_char(stream.tty,buffer[offset+i])}}catch(e){throw new FS.ErrnoError(29)}if(length){stream.node.mtime=stream.node.ctime=Date.now()}return i}},default_tty_ops:{get_char(tty){return FS_stdin_getChar()},put_char(tty,val){if(val===null||val===10){out(UTF8ArrayToString(tty.output));tty.output=[]}else{if(val!=0)tty.output.push(val)}},fsync(tty){if(tty.output?.length>0){out(UTF8ArrayToString(tty.output));tty.output=[]}},ioctl_tcgets(tty){return{c_iflag:25856,c_oflag:5,c_cflag:191,c_lflag:35387,c_cc:[3,28,127,21,4,0,1,0,17,19,26,0,18,15,23,22,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]}},ioctl_tcsets(tty,optional_actions,data){return 0},ioctl_tiocgwinsz(tty){return[24,80]}},default_tty1_ops:{put_char(tty,val){if(val===null||val===10){err(UTF8ArrayToString(tty.output));tty.output=[]}else{if(val!=0)tty.output.push(val)}},fsync(tty){if(tty.output?.length>0){err(UTF8ArrayToString(tty.output));tty.output=[]}}}};Module[\\\"TTY\\\"]=TTY;var zeroMemory=(address,size)=>{GROWABLE_HEAP_U8().fill(0,address,address+size)};Module[\\\"zeroMemory\\\"]=zeroMemory;var alignMemory=(size,alignment)=>Math.ceil(size/alignment)*alignment;Module[\\\"alignMemory\\\"]=alignMemory;var mmapAlloc=size=>{size=alignMemory(size,65536);var ptr=_emscripten_builtin_memalign(65536,size);if(ptr)zeroMemory(ptr,size);return ptr};Module[\\\"mmapAlloc\\\"]=mmapAlloc;var MEMFS={ops_table:null,mount(mount){return MEMFS.createNode(null,\\\"/\\\",16895,0)},createNode(parent,name,mode,dev){if(FS.isBlkdev(mode)||FS.isFIFO(mode)){throw new FS.ErrnoError(63)}MEMFS.ops_table||={dir:{node:{getattr:MEMFS.node_ops.getattr,setattr:MEMFS.node_ops.setattr,lookup:MEMFS.node_ops.lookup,mknod:MEMFS.node_ops.mknod,rename:MEMFS.node_ops.rename,unlink:MEMFS.node_ops.unlink,rmdir:MEMFS.node_ops.rmdir,readdir:MEMFS.node_ops.readdir,symlink:MEMFS.node_ops.symlink},stream:{llseek:MEMFS.stream_ops.llseek}},file:{node:{getattr:MEMFS.node_ops.getattr,setattr:MEMFS.node_ops.setattr},stream:{llseek:MEMFS.stream_ops.llseek,read:MEMFS.stream_ops.read,write:MEMFS.stream_ops.write,allocate:MEMFS.stream_ops.allocate,mmap:MEMFS.stream_ops.mmap,msync:MEMFS.stream_ops.msync}},link:{node:{getattr:MEMFS.node_ops.getattr,setattr:MEMFS.node_ops.setattr,readlink:MEMFS.node_ops.readlink},stream:{}},chrdev:{node:{getattr:MEMFS.node_ops.getattr,setattr:MEMFS.node_ops.setattr},stream:FS.chrdev_stream_ops}};var node=FS.createNode(parent,name,mode,dev);if(FS.isDir(node.mode)){node.node_ops=MEMFS.ops_table.dir.node;node.stream_ops=MEMFS.ops_table.dir.stream;node.contents={}}else if(FS.isFile(node.mode)){node.node_ops=MEMFS.ops_table.file.node;node.stream_ops=MEMFS.ops_table.file.stream;node.usedBytes=0;node.contents=null}else if(FS.isLink(node.mode)){node.node_ops=MEMFS.ops_table.link.node;node.stream_ops=MEMFS.ops_table.link.stream}else if(FS.isChrdev(node.mode)){node.node_ops=MEMFS.ops_table.chrdev.node;node.stream_ops=MEMFS.ops_table.chrdev.stream}node.atime=node.mtime=node.ctime=Date.now();if(parent){parent.contents[name]=node;parent.atime=parent.mtime=parent.ctime=node.atime}return node},getFileDataAsTypedArray(node){if(!node.contents)return new Uint8Array(0);if(node.contents.subarray)return node.contents.subarray(0,node.usedBytes);return new Uint8Array(node.contents)},expandFileStorage(node,newCapacity){var prevCapacity=node.contents?node.contents.length:0;if(prevCapacity>=newCapacity)return;var CAPACITY_DOUBLING_MAX=1024*1024;newCapacity=Math.max(newCapacity,prevCapacity*(prevCapacity<CAPACITY_DOUBLING_MAX?2:1.125)>>>0);if(prevCapacity!=0)newCapacity=Math.max(newCapacity,256);var oldContents=node.contents;node.contents=new Uint8Array(newCapacity);if(node.usedBytes>0)node.contents.set(oldContents.subarray(0,node.usedBytes),0)},resizeFileStorage(node,newSize){if(node.usedBytes==newSize)return;if(newSize==0){node.contents=null;node.usedBytes=0}else{var oldContents=node.contents;node.contents=new Uint8Array(newSize);if(oldContents){node.contents.set(oldContents.subarray(0,Math.min(newSize,node.usedBytes)))}node.usedBytes=newSize}},node_ops:{getattr(node){var attr={};attr.dev=FS.isChrdev(node.mode)?node.id:1;attr.ino=node.id;attr.mode=node.mode;attr.nlink=1;attr.uid=0;attr.gid=0;attr.rdev=node.rdev;if(FS.isDir(node.mode)){attr.size=4096}else if(FS.isFile(node.mode)){attr.size=node.usedBytes}else if(FS.isLink(node.mode)){attr.size=node.link.length}else{attr.size=0}attr.atime=new Date(node.atime);attr.mtime=new Date(node.mtime);attr.ctime=new Date(node.ctime);attr.blksize=4096;attr.blocks=Math.ceil(attr.size/attr.blksize);return attr},setattr(node,attr){for(const key of[\\\"mode\\\",\\\"atime\\\",\\\"mtime\\\",\\\"ctime\\\"]){if(attr[key]!=null){node[key]=attr[key]}}if(attr.size!==undefined){MEMFS.resizeFileStorage(node,attr.size)}},lookup(parent,name){throw MEMFS.doesNotExistError},mknod(parent,name,mode,dev){return MEMFS.createNode(parent,name,mode,dev)},rename(old_node,new_dir,new_name){var new_node;try{new_node=FS.lookupNode(new_dir,new_name)}catch(e){}if(new_node){if(FS.isDir(old_node.mode)){for(var i in new_node.contents){throw new FS.ErrnoError(55)}}FS.hashRemoveNode(new_node)}delete old_node.parent.contents[old_node.name];new_dir.contents[new_name]=old_node;old_node.name=new_name;new_dir.ctime=new_dir.mtime=old_node.parent.ctime=old_node.parent.mtime=Date.now()},unlink(parent,name){delete parent.contents[name];parent.ctime=parent.mtime=Date.now()},rmdir(parent,name){var node=FS.lookupNode(parent,name);for(var i in node.contents){throw new FS.ErrnoError(55)}delete parent.contents[name];parent.ctime=parent.mtime=Date.now()},readdir(node){return[\\\".\\\",\\\"..\\\",...Object.keys(node.contents)]},symlink(parent,newname,oldpath){var node=MEMFS.createNode(parent,newname,511|40960,0);node.link=oldpath;return node},readlink(node){if(!FS.isLink(node.mode)){throw new FS.ErrnoError(28)}return node.link}},stream_ops:{read(stream,buffer,offset,length,position){var contents=stream.node.contents;if(position>=stream.node.usedBytes)return 0;var size=Math.min(stream.node.usedBytes-position,length);if(size>8&&contents.subarray){buffer.set(contents.subarray(position,position+size),offset)}else{for(var i=0;i<size;i++)buffer[offset+i]=contents[position+i]}return size},write(stream,buffer,offset,length,position,canOwn){if(buffer.buffer===GROWABLE_HEAP_I8().buffer){canOwn=false}if(!length)return 0;var node=stream.node;node.mtime=node.ctime=Date.now();if(buffer.subarray&&(!node.contents||node.contents.subarray)){if(canOwn){node.contents=buffer.subarray(offset,offset+length);node.usedBytes=length;return length}else if(node.usedBytes===0&&position===0){node.contents=buffer.slice(offset,offset+length);node.usedBytes=length;return length}else if(position+length<=node.usedBytes){node.contents.set(buffer.subarray(offset,offset+length),position);return length}}MEMFS.expandFileStorage(node,position+length);if(node.contents.subarray&&buffer.subarray){node.contents.set(buffer.subarray(offset,offset+length),position)}else{for(var i=0;i<length;i++){node.contents[position+i]=buffer[offset+i]}}node.usedBytes=Math.max(node.usedBytes,position+length);return length},llseek(stream,offset,whence){var position=offset;if(whence===1){position+=stream.position}else if(whence===2){if(FS.isFile(stream.node.mode)){position+=stream.node.usedBytes}}if(position<0){throw new FS.ErrnoError(28)}return position},allocate(stream,offset,length){MEMFS.expandFileStorage(stream.node,offset+length);stream.node.usedBytes=Math.max(stream.node.usedBytes,offset+length)},mmap(stream,length,position,prot,flags){if(!FS.isFile(stream.node.mode)){throw new FS.ErrnoError(43)}var ptr;var allocated;var contents=stream.node.contents;if(!(flags&2)&&contents&&contents.buffer===GROWABLE_HEAP_I8().buffer){allocated=false;ptr=contents.byteOffset}else{allocated=true;ptr=mmapAlloc(length);if(!ptr){throw new FS.ErrnoError(48)}if(contents){if(position>0||position+length<contents.length){if(contents.subarray){contents=contents.subarray(position,position+length)}else{contents=Array.prototype.slice.call(contents,position,position+length)}}GROWABLE_HEAP_I8().set(contents,ptr>>>0)}}return{ptr,allocated}},msync(stream,buffer,offset,length,mmapFlags){MEMFS.stream_ops.write(stream,buffer,0,length,offset,false);return 0}}};Module[\\\"MEMFS\\\"]=MEMFS;var asyncLoad=async url=>{var arrayBuffer=await readAsync(url);return new Uint8Array(arrayBuffer)};Module[\\\"asyncLoad\\\"]=asyncLoad;var FS_createDataFile=(parent,name,fileData,canRead,canWrite,canOwn)=>{FS.createDataFile(parent,name,fileData,canRead,canWrite,canOwn)};Module[\\\"FS_createDataFile\\\"]=FS_createDataFile;var preloadPlugins=Module[\\\"preloadPlugins\\\"]||[];Module[\\\"preloadPlugins\\\"]=preloadPlugins;var FS_handledByPreloadPlugin=(byteArray,fullname,finish,onerror)=>{if(typeof Browser!=\\\"undefined\\\")Browser.init();var handled=false;preloadPlugins.forEach(plugin=>{if(handled)return;if(plugin[\\\"canHandle\\\"](fullname)){plugin[\\\"handle\\\"](byteArray,fullname,finish,onerror);handled=true}});return handled};Module[\\\"FS_handledByPreloadPlugin\\\"]=FS_handledByPreloadPlugin;var FS_createPreloadedFile=(parent,name,url,canRead,canWrite,onload,onerror,dontCreateFile,canOwn,preFinish)=>{var fullname=name?PATH_FS.resolve(PATH.join2(parent,name)):parent;var dep=getUniqueRunDependency(`cp ${fullname}`);function processData(byteArray){function finish(byteArray){preFinish?.();if(!dontCreateFile){FS_createDataFile(parent,name,byteArray,canRead,canWrite,canOwn)}onload?.();removeRunDependency(dep)}if(FS_handledByPreloadPlugin(byteArray,fullname,finish,()=>{onerror?.();removeRunDependency(dep)})){return}finish(byteArray)}addRunDependency(dep);if(typeof url==\\\"string\\\"){asyncLoad(url).then(processData,onerror)}else{processData(url)}};Module[\\\"FS_createPreloadedFile\\\"]=FS_createPreloadedFile;var FS_modeStringToFlags=str=>{var flagModes={r:0,\\\"r+\\\":2,w:512|64|1,\\\"w+\\\":512|64|2,a:1024|64|1,\\\"a+\\\":1024|64|2};var flags=flagModes[str];if(typeof flags==\\\"undefined\\\"){throw new Error(`Unknown file open mode: ${str}`)}return flags};Module[\\\"FS_modeStringToFlags\\\"]=FS_modeStringToFlags;var FS_getMode=(canRead,canWrite)=>{var mode=0;if(canRead)mode|=292|73;if(canWrite)mode|=146;return mode};Module[\\\"FS_getMode\\\"]=FS_getMode;var FS={root:null,mounts:[],devices:{},streams:[],nextInode:1,nameTable:null,currentPath:\\\"/\\\",initialized:false,ignorePermissions:true,ErrnoError:class{name=\\\"ErrnoError\\\";constructor(errno){this.errno=errno}},filesystems:null,syncFSRequests:0,readFiles:{},FSStream:class{shared={};get object(){return this.node}set object(val){this.node=val}get isRead(){return(this.flags&2097155)!==1}get isWrite(){return(this.flags&2097155)!==0}get isAppend(){return this.flags&1024}get flags(){return this.shared.flags}set flags(val){this.shared.flags=val}get position(){return this.shared.position}set position(val){this.shared.position=val}},FSNode:class{node_ops={};stream_ops={};readMode=292|73;writeMode=146;mounted=null;constructor(parent,name,mode,rdev){if(!parent){parent=this}this.parent=parent;this.mount=parent.mount;this.id=FS.nextInode++;this.name=name;this.mode=mode;this.rdev=rdev;this.atime=this.mtime=this.ctime=Date.now()}get read(){return(this.mode&this.readMode)===this.readMode}set read(val){val?this.mode|=this.readMode:this.mode&=~this.readMode}get write(){return(this.mode&this.writeMode)===this.writeMode}set write(val){val?this.mode|=this.writeMode:this.mode&=~this.writeMode}get isFolder(){return FS.isDir(this.mode)}get isDevice(){return FS.isChrdev(this.mode)}},lookupPath(path,opts={}){if(!path){throw new FS.ErrnoError(44)}opts.follow_mount??=true;if(!PATH.isAbs(path)){path=FS.cwd()+\\\"/\\\"+path}linkloop:for(var nlinks=0;nlinks<40;nlinks++){var parts=path.split(\\\"/\\\").filter(p=>!!p);var current=FS.root;var current_path=\\\"/\\\";for(var i=0;i<parts.length;i++){var islast=i===parts.length-1;if(islast&&opts.parent){break}if(parts[i]===\\\".\\\"){continue}if(parts[i]===\\\"..\\\"){current_path=PATH.dirname(current_path);current=current.parent;continue}current_path=PATH.join2(current_path,parts[i]);try{current=FS.lookupNode(current,parts[i])}catch(e){if(e?.errno===44&&islast&&opts.noent_okay){return{path:current_path}}throw e}if(FS.isMountpoint(current)&&(!islast||opts.follow_mount)){current=current.mounted.root}if(FS.isLink(current.mode)&&(!islast||opts.follow)){if(!current.node_ops.readlink){throw new FS.ErrnoError(52)}var link=current.node_ops.readlink(current);if(!PATH.isAbs(link)){link=PATH.dirname(current_path)+\\\"/\\\"+link}path=link+\\\"/\\\"+parts.slice(i+1).join(\\\"/\\\");continue linkloop}}return{path:current_path,node:current}}throw new FS.ErrnoError(32)},getPath(node){var path;while(true){if(FS.isRoot(node)){var mount=node.mount.mountpoint;if(!path)return mount;return mount[mount.length-1]!==\\\"/\\\"?`${mount}/${path}`:mount+path}path=path?`${node.name}/${path}`:node.name;node=node.parent}},hashName(parentid,name){var hash=0;for(var i=0;i<name.length;i++){hash=(hash<<5)-hash+name.charCodeAt(i)|0}return(parentid+hash>>>0)%FS.nameTable.length},hashAddNode(node){var hash=FS.hashName(node.parent.id,node.name);node.name_next=FS.nameTable[hash];FS.nameTable[hash]=node},hashRemoveNode(node){var hash=FS.hashName(node.parent.id,node.name);if(FS.nameTable[hash]===node){FS.nameTable[hash]=node.name_next}else{var current=FS.nameTable[hash];while(current){if(current.name_next===node){current.name_next=node.name_next;break}current=current.name_next}}},lookupNode(parent,name){var errCode=FS.mayLookup(parent);if(errCode){throw new FS.ErrnoError(errCode)}var hash=FS.hashName(parent.id,name);for(var node=FS.nameTable[hash];node;node=node.name_next){var nodeName=node.name;if(node.parent.id===parent.id&&nodeName===name){return node}}return FS.lookup(parent,name)},createNode(parent,name,mode,rdev){var node=new FS.FSNode(parent,name,mode,rdev);FS.hashAddNode(node);return node},destroyNode(node){FS.hashRemoveNode(node)},isRoot(node){return node===node.parent},isMountpoint(node){return!!node.mounted},isFile(mode){return(mode&61440)===32768},isDir(mode){return(mode&61440)===16384},isLink(mode){return(mode&61440)===40960},isChrdev(mode){return(mode&61440)===8192},isBlkdev(mode){return(mode&61440)===24576},isFIFO(mode){return(mode&61440)===4096},isSocket(mode){return(mode&49152)===49152},flagsToPermissionString(flag){var perms=[\\\"r\\\",\\\"w\\\",\\\"rw\\\"][flag&3];if(flag&512){perms+=\\\"w\\\"}return perms},nodePermissions(node,perms){if(FS.ignorePermissions){return 0}if(perms.includes(\\\"r\\\")&&!(node.mode&292)){return 2}else if(perms.includes(\\\"w\\\")&&!(node.mode&146)){return 2}else if(perms.includes(\\\"x\\\")&&!(node.mode&73)){return 2}return 0},mayLookup(dir){if(!FS.isDir(dir.mode))return 54;var errCode=FS.nodePermissions(dir,\\\"x\\\");if(errCode)return errCode;if(!dir.node_ops.lookup)return 2;return 0},mayCreate(dir,name){if(!FS.isDir(dir.mode)){return 54}try{var node=FS.lookupNode(dir,name);return 20}catch(e){}return FS.nodePermissions(dir,\\\"wx\\\")},mayDelete(dir,name,isdir){var node;try{node=FS.lookupNode(dir,name)}catch(e){return e.errno}var errCode=FS.nodePermissions(dir,\\\"wx\\\");if(errCode){return errCode}if(isdir){if(!FS.isDir(node.mode)){return 54}if(FS.isRoot(node)||FS.getPath(node)===FS.cwd()){return 10}}else{if(FS.isDir(node.mode)){return 31}}return 0},mayOpen(node,flags){if(!node){return 44}if(FS.isLink(node.mode)){return 32}else if(FS.isDir(node.mode)){if(FS.flagsToPermissionString(flags)!==\\\"r\\\"||flags&(512|64)){return 31}}return FS.nodePermissions(node,FS.flagsToPermissionString(flags))},checkOpExists(op,err){if(!op){throw new FS.ErrnoError(err)}return op},MAX_OPEN_FDS:4096,nextfd(){for(var fd=0;fd<=FS.MAX_OPEN_FDS;fd++){if(!FS.streams[fd]){return fd}}throw new FS.ErrnoError(33)},getStreamChecked(fd){var stream=FS.getStream(fd);if(!stream){throw new FS.ErrnoError(8)}return stream},getStream:fd=>FS.streams[fd],createStream(stream,fd=-1){stream=Object.assign(new FS.FSStream,stream);if(fd==-1){fd=FS.nextfd()}stream.fd=fd;FS.streams[fd]=stream;return stream},closeStream(fd){FS.streams[fd]=null},dupStream(origStream,fd=-1){var stream=FS.createStream(origStream,fd);stream.stream_ops?.dup?.(stream);return stream},doSetAttr(stream,node,attr){var setattr=stream?.stream_ops.setattr;var arg=setattr?stream:node;setattr??=node.node_ops.setattr;FS.checkOpExists(setattr,63);setattr(arg,attr)},chrdev_stream_ops:{open(stream){var device=FS.getDevice(stream.node.rdev);stream.stream_ops=device.stream_ops;stream.stream_ops.open?.(stream)},llseek(){throw new FS.ErrnoError(70)}},major:dev=>dev>>8,minor:dev=>dev&255,makedev:(ma,mi)=>ma<<8|mi,registerDevice(dev,ops){FS.devices[dev]={stream_ops:ops}},getDevice:dev=>FS.devices[dev],getMounts(mount){var mounts=[];var check=[mount];while(check.length){var m=check.pop();mounts.push(m);check.push(...m.mounts)}return mounts},syncfs(populate,callback){if(typeof populate==\\\"function\\\"){callback=populate;populate=false}FS.syncFSRequests++;if(FS.syncFSRequests>1){err(`warning: ${FS.syncFSRequests} FS.syncfs operations in flight at once, probably just doing extra work`)}var mounts=FS.getMounts(FS.root.mount);var completed=0;function doCallback(errCode){FS.syncFSRequests--;return callback(errCode)}function done(errCode){if(errCode){if(!done.errored){done.errored=true;return doCallback(errCode)}return}if(++completed>=mounts.length){doCallback(null)}}mounts.forEach(mount=>{if(!mount.type.syncfs){return done(null)}mount.type.syncfs(mount,populate,done)})},mount(type,opts,mountpoint){var root=mountpoint===\\\"/\\\";var pseudo=!mountpoint;var node;if(root&&FS.root){throw new FS.ErrnoError(10)}else if(!root&&!pseudo){var lookup=FS.lookupPath(mountpoint,{follow_mount:false});mountpoint=lookup.path;node=lookup.node;if(FS.isMountpoint(node)){throw new FS.ErrnoError(10)}if(!FS.isDir(node.mode)){throw new FS.ErrnoError(54)}}var mount={type,opts,mountpoint,mounts:[]};var mountRoot=type.mount(mount);mountRoot.mount=mount;mount.root=mountRoot;if(root){FS.root=mountRoot}else if(node){node.mounted=mount;if(node.mount){node.mount.mounts.push(mount)}}return mountRoot},unmount(mountpoint){var lookup=FS.lookupPath(mountpoint,{follow_mount:false});if(!FS.isMountpoint(lookup.node)){throw new FS.ErrnoError(28)}var node=lookup.node;var mount=node.mounted;var mounts=FS.getMounts(mount);Object.keys(FS.nameTable).forEach(hash=>{var current=FS.nameTable[hash];while(current){var next=current.name_next;if(mounts.includes(current.mount)){FS.destroyNode(current)}current=next}});node.mounted=null;var idx=node.mount.mounts.indexOf(mount);node.mount.mounts.splice(idx,1)},lookup(parent,name){return parent.node_ops.lookup(parent,name)},mknod(path,mode,dev){var lookup=FS.lookupPath(path,{parent:true});var parent=lookup.node;var name=PATH.basename(path);if(!name){throw new FS.ErrnoError(28)}if(name===\\\".\\\"||name===\\\"..\\\"){throw new FS.ErrnoError(20)}var errCode=FS.mayCreate(parent,name);if(errCode){throw new FS.ErrnoError(errCode)}if(!parent.node_ops.mknod){throw new FS.ErrnoError(63)}return parent.node_ops.mknod(parent,name,mode,dev)},statfs(path){return FS.statfsNode(FS.lookupPath(path,{follow:true}).node)},statfsStream(stream){return FS.statfsNode(stream.node)},statfsNode(node){var rtn={bsize:4096,frsize:4096,blocks:1e6,bfree:5e5,bavail:5e5,files:FS.nextInode,ffree:FS.nextInode-1,fsid:42,flags:2,namelen:255};if(node.node_ops.statfs){Object.assign(rtn,node.node_ops.statfs(node.mount.opts.root))}return rtn},create(path,mode=438){mode&=4095;mode|=32768;return FS.mknod(path,mode,0)},mkdir(path,mode=511){mode&=511|512;mode|=16384;return FS.mknod(path,mode,0)},mkdirTree(path,mode){var dirs=path.split(\\\"/\\\");var d=\\\"\\\";for(var i=0;i<dirs.length;++i){if(!dirs[i])continue;d+=\\\"/\\\"+dirs[i];try{FS.mkdir(d,mode)}catch(e){if(e.errno!=20)throw e}}},mkdev(path,mode,dev){if(typeof dev==\\\"undefined\\\"){dev=mode;mode=438}mode|=8192;return FS.mknod(path,mode,dev)},symlink(oldpath,newpath){if(!PATH_FS.resolve(oldpath)){throw new FS.ErrnoError(44)}var lookup=FS.lookupPath(newpath,{parent:true});var parent=lookup.node;if(!parent){throw new FS.ErrnoError(44)}var newname=PATH.basename(newpath);var errCode=FS.mayCreate(parent,newname);if(errCode){throw new FS.ErrnoError(errCode)}if(!parent.node_ops.symlink){throw new FS.ErrnoError(63)}return parent.node_ops.symlink(parent,newname,oldpath)},rename(old_path,new_path){var old_dirname=PATH.dirname(old_path);var new_dirname=PATH.dirname(new_path);var old_name=PATH.basename(old_path);var new_name=PATH.basename(new_path);var lookup,old_dir,new_dir;lookup=FS.lookupPath(old_path,{parent:true});old_dir=lookup.node;lookup=FS.lookupPath(new_path,{parent:true});new_dir=lookup.node;if(!old_dir||!new_dir)throw new FS.ErrnoError(44);if(old_dir.mount!==new_dir.mount){throw new FS.ErrnoError(75)}var old_node=FS.lookupNode(old_dir,old_name);var relative=PATH_FS.relative(old_path,new_dirname);if(relative.charAt(0)!==\\\".\\\"){throw new FS.ErrnoError(28)}relative=PATH_FS.relative(new_path,old_dirname);if(relative.charAt(0)!==\\\".\\\"){throw new FS.ErrnoError(55)}var new_node;try{new_node=FS.lookupNode(new_dir,new_name)}catch(e){}if(old_node===new_node){return}var isdir=FS.isDir(old_node.mode);var errCode=FS.mayDelete(old_dir,old_name,isdir);if(errCode){throw new FS.ErrnoError(errCode)}errCode=new_node?FS.mayDelete(new_dir,new_name,isdir):FS.mayCreate(new_dir,new_name);if(errCode){throw new FS.ErrnoError(errCode)}if(!old_dir.node_ops.rename){throw new FS.ErrnoError(63)}if(FS.isMountpoint(old_node)||new_node&&FS.isMountpoint(new_node)){throw new FS.ErrnoError(10)}if(new_dir!==old_dir){errCode=FS.nodePermissions(old_dir,\\\"w\\\");if(errCode){throw new FS.ErrnoError(errCode)}}FS.hashRemoveNode(old_node);try{old_dir.node_ops.rename(old_node,new_dir,new_name);old_node.parent=new_dir}catch(e){throw e}finally{FS.hashAddNode(old_node)}},rmdir(path){var lookup=FS.lookupPath(path,{parent:true});var parent=lookup.node;var name=PATH.basename(path);var node=FS.lookupNode(parent,name);var errCode=FS.mayDelete(parent,name,true);if(errCode){throw new FS.ErrnoError(errCode)}if(!parent.node_ops.rmdir){throw new FS.ErrnoError(63)}if(FS.isMountpoint(node)){throw new FS.ErrnoError(10)}parent.node_ops.rmdir(parent,name);FS.destroyNode(node)},readdir(path){var lookup=FS.lookupPath(path,{follow:true});var node=lookup.node;var readdir=FS.checkOpExists(node.node_ops.readdir,54);return readdir(node)},unlink(path){var lookup=FS.lookupPath(path,{parent:true});var parent=lookup.node;if(!parent){throw new FS.ErrnoError(44)}var name=PATH.basename(path);var node=FS.lookupNode(parent,name);var errCode=FS.mayDelete(parent,name,false);if(errCode){throw new FS.ErrnoError(errCode)}if(!parent.node_ops.unlink){throw new FS.ErrnoError(63)}if(FS.isMountpoint(node)){throw new FS.ErrnoError(10)}parent.node_ops.unlink(parent,name);FS.destroyNode(node)},readlink(path){var lookup=FS.lookupPath(path);var link=lookup.node;if(!link){throw new FS.ErrnoError(44)}if(!link.node_ops.readlink){throw new FS.ErrnoError(28)}return link.node_ops.readlink(link)},stat(path,dontFollow){var lookup=FS.lookupPath(path,{follow:!dontFollow});var node=lookup.node;var getattr=FS.checkOpExists(node.node_ops.getattr,63);return getattr(node)},fstat(fd){var stream=FS.getStreamChecked(fd);var node=stream.node;var getattr=stream.stream_ops.getattr;var arg=getattr?stream:node;getattr??=node.node_ops.getattr;FS.checkOpExists(getattr,63);return getattr(arg)},lstat(path){return FS.stat(path,true)},doChmod(stream,node,mode,dontFollow){FS.doSetAttr(stream,node,{mode:mode&4095|node.mode&~4095,ctime:Date.now(),dontFollow})},chmod(path,mode,dontFollow){var node;if(typeof path==\\\"string\\\"){var lookup=FS.lookupPath(path,{follow:!dontFollow});node=lookup.node}else{node=path}FS.doChmod(null,node,mode,dontFollow)},lchmod(path,mode){FS.chmod(path,mode,true)},fchmod(fd,mode){var stream=FS.getStreamChecked(fd);FS.doChmod(stream,stream.node,mode,false)},doChown(stream,node,dontFollow){FS.doSetAttr(stream,node,{timestamp:Date.now(),dontFollow})},chown(path,uid,gid,dontFollow){var node;if(typeof path==\\\"string\\\"){var lookup=FS.lookupPath(path,{follow:!dontFollow});node=lookup.node}else{node=path}FS.doChown(null,node,dontFollow)},lchown(path,uid,gid){FS.chown(path,uid,gid,true)},fchown(fd,uid,gid){var stream=FS.getStreamChecked(fd);FS.doChown(stream,stream.node,false)},doTruncate(stream,node,len){if(FS.isDir(node.mode)){throw new FS.ErrnoError(31)}if(!FS.isFile(node.mode)){throw new FS.ErrnoError(28)}var errCode=FS.nodePermissions(node,\\\"w\\\");if(errCode){throw new FS.ErrnoError(errCode)}FS.doSetAttr(stream,node,{size:len,timestamp:Date.now()})},truncate(path,len){if(len<0){throw new FS.ErrnoError(28)}var node;if(typeof path==\\\"string\\\"){var lookup=FS.lookupPath(path,{follow:true});node=lookup.node}else{node=path}FS.doTruncate(null,node,len)},ftruncate(fd,len){var stream=FS.getStreamChecked(fd);if(len<0||(stream.flags&2097155)===0){throw new FS.ErrnoError(28)}FS.doTruncate(stream,stream.node,len)},utime(path,atime,mtime){var lookup=FS.lookupPath(path,{follow:true});var node=lookup.node;var setattr=FS.checkOpExists(node.node_ops.setattr,63);setattr(node,{atime,mtime})},open(path,flags,mode=438){if(path===\\\"\\\"){throw new FS.ErrnoError(44)}flags=typeof flags==\\\"string\\\"?FS_modeStringToFlags(flags):flags;if(flags&64){mode=mode&4095|32768}else{mode=0}var node;var isDirPath;if(typeof path==\\\"object\\\"){node=path}else{isDirPath=path.endsWith(\\\"/\\\");var lookup=FS.lookupPath(path,{follow:!(flags&131072),noent_okay:true});node=lookup.node;path=lookup.path}var created=false;if(flags&64){if(node){if(flags&128){throw new FS.ErrnoError(20)}}else if(isDirPath){throw new FS.ErrnoError(31)}else{node=FS.mknod(path,mode|511,0);created=true}}if(!node){throw new FS.ErrnoError(44)}if(FS.isChrdev(node.mode)){flags&=~512}if(flags&65536&&!FS.isDir(node.mode)){throw new FS.ErrnoError(54)}if(!created){var errCode=FS.mayOpen(node,flags);if(errCode){throw new FS.ErrnoError(errCode)}}if(flags&512&&!created){FS.truncate(node,0)}flags&=~(128|512|131072);var stream=FS.createStream({node,path:FS.getPath(node),flags,seekable:true,position:0,stream_ops:node.stream_ops,ungotten:[],error:false});if(stream.stream_ops.open){stream.stream_ops.open(stream)}if(created){FS.chmod(node,mode&511)}if(Module[\\\"logReadFiles\\\"]&&!(flags&1)){if(!(path in FS.readFiles)){FS.readFiles[path]=1}}return stream},close(stream){if(FS.isClosed(stream)){throw new FS.ErrnoError(8)}if(stream.getdents)stream.getdents=null;try{if(stream.stream_ops.close){stream.stream_ops.close(stream)}}catch(e){throw e}finally{FS.closeStream(stream.fd)}stream.fd=null},isClosed(stream){return stream.fd===null},llseek(stream,offset,whence){if(FS.isClosed(stream)){throw new FS.ErrnoError(8)}if(!stream.seekable||!stream.stream_ops.llseek){throw new FS.ErrnoError(70)}if(whence!=0&&whence!=1&&whence!=2){throw new FS.ErrnoError(28)}stream.position=stream.stream_ops.llseek(stream,offset,whence);stream.ungotten=[];return stream.position},read(stream,buffer,offset,length,position){if(length<0||position<0){throw new FS.ErrnoError(28)}if(FS.isClosed(stream)){throw new FS.ErrnoError(8)}if((stream.flags&2097155)===1){throw new FS.ErrnoError(8)}if(FS.isDir(stream.node.mode)){throw new FS.ErrnoError(31)}if(!stream.stream_ops.read){throw new FS.ErrnoError(28)}var seeking=typeof position!=\\\"undefined\\\";if(!seeking){position=stream.position}else if(!stream.seekable){throw new FS.ErrnoError(70)}var bytesRead=stream.stream_ops.read(stream,buffer,offset,length,position);if(!seeking)stream.position+=bytesRead;return bytesRead},write(stream,buffer,offset,length,position,canOwn){if(length<0||position<0){throw new FS.ErrnoError(28)}if(FS.isClosed(stream)){throw new FS.ErrnoError(8)}if((stream.flags&2097155)===0){throw new FS.ErrnoError(8)}if(FS.isDir(stream.node.mode)){throw new FS.ErrnoError(31)}if(!stream.stream_ops.write){throw new FS.ErrnoError(28)}if(stream.seekable&&stream.flags&1024){FS.llseek(stream,0,2)}var seeking=typeof position!=\\\"undefined\\\";if(!seeking){position=stream.position}else if(!stream.seekable){throw new FS.ErrnoError(70)}var bytesWritten=stream.stream_ops.write(stream,buffer,offset,length,position,canOwn);if(!seeking)stream.position+=bytesWritten;return bytesWritten},allocate(stream,offset,length){if(FS.isClosed(stream)){throw new FS.ErrnoError(8)}if(offset<0||length<=0){throw new FS.ErrnoError(28)}if((stream.flags&2097155)===0){throw new FS.ErrnoError(8)}if(!FS.isFile(stream.node.mode)&&!FS.isDir(stream.node.mode)){throw new FS.ErrnoError(43)}if(!stream.stream_ops.allocate){throw new FS.ErrnoError(138)}stream.stream_ops.allocate(stream,offset,length)},mmap(stream,length,position,prot,flags){if((prot&2)!==0&&(flags&2)===0&&(stream.flags&2097155)!==2){throw new FS.ErrnoError(2)}if((stream.flags&2097155)===1){throw new FS.ErrnoError(2)}if(!stream.stream_ops.mmap){throw new FS.ErrnoError(43)}if(!length){throw new FS.ErrnoError(28)}return stream.stream_ops.mmap(stream,length,position,prot,flags)},msync(stream,buffer,offset,length,mmapFlags){if(!stream.stream_ops.msync){return 0}return stream.stream_ops.msync(stream,buffer,offset,length,mmapFlags)},ioctl(stream,cmd,arg){if(!stream.stream_ops.ioctl){throw new FS.ErrnoError(59)}return stream.stream_ops.ioctl(stream,cmd,arg)},readFile(path,opts={}){opts.flags=opts.flags||0;opts.encoding=opts.encoding||\\\"binary\\\";if(opts.encoding!==\\\"utf8\\\"&&opts.encoding!==\\\"binary\\\"){throw new Error(`Invalid encoding type \\\"${opts.encoding}\\\"`)}var ret;var stream=FS.open(path,opts.flags);var stat=FS.stat(path);var length=stat.size;var buf=new Uint8Array(length);FS.read(stream,buf,0,length,0);if(opts.encoding===\\\"utf8\\\"){ret=UTF8ArrayToString(buf)}else if(opts.encoding===\\\"binary\\\"){ret=buf}FS.close(stream);return ret},writeFile(path,data,opts={}){opts.flags=opts.flags||577;var stream=FS.open(path,opts.flags,opts.mode);if(typeof data==\\\"string\\\"){var buf=new Uint8Array(lengthBytesUTF8(data)+1);var actualNumBytes=stringToUTF8Array(data,buf,0,buf.length);FS.write(stream,buf,0,actualNumBytes,undefined,opts.canOwn)}else if(ArrayBuffer.isView(data)){FS.write(stream,data,0,data.byteLength,undefined,opts.canOwn)}else{throw new Error(\\\"Unsupported data type\\\")}FS.close(stream)},cwd:()=>FS.currentPath,chdir(path){var lookup=FS.lookupPath(path,{follow:true});if(lookup.node===null){throw new FS.ErrnoError(44)}if(!FS.isDir(lookup.node.mode)){throw new FS.ErrnoError(54)}var errCode=FS.nodePermissions(lookup.node,\\\"x\\\");if(errCode){throw new FS.ErrnoError(errCode)}FS.currentPath=lookup.path},createDefaultDirectories(){FS.mkdir(\\\"/tmp\\\");FS.mkdir(\\\"/home\\\");FS.mkdir(\\\"/home/web_user\\\")},createDefaultDevices(){FS.mkdir(\\\"/dev\\\");FS.registerDevice(FS.makedev(1,3),{read:()=>0,write:(stream,buffer,offset,length,pos)=>length,llseek:()=>0});FS.mkdev(\\\"/dev/null\\\",FS.makedev(1,3));TTY.register(FS.makedev(5,0),TTY.default_tty_ops);TTY.register(FS.makedev(6,0),TTY.default_tty1_ops);FS.mkdev(\\\"/dev/tty\\\",FS.makedev(5,0));FS.mkdev(\\\"/dev/tty1\\\",FS.makedev(6,0));var randomBuffer=new Uint8Array(1024),randomLeft=0;var randomByte=()=>{if(randomLeft===0){randomFill(randomBuffer);randomLeft=randomBuffer.byteLength}return randomBuffer[--randomLeft]};FS.createDevice(\\\"/dev\\\",\\\"random\\\",randomByte);FS.createDevice(\\\"/dev\\\",\\\"urandom\\\",randomByte);FS.mkdir(\\\"/dev/shm\\\");FS.mkdir(\\\"/dev/shm/tmp\\\")},createSpecialDirectories(){FS.mkdir(\\\"/proc\\\");var proc_self=FS.mkdir(\\\"/proc/self\\\");FS.mkdir(\\\"/proc/self/fd\\\");FS.mount({mount(){var node=FS.createNode(proc_self,\\\"fd\\\",16895,73);node.stream_ops={llseek:MEMFS.stream_ops.llseek};node.node_ops={lookup(parent,name){var fd=+name;var stream=FS.getStreamChecked(fd);var ret={parent:null,mount:{mountpoint:\\\"fake\\\"},node_ops:{readlink:()=>stream.path},id:fd+1};ret.parent=ret;return ret},readdir(){return Array.from(FS.streams.entries()).filter(([k,v])=>v).map(([k,v])=>k.toString())}};return node}},{},\\\"/proc/self/fd\\\")},createStandardStreams(input,output,error){if(input){FS.createDevice(\\\"/dev\\\",\\\"stdin\\\",input)}else{FS.symlink(\\\"/dev/tty\\\",\\\"/dev/stdin\\\")}if(output){FS.createDevice(\\\"/dev\\\",\\\"stdout\\\",null,output)}else{FS.symlink(\\\"/dev/tty\\\",\\\"/dev/stdout\\\")}if(error){FS.createDevice(\\\"/dev\\\",\\\"stderr\\\",null,error)}else{FS.symlink(\\\"/dev/tty1\\\",\\\"/dev/stderr\\\")}var stdin=FS.open(\\\"/dev/stdin\\\",0);var stdout=FS.open(\\\"/dev/stdout\\\",1);var stderr=FS.open(\\\"/dev/stderr\\\",1)},staticInit(){FS.nameTable=new Array(4096);FS.mount(MEMFS,{},\\\"/\\\");FS.createDefaultDirectories();FS.createDefaultDevices();FS.createSpecialDirectories();FS.filesystems={MEMFS}},init(input,output,error){FS.initialized=true;input??=Module[\\\"stdin\\\"];output??=Module[\\\"stdout\\\"];error??=Module[\\\"stderr\\\"];FS.createStandardStreams(input,output,error)},quit(){FS.initialized=false;for(var i=0;i<FS.streams.length;i++){var stream=FS.streams[i];if(!stream){continue}FS.close(stream)}},findObject(path,dontResolveLastLink){var ret=FS.analyzePath(path,dontResolveLastLink);if(!ret.exists){return null}return ret.object},analyzePath(path,dontResolveLastLink){try{var lookup=FS.lookupPath(path,{follow:!dontResolveLastLink});path=lookup.path}catch(e){}var ret={isRoot:false,exists:false,error:0,name:null,path:null,object:null,parentExists:false,parentPath:null,parentObject:null};try{var lookup=FS.lookupPath(path,{parent:true});ret.parentExists=true;ret.parentPath=lookup.path;ret.parentObject=lookup.node;ret.name=PATH.basename(path);lookup=FS.lookupPath(path,{follow:!dontResolveLastLink});ret.exists=true;ret.path=lookup.path;ret.object=lookup.node;ret.name=lookup.node.name;ret.isRoot=lookup.path===\\\"/\\\"}catch(e){ret.error=e.errno}return ret},createPath(parent,path,canRead,canWrite){parent=typeof parent==\\\"string\\\"?parent:FS.getPath(parent);var parts=path.split(\\\"/\\\").reverse();while(parts.length){var part=parts.pop();if(!part)continue;var current=PATH.join2(parent,part);try{FS.mkdir(current)}catch(e){}parent=current}return current},createFile(parent,name,properties,canRead,canWrite){var path=PATH.join2(typeof parent==\\\"string\\\"?parent:FS.getPath(parent),name);var mode=FS_getMode(canRead,canWrite);return FS.create(path,mode)},createDataFile(parent,name,data,canRead,canWrite,canOwn){var path=name;if(parent){parent=typeof parent==\\\"string\\\"?parent:FS.getPath(parent);path=name?PATH.join2(parent,name):parent}var mode=FS_getMode(canRead,canWrite);var node=FS.create(path,mode);if(data){if(typeof data==\\\"string\\\"){var arr=new Array(data.length);for(var i=0,len=data.length;i<len;++i)arr[i]=data.charCodeAt(i);data=arr}FS.chmod(node,mode|146);var stream=FS.open(node,577);FS.write(stream,data,0,data.length,0,canOwn);FS.close(stream);FS.chmod(node,mode)}},createDevice(parent,name,input,output){var path=PATH.join2(typeof parent==\\\"string\\\"?parent:FS.getPath(parent),name);var mode=FS_getMode(!!input,!!output);FS.createDevice.major??=64;var dev=FS.makedev(FS.createDevice.major++,0);FS.registerDevice(dev,{open(stream){stream.seekable=false},close(stream){if(output?.buffer?.length){output(10)}},read(stream,buffer,offset,length,pos){var bytesRead=0;for(var i=0;i<length;i++){var result;try{result=input()}catch(e){throw new FS.ErrnoError(29)}if(result===undefined&&bytesRead===0){throw new FS.ErrnoError(6)}if(result===null||result===undefined)break;bytesRead++;buffer[offset+i]=result}if(bytesRead){stream.node.atime=Date.now()}return bytesRead},write(stream,buffer,offset,length,pos){for(var i=0;i<length;i++){try{output(buffer[offset+i])}catch(e){throw new FS.ErrnoError(29)}}if(length){stream.node.mtime=stream.node.ctime=Date.now()}return i}});return FS.mkdev(path,mode,dev)},forceLoadFile(obj){if(obj.isDevice||obj.isFolder||obj.link||obj.contents)return true;if(typeof XMLHttpRequest!=\\\"undefined\\\"){throw new Error(\\\"Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.\\\")}else{try{obj.contents=readBinary(obj.url);obj.usedBytes=obj.contents.length}catch(e){throw new FS.ErrnoError(29)}}},createLazyFile(parent,name,url,canRead,canWrite){class LazyUint8Array{lengthKnown=false;chunks=[];get(idx){if(idx>this.length-1||idx<0){return undefined}var chunkOffset=idx%this.chunkSize;var chunkNum=idx/this.chunkSize|0;return this.getter(chunkNum)[chunkOffset]}setDataGetter(getter){this.getter=getter}cacheLength(){var xhr=new XMLHttpRequest;xhr.open(\\\"HEAD\\\",url,false);xhr.send(null);if(!(xhr.status>=200&&xhr.status<300||xhr.status===304))throw new Error(\\\"Couldn't load \\\"+url+\\\". Status: \\\"+xhr.status);var datalength=Number(xhr.getResponseHeader(\\\"Content-length\\\"));var header;var hasByteServing=(header=xhr.getResponseHeader(\\\"Accept-Ranges\\\"))&&header===\\\"bytes\\\";var usesGzip=(header=xhr.getResponseHeader(\\\"Content-Encoding\\\"))&&header===\\\"gzip\\\";var chunkSize=1024*1024;if(!hasByteServing)chunkSize=datalength;var doXHR=(from,to)=>{if(from>to)throw new Error(\\\"invalid range (\\\"+from+\\\", \\\"+to+\\\") or no bytes requested!\\\");if(to>datalength-1)throw new Error(\\\"only \\\"+datalength+\\\" bytes available! programmer error!\\\");var xhr=new XMLHttpRequest;xhr.open(\\\"GET\\\",url,false);if(datalength!==chunkSize)xhr.setRequestHeader(\\\"Range\\\",\\\"bytes=\\\"+from+\\\"-\\\"+to);xhr.responseType=\\\"arraybuffer\\\";if(xhr.overrideMimeType){xhr.overrideMimeType(\\\"text/plain; charset=x-user-defined\\\")}xhr.send(null);if(!(xhr.status>=200&&xhr.status<300||xhr.status===304))throw new Error(\\\"Couldn't load \\\"+url+\\\". Status: \\\"+xhr.status);if(xhr.response!==undefined){return new Uint8Array(xhr.response||[])}return intArrayFromString(xhr.responseText||\\\"\\\",true)};var lazyArray=this;lazyArray.setDataGetter(chunkNum=>{var start=chunkNum*chunkSize;var end=(chunkNum+1)*chunkSize-1;end=Math.min(end,datalength-1);if(typeof lazyArray.chunks[chunkNum]==\\\"undefined\\\"){lazyArray.chunks[chunkNum]=doXHR(start,end)}if(typeof lazyArray.chunks[chunkNum]==\\\"undefined\\\")throw new Error(\\\"doXHR failed!\\\");return lazyArray.chunks[chunkNum]});if(usesGzip||!datalength){chunkSize=datalength=1;datalength=this.getter(0).length;chunkSize=datalength;out(\\\"LazyFiles on gzip forces download of the whole file when length is accessed\\\")}this._length=datalength;this._chunkSize=chunkSize;this.lengthKnown=true}get length(){if(!this.lengthKnown){this.cacheLength()}return this._length}get chunkSize(){if(!this.lengthKnown){this.cacheLength()}return this._chunkSize}}if(typeof XMLHttpRequest!=\\\"undefined\\\"){if(!ENVIRONMENT_IS_WORKER)throw\\\"Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc\\\";var lazyArray=new LazyUint8Array;var properties={isDevice:false,contents:lazyArray}}else{var properties={isDevice:false,url}}var node=FS.createFile(parent,name,properties,canRead,canWrite);if(properties.contents){node.contents=properties.contents}else if(properties.url){node.contents=null;node.url=properties.url}Object.defineProperties(node,{usedBytes:{get:function(){return this.contents.length}}});var stream_ops={};var keys=Object.keys(node.stream_ops);keys.forEach(key=>{var fn=node.stream_ops[key];stream_ops[key]=(...args)=>{FS.forceLoadFile(node);return fn(...args)}});function writeChunks(stream,buffer,offset,length,position){var contents=stream.node.contents;if(position>=contents.length)return 0;var size=Math.min(contents.length-position,length);if(contents.slice){for(var i=0;i<size;i++){buffer[offset+i]=contents[position+i]}}else{for(var i=0;i<size;i++){buffer[offset+i]=contents.get(position+i)}}return size}stream_ops.read=(stream,buffer,offset,length,position)=>{FS.forceLoadFile(node);return writeChunks(stream,buffer,offset,length,position)};stream_ops.mmap=(stream,length,position,prot,flags)=>{FS.forceLoadFile(node);var ptr=mmapAlloc(length);if(!ptr){throw new FS.ErrnoError(48)}writeChunks(stream,GROWABLE_HEAP_I8(),ptr,length,position);return{ptr,allocated:true}};node.stream_ops=stream_ops;return node}};Module[\\\"FS\\\"]=FS;var UTF8ToString=(ptr,maxBytesToRead)=>{ptr>>>=0;return ptr?UTF8ArrayToString(GROWABLE_HEAP_U8(),ptr,maxBytesToRead):\\\"\\\"};Module[\\\"UTF8ToString\\\"]=UTF8ToString;var SYSCALLS={DEFAULT_POLLMASK:5,calculateAt(dirfd,path,allowEmpty){if(PATH.isAbs(path)){return path}var dir;if(dirfd===-100){dir=FS.cwd()}else{var dirstream=SYSCALLS.getStreamFromFD(dirfd);dir=dirstream.path}if(path.length==0){if(!allowEmpty){throw new FS.ErrnoError(44)}return dir}return dir+\\\"/\\\"+path},writeStat(buf,stat){GROWABLE_HEAP_I32()[buf>>>2>>>0]=stat.dev;GROWABLE_HEAP_I32()[buf+4>>>2>>>0]=stat.mode;GROWABLE_HEAP_U32()[buf+8>>>2>>>0]=stat.nlink;GROWABLE_HEAP_I32()[buf+12>>>2>>>0]=stat.uid;GROWABLE_HEAP_I32()[buf+16>>>2>>>0]=stat.gid;GROWABLE_HEAP_I32()[buf+20>>>2>>>0]=stat.rdev;HEAP64[buf+24>>>3]=BigInt(stat.size);GROWABLE_HEAP_I32()[buf+32>>>2>>>0]=4096;GROWABLE_HEAP_I32()[buf+36>>>2>>>0]=stat.blocks;var atime=stat.atime.getTime();var mtime=stat.mtime.getTime();var ctime=stat.ctime.getTime();HEAP64[buf+40>>>3]=BigInt(Math.floor(atime/1e3));GROWABLE_HEAP_U32()[buf+48>>>2>>>0]=atime%1e3*1e3*1e3;HEAP64[buf+56>>>3]=BigInt(Math.floor(mtime/1e3));GROWABLE_HEAP_U32()[buf+64>>>2>>>0]=mtime%1e3*1e3*1e3;HEAP64[buf+72>>>3]=BigInt(Math.floor(ctime/1e3));GROWABLE_HEAP_U32()[buf+80>>>2>>>0]=ctime%1e3*1e3*1e3;HEAP64[buf+88>>>3]=BigInt(stat.ino);return 0},writeStatFs(buf,stats){GROWABLE_HEAP_I32()[buf+4>>>2>>>0]=stats.bsize;GROWABLE_HEAP_I32()[buf+40>>>2>>>0]=stats.bsize;GROWABLE_HEAP_I32()[buf+8>>>2>>>0]=stats.blocks;GROWABLE_HEAP_I32()[buf+12>>>2>>>0]=stats.bfree;GROWABLE_HEAP_I32()[buf+16>>>2>>>0]=stats.bavail;GROWABLE_HEAP_I32()[buf+20>>>2>>>0]=stats.files;GROWABLE_HEAP_I32()[buf+24>>>2>>>0]=stats.ffree;GROWABLE_HEAP_I32()[buf+28>>>2>>>0]=stats.fsid;GROWABLE_HEAP_I32()[buf+44>>>2>>>0]=stats.flags;GROWABLE_HEAP_I32()[buf+36>>>2>>>0]=stats.namelen},doMsync(addr,stream,len,flags,offset){if(!FS.isFile(stream.node.mode)){throw new FS.ErrnoError(43)}if(flags&2){return 0}var buffer=GROWABLE_HEAP_U8().slice(addr,addr+len);FS.msync(stream,buffer,offset,len,flags)},getStreamFromFD(fd){var stream=FS.getStreamChecked(fd);return stream},varargs:undefined,getStr(ptr){var ret=UTF8ToString(ptr);return ret}};Module[\\\"SYSCALLS\\\"]=SYSCALLS;function ___syscall_fcntl64(fd,cmd,varargs){if(ENVIRONMENT_IS_PTHREAD)return proxyToMainThread(3,0,1,fd,cmd,varargs);varargs>>>=0;SYSCALLS.varargs=varargs;try{var stream=SYSCALLS.getStreamFromFD(fd);switch(cmd){case 0:{var arg=syscallGetVarargI();if(arg<0){return-28}while(FS.streams[arg]){arg++}var newStream;newStream=FS.dupStream(stream,arg);return newStream.fd}case 1:case 2:return 0;case 3:return stream.flags;case 4:{var arg=syscallGetVarargI();stream.flags|=arg;return 0}case 12:{var arg=syscallGetVarargP();var offset=0;GROWABLE_HEAP_I16()[arg+offset>>>1>>>0]=2;return 0}case 13:case 14:return 0}return-28}catch(e){if(typeof FS==\\\"undefined\\\"||!(e.name===\\\"ErrnoError\\\"))throw e;return-e.errno}}Module[\\\"___syscall_fcntl64\\\"]=___syscall_fcntl64;function ___syscall_ioctl(fd,op,varargs){if(ENVIRONMENT_IS_PTHREAD)return proxyToMainThread(4,0,1,fd,op,varargs);varargs>>>=0;SYSCALLS.varargs=varargs;try{var stream=SYSCALLS.getStreamFromFD(fd);switch(op){case 21509:{if(!stream.tty)return-59;return 0}case 21505:{if(!stream.tty)return-59;if(stream.tty.ops.ioctl_tcgets){var termios=stream.tty.ops.ioctl_tcgets(stream);var argp=syscallGetVarargP();GROWABLE_HEAP_I32()[argp>>>2>>>0]=termios.c_iflag||0;GROWABLE_HEAP_I32()[argp+4>>>2>>>0]=termios.c_oflag||0;GROWABLE_HEAP_I32()[argp+8>>>2>>>0]=termios.c_cflag||0;GROWABLE_HEAP_I32()[argp+12>>>2>>>0]=termios.c_lflag||0;for(var i=0;i<32;i++){GROWABLE_HEAP_I8()[argp+i+17>>>0]=termios.c_cc[i]||0}return 0}return 0}case 21510:case 21511:case 21512:{if(!stream.tty)return-59;return 0}case 21506:case 21507:case 21508:{if(!stream.tty)return-59;if(stream.tty.ops.ioctl_tcsets){var argp=syscallGetVarargP();var c_iflag=GROWABLE_HEAP_I32()[argp>>>2>>>0];var c_oflag=GROWABLE_HEAP_I32()[argp+4>>>2>>>0];var c_cflag=GROWABLE_HEAP_I32()[argp+8>>>2>>>0];var c_lflag=GROWABLE_HEAP_I32()[argp+12>>>2>>>0];var c_cc=[];for(var i=0;i<32;i++){c_cc.push(GROWABLE_HEAP_I8()[argp+i+17>>>0])}return stream.tty.ops.ioctl_tcsets(stream.tty,op,{c_iflag,c_oflag,c_cflag,c_lflag,c_cc})}return 0}case 21519:{if(!stream.tty)return-59;var argp=syscallGetVarargP();GROWABLE_HEAP_I32()[argp>>>2>>>0]=0;return 0}case 21520:{if(!stream.tty)return-59;return-28}case 21531:{var argp=syscallGetVarargP();return FS.ioctl(stream,op,argp)}case 21523:{if(!stream.tty)return-59;if(stream.tty.ops.ioctl_tiocgwinsz){var winsize=stream.tty.ops.ioctl_tiocgwinsz(stream.tty);var argp=syscallGetVarargP();GROWABLE_HEAP_I16()[argp>>>1>>>0]=winsize[0];GROWABLE_HEAP_I16()[argp+2>>>1>>>0]=winsize[1]}return 0}case 21524:{if(!stream.tty)return-59;return 0}case 21515:{if(!stream.tty)return-59;return 0}default:return-28}}catch(e){if(typeof FS==\\\"undefined\\\"||!(e.name===\\\"ErrnoError\\\"))throw e;return-e.errno}}Module[\\\"___syscall_ioctl\\\"]=___syscall_ioctl;function ___syscall_openat(dirfd,path,flags,varargs){if(ENVIRONMENT_IS_PTHREAD)return proxyToMainThread(5,0,1,dirfd,path,flags,varargs);path>>>=0;varargs>>>=0;SYSCALLS.varargs=varargs;try{path=SYSCALLS.getStr(path);path=SYSCALLS.calculateAt(dirfd,path);var mode=varargs?syscallGetVarargI():0;return FS.open(path,flags,mode).fd}catch(e){if(typeof FS==\\\"undefined\\\"||!(e.name===\\\"ErrnoError\\\"))throw e;return-e.errno}}Module[\\\"___syscall_openat\\\"]=___syscall_openat;var __abort_js=()=>abort(\\\"\\\");Module[\\\"__abort_js\\\"]=__abort_js;function __emscripten_init_main_thread_js(tb){tb>>>=0;__emscripten_thread_init(tb,!ENVIRONMENT_IS_WORKER,1,!ENVIRONMENT_IS_WEB,65536,false);PThread.threadInitTLS()}Module[\\\"__emscripten_init_main_thread_js\\\"]=__emscripten_init_main_thread_js;var maybeExit=()=>{if(!keepRuntimeAlive()){try{if(ENVIRONMENT_IS_PTHREAD)__emscripten_thread_exit(EXITSTATUS);else _exit(EXITSTATUS)}catch(e){handleException(e)}}};Module[\\\"maybeExit\\\"]=maybeExit;var callUserCallback=func=>{if(ABORT){return}try{func();maybeExit()}catch(e){handleException(e)}};Module[\\\"callUserCallback\\\"]=callUserCallback;function __emscripten_thread_mailbox_await(pthread_ptr){pthread_ptr>>>=0;if(typeof Atomics.waitAsync===\\\"function\\\"){var wait=Atomics.waitAsync(GROWABLE_HEAP_I32(),pthread_ptr>>>2,pthread_ptr);wait.value.then(checkMailbox);var waitingAsync=pthread_ptr+128;Atomics.store(GROWABLE_HEAP_I32(),waitingAsync>>>2,1)}}Module[\\\"__emscripten_thread_mailbox_await\\\"]=__emscripten_thread_mailbox_await;var checkMailbox=()=>{var pthread_ptr=_pthread_self();if(pthread_ptr){__emscripten_thread_mailbox_await(pthread_ptr);callUserCallback(__emscripten_check_mailbox)}};Module[\\\"checkMailbox\\\"]=checkMailbox;function __emscripten_notify_mailbox_postmessage(targetThread,currThreadId){targetThread>>>=0;currThreadId>>>=0;if(targetThread==currThreadId){setTimeout(checkMailbox)}else if(ENVIRONMENT_IS_PTHREAD){postMessage({targetThread,cmd:\\\"checkMailbox\\\"})}else{var worker=PThread.pthreads[targetThread];if(!worker){return}worker.postMessage({cmd:\\\"checkMailbox\\\"})}}Module[\\\"__emscripten_notify_mailbox_postmessage\\\"]=__emscripten_notify_mailbox_postmessage;var proxiedJSCallArgs=[];Module[\\\"proxiedJSCallArgs\\\"]=proxiedJSCallArgs;function __emscripten_receive_on_main_thread_js(funcIndex,emAsmAddr,callingThread,numCallArgs,args){emAsmAddr>>>=0;callingThread>>>=0;args>>>=0;numCallArgs/=2;proxiedJSCallArgs.length=numCallArgs;var b=args>>>3;for(var i=0;i<numCallArgs;i++){if(HEAP64[b+2*i]){proxiedJSCallArgs[i]=HEAP64[b+2*i+1]}else{proxiedJSCallArgs[i]=GROWABLE_HEAP_F64()[b+2*i+1>>>0]}}var func=proxiedFunctionTable[funcIndex];PThread.currentProxiedOperationCallerThread=callingThread;var rtn=func(...proxiedJSCallArgs);PThread.currentProxiedOperationCallerThread=0;return rtn}Module[\\\"__emscripten_receive_on_main_thread_js\\\"]=__emscripten_receive_on_main_thread_js;var __emscripten_runtime_keepalive_clear=()=>{noExitRuntime=false;runtimeKeepaliveCounter=0};Module[\\\"__emscripten_runtime_keepalive_clear\\\"]=__emscripten_runtime_keepalive_clear;function __emscripten_thread_cleanup(thread){thread>>>=0;if(!ENVIRONMENT_IS_PTHREAD)cleanupThread(thread);else postMessage({cmd:\\\"cleanupThread\\\",thread})}Module[\\\"__emscripten_thread_cleanup\\\"]=__emscripten_thread_cleanup;function __emscripten_thread_set_strongref(thread){thread>>>=0;if(ENVIRONMENT_IS_NODE){PThread.pthreads[thread].ref()}}Module[\\\"__emscripten_thread_set_strongref\\\"]=__emscripten_thread_set_strongref;function __mmap_js(len,prot,flags,fd,offset,allocated,addr){if(ENVIRONMENT_IS_PTHREAD)return proxyToMainThread(6,0,1,len,prot,flags,fd,offset,allocated,addr);len>>>=0;offset=bigintToI53Checked(offset);allocated>>>=0;addr>>>=0;try{if(isNaN(offset))return 61;var stream=SYSCALLS.getStreamFromFD(fd);var res=FS.mmap(stream,len,offset,prot,flags);var ptr=res.ptr;GROWABLE_HEAP_I32()[allocated>>>2>>>0]=res.allocated;GROWABLE_HEAP_U32()[addr>>>2>>>0]=ptr;return 0}catch(e){if(typeof FS==\\\"undefined\\\"||!(e.name===\\\"ErrnoError\\\"))throw e;return-e.errno}}Module[\\\"__mmap_js\\\"]=__mmap_js;function __munmap_js(addr,len,prot,flags,fd,offset){if(ENVIRONMENT_IS_PTHREAD)return proxyToMainThread(7,0,1,addr,len,prot,flags,fd,offset);addr>>>=0;len>>>=0;offset=bigintToI53Checked(offset);try{var stream=SYSCALLS.getStreamFromFD(fd);if(prot&2){SYSCALLS.doMsync(addr,stream,len,flags,offset)}}catch(e){if(typeof FS==\\\"undefined\\\"||!(e.name===\\\"ErrnoError\\\"))throw e;return-e.errno}}Module[\\\"__munmap_js\\\"]=__munmap_js;var timers={};Module[\\\"timers\\\"]=timers;var _emscripten_get_now=()=>performance.timeOrigin+performance.now();Module[\\\"_emscripten_get_now\\\"]=_emscripten_get_now;function __setitimer_js(which,timeout_ms){if(ENVIRONMENT_IS_PTHREAD)return proxyToMainThread(8,0,1,which,timeout_ms);if(timers[which]){clearTimeout(timers[which].id);delete timers[which]}if(!timeout_ms)return 0;var id=setTimeout(()=>{delete timers[which];callUserCallback(()=>__emscripten_timeout(which,_emscripten_get_now()))},timeout_ms);timers[which]={id,timeout_ms};return 0}Module[\\\"__setitimer_js\\\"]=__setitimer_js;var stringToUTF8=(str,outPtr,maxBytesToWrite)=>stringToUTF8Array(str,GROWABLE_HEAP_U8(),outPtr,maxBytesToWrite);Module[\\\"stringToUTF8\\\"]=stringToUTF8;var __tzset_js=function(timezone,daylight,std_name,dst_name){timezone>>>=0;daylight>>>=0;std_name>>>=0;dst_name>>>=0;var currentYear=(new Date).getFullYear();var winter=new Date(currentYear,0,1);var summer=new Date(currentYear,6,1);var winterOffset=winter.getTimezoneOffset();var summerOffset=summer.getTimezoneOffset();var stdTimezoneOffset=Math.max(winterOffset,summerOffset);GROWABLE_HEAP_U32()[timezone>>>2>>>0]=stdTimezoneOffset*60;GROWABLE_HEAP_I32()[daylight>>>2>>>0]=Number(winterOffset!=summerOffset);var extractZone=timezoneOffset=>{var sign=timezoneOffset>=0?\\\"-\\\":\\\"+\\\";var absOffset=Math.abs(timezoneOffset);var hours=String(Math.floor(absOffset/60)).padStart(2,\\\"0\\\");var minutes=String(absOffset%60).padStart(2,\\\"0\\\");return`UTC${sign}${hours}${minutes}`};var winterName=extractZone(winterOffset);var summerName=extractZone(summerOffset);if(summerOffset<winterOffset){stringToUTF8(winterName,std_name,17);stringToUTF8(summerName,dst_name,17)}else{stringToUTF8(winterName,dst_name,17);stringToUTF8(summerName,std_name,17)}};Module[\\\"__tzset_js\\\"]=__tzset_js;var _emscripten_date_now=()=>Date.now();Module[\\\"_emscripten_date_now\\\"]=_emscripten_date_now;var nowIsMonotonic=1;Module[\\\"nowIsMonotonic\\\"]=nowIsMonotonic;var checkWasiClock=clock_id=>clock_id>=0&&clock_id<=3;Module[\\\"checkWasiClock\\\"]=checkWasiClock;function _clock_time_get(clk_id,ignored_precision,ptime){ignored_precision=bigintToI53Checked(ignored_precision);ptime>>>=0;if(!checkWasiClock(clk_id)){return 28}var now;if(clk_id===0){now=_emscripten_date_now()}else if(nowIsMonotonic){now=_emscripten_get_now()}else{return 52}var nsec=Math.round(now*1e3*1e3);HEAP64[ptime>>>3]=BigInt(nsec);return 0}Module[\\\"_clock_time_get\\\"]=_clock_time_get;var warnOnce=text=>{warnOnce.shown||={};if(!warnOnce.shown[text]){warnOnce.shown[text]=1;if(ENVIRONMENT_IS_NODE)text=\\\"warning: \\\"+text;err(text)}};Module[\\\"warnOnce\\\"]=warnOnce;var _emscripten_check_blocking_allowed=()=>{};Module[\\\"_emscripten_check_blocking_allowed\\\"]=_emscripten_check_blocking_allowed;var runtimeKeepalivePush=()=>{runtimeKeepaliveCounter+=1};Module[\\\"runtimeKeepalivePush\\\"]=runtimeKeepalivePush;var _emscripten_exit_with_live_runtime=()=>{runtimeKeepalivePush();throw\\\"unwind\\\"};Module[\\\"_emscripten_exit_with_live_runtime\\\"]=_emscripten_exit_with_live_runtime;var getHeapMax=()=>4294901760;Module[\\\"getHeapMax\\\"]=getHeapMax;function _emscripten_get_heap_max(){return getHeapMax()}Module[\\\"_emscripten_get_heap_max\\\"]=_emscripten_get_heap_max;var _emscripten_num_logical_cores=()=>ENVIRONMENT_IS_NODE?require(\\\"os\\\").cpus().length:navigator[\\\"hardwareConcurrency\\\"];Module[\\\"_emscripten_num_logical_cores\\\"]=_emscripten_num_logical_cores;var growMemory=size=>{var b=wasmMemory.buffer;var pages=(size-b.byteLength+65535)/65536|0;try{wasmMemory.grow(pages);updateMemoryViews();return 1}catch(e){}};Module[\\\"growMemory\\\"]=growMemory;function _emscripten_resize_heap(requestedSize){requestedSize>>>=0;var oldSize=GROWABLE_HEAP_U8().length;if(requestedSize<=oldSize){return false}var maxHeapSize=getHeapMax();if(requestedSize>maxHeapSize){return false}for(var cutDown=1;cutDown<=4;cutDown*=2){var overGrownHeapSize=oldSize*(1+.2/cutDown);overGrownHeapSize=Math.min(overGrownHeapSize,requestedSize+100663296);var newSize=Math.min(maxHeapSize,alignMemory(Math.max(requestedSize,overGrownHeapSize),65536));var replacement=growMemory(newSize);if(replacement){return true}}return false}Module[\\\"_emscripten_resize_heap\\\"]=_emscripten_resize_heap;var ENV={};Module[\\\"ENV\\\"]=ENV;var getExecutableName=()=>thisProgram||\\\"./this.program\\\";Module[\\\"getExecutableName\\\"]=getExecutableName;var getEnvStrings=()=>{if(!getEnvStrings.strings){var lang=(typeof navigator==\\\"object\\\"&&navigator.languages&&navigator.languages[0]||\\\"C\\\").replace(\\\"-\\\",\\\"_\\\")+\\\".UTF-8\\\";var env={USER:\\\"web_user\\\",LOGNAME:\\\"web_user\\\",PATH:\\\"/\\\",PWD:\\\"/\\\",HOME:\\\"/home/web_user\\\",LANG:lang,_:getExecutableName()};for(var x in ENV){if(ENV[x]===undefined)delete env[x];else env[x]=ENV[x]}var strings=[];for(var x in env){strings.push(`${x}=${env[x]}`)}getEnvStrings.strings=strings}return getEnvStrings.strings};Module[\\\"getEnvStrings\\\"]=getEnvStrings;var stringToAscii=(str,buffer)=>{for(var i=0;i<str.length;++i){GROWABLE_HEAP_I8()[buffer++>>>0]=str.charCodeAt(i)}GROWABLE_HEAP_I8()[buffer>>>0]=0};Module[\\\"stringToAscii\\\"]=stringToAscii;var _environ_get=function(__environ,environ_buf){if(ENVIRONMENT_IS_PTHREAD)return proxyToMainThread(9,0,1,__environ,environ_buf);__environ>>>=0;environ_buf>>>=0;var bufSize=0;getEnvStrings().forEach((string,i)=>{var ptr=environ_buf+bufSize;GROWABLE_HEAP_U32()[__environ+i*4>>>2>>>0]=ptr;stringToAscii(string,ptr);bufSize+=string.length+1});return 0};Module[\\\"_environ_get\\\"]=_environ_get;var _environ_sizes_get=function(penviron_count,penviron_buf_size){if(ENVIRONMENT_IS_PTHREAD)return proxyToMainThread(10,0,1,penviron_count,penviron_buf_size);penviron_count>>>=0;penviron_buf_size>>>=0;var strings=getEnvStrings();GROWABLE_HEAP_U32()[penviron_count>>>2>>>0]=strings.length;var bufSize=0;strings.forEach(string=>bufSize+=string.length+1);GROWABLE_HEAP_U32()[penviron_buf_size>>>2>>>0]=bufSize;return 0};Module[\\\"_environ_sizes_get\\\"]=_environ_sizes_get;function _fd_close(fd){if(ENVIRONMENT_IS_PTHREAD)return proxyToMainThread(11,0,1,fd);try{var stream=SYSCALLS.getStreamFromFD(fd);FS.close(stream);return 0}catch(e){if(typeof FS==\\\"undefined\\\"||!(e.name===\\\"ErrnoError\\\"))throw e;return e.errno}}Module[\\\"_fd_close\\\"]=_fd_close;var doReadv=(stream,iov,iovcnt,offset)=>{var ret=0;for(var i=0;i<iovcnt;i++){var ptr=GROWABLE_HEAP_U32()[iov>>>2>>>0];var len=GROWABLE_HEAP_U32()[iov+4>>>2>>>0];iov+=8;var curr=FS.read(stream,GROWABLE_HEAP_I8(),ptr,len,offset);if(curr<0)return-1;ret+=curr;if(curr<len)break;if(typeof offset!=\\\"undefined\\\"){offset+=curr}}return ret};Module[\\\"doReadv\\\"]=doReadv;function _fd_read(fd,iov,iovcnt,pnum){if(ENVIRONMENT_IS_PTHREAD)return proxyToMainThread(12,0,1,fd,iov,iovcnt,pnum);iov>>>=0;iovcnt>>>=0;pnum>>>=0;try{var stream=SYSCALLS.getStreamFromFD(fd);var num=doReadv(stream,iov,iovcnt);GROWABLE_HEAP_U32()[pnum>>>2>>>0]=num;return 0}catch(e){if(typeof FS==\\\"undefined\\\"||!(e.name===\\\"ErrnoError\\\"))throw e;return e.errno}}Module[\\\"_fd_read\\\"]=_fd_read;function _fd_seek(fd,offset,whence,newOffset){if(ENVIRONMENT_IS_PTHREAD)return proxyToMainThread(13,0,1,fd,offset,whence,newOffset);offset=bigintToI53Checked(offset);newOffset>>>=0;try{if(isNaN(offset))return 61;var stream=SYSCALLS.getStreamFromFD(fd);FS.llseek(stream,offset,whence);HEAP64[newOffset>>>3]=BigInt(stream.position);if(stream.getdents&&offset===0&&whence===0)stream.getdents=null;return 0}catch(e){if(typeof FS==\\\"undefined\\\"||!(e.name===\\\"ErrnoError\\\"))throw e;return e.errno}}Module[\\\"_fd_seek\\\"]=_fd_seek;var doWritev=(stream,iov,iovcnt,offset)=>{var ret=0;for(var i=0;i<iovcnt;i++){var ptr=GROWABLE_HEAP_U32()[iov>>>2>>>0];var len=GROWABLE_HEAP_U32()[iov+4>>>2>>>0];iov+=8;var curr=FS.write(stream,GROWABLE_HEAP_I8(),ptr,len,offset);if(curr<0)return-1;ret+=curr;if(curr<len){break}if(typeof offset!=\\\"undefined\\\"){offset+=curr}}return ret};Module[\\\"doWritev\\\"]=doWritev;function _fd_write(fd,iov,iovcnt,pnum){if(ENVIRONMENT_IS_PTHREAD)return proxyToMainThread(14,0,1,fd,iov,iovcnt,pnum);iov>>>=0;iovcnt>>>=0;pnum>>>=0;try{var stream=SYSCALLS.getStreamFromFD(fd);var num=doWritev(stream,iov,iovcnt);GROWABLE_HEAP_U32()[pnum>>>2>>>0]=num;return 0}catch(e){if(typeof FS==\\\"undefined\\\"||!(e.name===\\\"ErrnoError\\\"))throw e;return e.errno}}Module[\\\"_fd_write\\\"]=_fd_write;function _random_get(buffer,size){buffer>>>=0;size>>>=0;try{randomFill(GROWABLE_HEAP_U8().subarray(buffer>>>0,buffer+size>>>0));return 0}catch(e){if(typeof FS==\\\"undefined\\\"||!(e.name===\\\"ErrnoError\\\"))throw e;return e.errno}}Module[\\\"_random_get\\\"]=_random_get;var getCFunc=ident=>{var func=Module[\\\"_\\\"+ident];return func};Module[\\\"getCFunc\\\"]=getCFunc;var writeArrayToMemory=(array,buffer)=>{GROWABLE_HEAP_I8().set(array,buffer>>>0)};Module[\\\"writeArrayToMemory\\\"]=writeArrayToMemory;var stringToUTF8OnStack=str=>{var size=lengthBytesUTF8(str)+1;var ret=stackAlloc(size);stringToUTF8(str,ret,size);return ret};Module[\\\"stringToUTF8OnStack\\\"]=stringToUTF8OnStack;var ccall=(ident,returnType,argTypes,args,opts)=>{var toC={string:str=>{var ret=0;if(str!==null&&str!==undefined&&str!==0){ret=stringToUTF8OnStack(str)}return ret},array:arr=>{var ret=stackAlloc(arr.length);writeArrayToMemory(arr,ret);return ret}};function convertReturnValue(ret){if(returnType===\\\"string\\\"){return UTF8ToString(ret)}if(returnType===\\\"boolean\\\")return Boolean(ret);return ret}var func=getCFunc(ident);var cArgs=[];var stack=0;if(args){for(var i=0;i<args.length;i++){var converter=toC[argTypes[i]];if(converter){if(stack===0)stack=stackSave();cArgs[i]=converter(args[i])}else{cArgs[i]=args[i]}}}var ret=func(...cArgs);function onDone(ret){if(stack!==0)stackRestore(stack);return convertReturnValue(ret)}ret=onDone(ret);return ret};Module[\\\"ccall\\\"]=ccall;var cwrap=(ident,returnType,argTypes,opts)=>{var numericArgs=!argTypes||argTypes.every(type=>type===\\\"number\\\"||type===\\\"boolean\\\");var numericRet=returnType!==\\\"string\\\";if(numericRet&&numericArgs&&!opts){return getCFunc(ident)}return(...args)=>ccall(ident,returnType,argTypes,args,opts)};Module[\\\"cwrap\\\"]=cwrap;var FS_createPath=FS.createPath;Module[\\\"FS_createPath\\\"]=FS_createPath;var FS_unlink=path=>FS.unlink(path);Module[\\\"FS_unlink\\\"]=FS_unlink;var FS_createLazyFile=FS.createLazyFile;Module[\\\"FS_createLazyFile\\\"]=FS_createLazyFile;var FS_createDevice=FS.createDevice;Module[\\\"FS_createDevice\\\"]=FS_createDevice;PThread.init();FS.createPreloadedFile=FS_createPreloadedFile;FS.staticInit();Module[\\\"FS_createPath\\\"]=FS.createPath;Module[\\\"FS_createDataFile\\\"]=FS.createDataFile;Module[\\\"FS_createPreloadedFile\\\"]=FS.createPreloadedFile;Module[\\\"FS_unlink\\\"]=FS.unlink;Module[\\\"FS_createLazyFile\\\"]=FS.createLazyFile;Module[\\\"FS_createDevice\\\"]=FS.createDevice;MEMFS.doesNotExistError=new FS.ErrnoError(44);MEMFS.doesNotExistError.stack=\\\"<generic error, no stack>\\\";var proxiedFunctionTable=[_proc_exit,exitOnMainThread,pthreadCreateProxied,___syscall_fcntl64,___syscall_ioctl,___syscall_openat,__mmap_js,__munmap_js,__setitimer_js,_environ_get,_environ_sizes_get,_fd_close,_fd_read,_fd_seek,_fd_write];var wasmImports;function assignWasmImports(){wasmImports={u:___pthread_create_js,c:___syscall_fcntl64,h:___syscall_ioctl,i:___syscall_openat,H:__abort_js,C:__emscripten_init_main_thread_js,q:__emscripten_notify_mailbox_postmessage,v:__emscripten_receive_on_main_thread_js,l:__emscripten_runtime_keepalive_clear,d:__emscripten_thread_cleanup,B:__emscripten_thread_mailbox_await,n:__emscripten_thread_set_strongref,x:__mmap_js,y:__munmap_js,m:__setitimer_js,z:__tzset_js,G:_clock_time_get,e:_emscripten_check_blocking_allowed,w:_emscripten_date_now,j:_emscripten_exit_with_live_runtime,r:_emscripten_get_heap_max,b:_emscripten_get_now,s:_emscripten_num_logical_cores,p:_emscripten_resize_heap,D:_environ_get,E:_environ_sizes_get,t:_exit,f:_fd_close,g:_fd_read,A:_fd_seek,F:_fd_write,a:wasmMemory,k:_proc_exit,o:_random_get}}var wasmExports;createWasm();var ___wasm_call_ctors=()=>(___wasm_call_ctors=wasmExports[\\\"I\\\"])();var _wllama_malloc=Module[\\\"_wllama_malloc\\\"]=(a0,a1)=>(_wllama_malloc=Module[\\\"_wllama_malloc\\\"]=wasmExports[\\\"J\\\"])(a0,a1);var _wllama_start=Module[\\\"_wllama_start\\\"]=()=>(_wllama_start=Module[\\\"_wllama_start\\\"]=wasmExports[\\\"K\\\"])();var _wllama_action=Module[\\\"_wllama_action\\\"]=(a0,a1)=>(_wllama_action=Module[\\\"_wllama_action\\\"]=wasmExports[\\\"L\\\"])(a0,a1);var _wllama_exit=Module[\\\"_wllama_exit\\\"]=()=>(_wllama_exit=Module[\\\"_wllama_exit\\\"]=wasmExports[\\\"M\\\"])();var _wllama_debug=Module[\\\"_wllama_debug\\\"]=()=>(_wllama_debug=Module[\\\"_wllama_debug\\\"]=wasmExports[\\\"N\\\"])();var _main=Module[\\\"_main\\\"]=(a0,a1)=>(_main=Module[\\\"_main\\\"]=wasmExports[\\\"O\\\"])(a0,a1);var __emscripten_tls_init=()=>(__emscripten_tls_init=wasmExports[\\\"P\\\"])();var _pthread_self=()=>(_pthread_self=wasmExports[\\\"Q\\\"])();var _emscripten_builtin_memalign=(a0,a1)=>(_emscripten_builtin_memalign=wasmExports[\\\"R\\\"])(a0,a1);var __emscripten_thread_init=(a0,a1,a2,a3,a4,a5)=>(__emscripten_thread_init=wasmExports[\\\"T\\\"])(a0,a1,a2,a3,a4,a5);var __emscripten_thread_crashed=()=>(__emscripten_thread_crashed=wasmExports[\\\"U\\\"])();var __emscripten_run_on_main_thread_js=(a0,a1,a2,a3,a4)=>(__emscripten_run_on_main_thread_js=wasmExports[\\\"V\\\"])(a0,a1,a2,a3,a4);var __emscripten_thread_free_data=a0=>(__emscripten_thread_free_data=wasmExports[\\\"W\\\"])(a0);var __emscripten_thread_exit=a0=>(__emscripten_thread_exit=wasmExports[\\\"X\\\"])(a0);var __emscripten_timeout=(a0,a1)=>(__emscripten_timeout=wasmExports[\\\"Y\\\"])(a0,a1);var __emscripten_check_mailbox=()=>(__emscripten_check_mailbox=wasmExports[\\\"Z\\\"])();var ___trap=()=>(___trap=wasmExports[\\\"_\\\"])();var _emscripten_stack_set_limits=(a0,a1)=>(_emscripten_stack_set_limits=wasmExports[\\\"$\\\"])(a0,a1);var __emscripten_stack_restore=a0=>(__emscripten_stack_restore=wasmExports[\\\"aa\\\"])(a0);var __emscripten_stack_alloc=a0=>(__emscripten_stack_alloc=wasmExports[\\\"ba\\\"])(a0);var _emscripten_stack_get_current=()=>(_emscripten_stack_get_current=wasmExports[\\\"ca\\\"])();function applySignatureConversions(wasmExports){wasmExports=Object.assign({},wasmExports);var makeWrapper_p=f=>()=>f()>>>0;var makeWrapper_ppp=f=>(a0,a1)=>f(a0,a1)>>>0;var makeWrapper_pp=f=>a0=>f(a0)>>>0;wasmExports[\\\"Q\\\"]=makeWrapper_p(wasmExports[\\\"Q\\\"]);wasmExports[\\\"R\\\"]=makeWrapper_ppp(wasmExports[\\\"R\\\"]);wasmExports[\\\"ba\\\"]=makeWrapper_pp(wasmExports[\\\"ba\\\"]);wasmExports[\\\"ca\\\"]=makeWrapper_p(wasmExports[\\\"ca\\\"]);return wasmExports}Module[\\\"addRunDependency\\\"]=addRunDependency;Module[\\\"removeRunDependency\\\"]=removeRunDependency;Module[\\\"ccall\\\"]=ccall;Module[\\\"cwrap\\\"]=cwrap;Module[\\\"FS_createPreloadedFile\\\"]=FS_createPreloadedFile;Module[\\\"FS_unlink\\\"]=FS_unlink;Module[\\\"FS_createPath\\\"]=FS_createPath;Module[\\\"FS_createDevice\\\"]=FS_createDevice;Module[\\\"FS_createDataFile\\\"]=FS_createDataFile;Module[\\\"FS_createLazyFile\\\"]=FS_createLazyFile;function callMain(){var entryFunction=_main;var argc=0;var argv=0;try{var ret=entryFunction(argc,argv);exitJS(ret,true);return ret}catch(e){return handleException(e)}}function run(){if(runDependencies>0){dependenciesFulfilled=run;return}if(ENVIRONMENT_IS_PTHREAD){initRuntime();return}preRun();if(runDependencies>0){dependenciesFulfilled=run;return}function doRun(){Module[\\\"calledRun\\\"]=true;if(ABORT)return;initRuntime();preMain();Module[\\\"onRuntimeInitialized\\\"]?.();var noInitialRun=Module[\\\"noInitialRun\\\"];if(!noInitialRun)callMain();postRun()}if(Module[\\\"setStatus\\\"]){Module[\\\"setStatus\\\"](\\\"Running...\\\");setTimeout(()=>{setTimeout(()=>Module[\\\"setStatus\\\"](\\\"\\\"),1);doRun()},1)}else{doRun()}}if(Module[\\\"preInit\\\"]){if(typeof Module[\\\"preInit\\\"]==\\\"function\\\")Module[\\\"preInit\\\"]=[Module[\\\"preInit\\\"]];while(Module[\\\"preInit\\\"].length>0){Module[\\\"preInit\\\"].pop()()}}run();\\n\";\n\nexport const WLLAMA_SINGLE_THREAD_CODE = \"var Module=typeof Module!=\\\"undefined\\\"?Module:{};var ENVIRONMENT_IS_WEB=typeof window==\\\"object\\\";var ENVIRONMENT_IS_WORKER=typeof WorkerGlobalScope!=\\\"undefined\\\";var ENVIRONMENT_IS_NODE=typeof process==\\\"object\\\"&&typeof process.versions==\\\"object\\\"&&typeof process.versions.node==\\\"string\\\"&&process.type!=\\\"renderer\\\";if(ENVIRONMENT_IS_NODE){}var moduleOverrides=Object.assign({},Module);var arguments_=[];var thisProgram=\\\"./this.program\\\";var quit_=(status,toThrow)=>{throw toThrow};var scriptDirectory=\\\"\\\";function locateFile(path){if(Module[\\\"locateFile\\\"]){return Module[\\\"locateFile\\\"](path,scriptDirectory)}return scriptDirectory+path}var readAsync,readBinary;if(ENVIRONMENT_IS_NODE){var fs=require(\\\"fs\\\");var nodePath=require(\\\"path\\\");scriptDirectory=__dirname+\\\"/\\\";readBinary=filename=>{filename=isFileURI(filename)?new URL(filename):filename;var ret=fs.readFileSync(filename);return ret};readAsync=async(filename,binary=true)=>{filename=isFileURI(filename)?new URL(filename):filename;var ret=fs.readFileSync(filename,binary?undefined:\\\"utf8\\\");return ret};if(!Module[\\\"thisProgram\\\"]&&process.argv.length>1){thisProgram=process.argv[1].replace(/\\\\\\\\/g,\\\"/\\\")}arguments_=process.argv.slice(2);if(typeof module!=\\\"undefined\\\"){module[\\\"exports\\\"]=Module}quit_=(status,toThrow)=>{process.exitCode=status;throw toThrow}}else if(ENVIRONMENT_IS_WEB||ENVIRONMENT_IS_WORKER){if(ENVIRONMENT_IS_WORKER){scriptDirectory=self.location.href}else if(typeof document!=\\\"undefined\\\"&&document.currentScript){scriptDirectory=document.currentScript.src}if(scriptDirectory.startsWith(\\\"blob:\\\")){scriptDirectory=\\\"\\\"}else{scriptDirectory=scriptDirectory.slice(0,scriptDirectory.replace(/[?#].*/,\\\"\\\").lastIndexOf(\\\"/\\\")+1)}{if(ENVIRONMENT_IS_WORKER){readBinary=url=>{var xhr=new XMLHttpRequest;xhr.open(\\\"GET\\\",url,false);xhr.responseType=\\\"arraybuffer\\\";xhr.send(null);return new Uint8Array(xhr.response)}}readAsync=async url=>{if(isFileURI(url)){return new Promise((resolve,reject)=>{var xhr=new XMLHttpRequest;xhr.open(\\\"GET\\\",url,true);xhr.responseType=\\\"arraybuffer\\\";xhr.onload=()=>{if(xhr.status==200||xhr.status==0&&xhr.response){resolve(xhr.response);return}reject(xhr.status)};xhr.onerror=reject;xhr.send(null)})}var response=await fetch(url,{credentials:\\\"same-origin\\\"});if(response.ok){return response.arrayBuffer()}throw new Error(response.status+\\\" : \\\"+response.url)}}}else{}var out=Module[\\\"print\\\"]||console.log.bind(console);var err=Module[\\\"printErr\\\"]||console.error.bind(console);Object.assign(Module,moduleOverrides);moduleOverrides=null;if(Module[\\\"arguments\\\"])arguments_=Module[\\\"arguments\\\"];if(Module[\\\"thisProgram\\\"])thisProgram=Module[\\\"thisProgram\\\"];var wasmBinary=Module[\\\"wasmBinary\\\"];var wasmMemory;var ABORT=false;var EXITSTATUS;var HEAP8,HEAPU8,HEAP16,HEAPU16,HEAP32,HEAPU32,HEAPF32,HEAP64,HEAPU64,HEAPF64;var runtimeInitialized=false;var isFileURI=filename=>filename.startsWith(\\\"file://\\\");function updateMemoryViews(){var b=wasmMemory.buffer;Module[\\\"HEAP8\\\"]=HEAP8=new Int8Array(b);Module[\\\"HEAP16\\\"]=HEAP16=new Int16Array(b);Module[\\\"HEAPU8\\\"]=HEAPU8=new Uint8Array(b);Module[\\\"HEAPU16\\\"]=HEAPU16=new Uint16Array(b);Module[\\\"HEAP32\\\"]=HEAP32=new Int32Array(b);Module[\\\"HEAPU32\\\"]=HEAPU32=new Uint32Array(b);Module[\\\"HEAPF32\\\"]=HEAPF32=new Float32Array(b);Module[\\\"HEAPF64\\\"]=HEAPF64=new Float64Array(b);Module[\\\"HEAP64\\\"]=HEAP64=new BigInt64Array(b);Module[\\\"HEAPU64\\\"]=HEAPU64=new BigUint64Array(b)}function preRun(){if(Module[\\\"preRun\\\"]){if(typeof Module[\\\"preRun\\\"]==\\\"function\\\")Module[\\\"preRun\\\"]=[Module[\\\"preRun\\\"]];while(Module[\\\"preRun\\\"].length){addOnPreRun(Module[\\\"preRun\\\"].shift())}}callRuntimeCallbacks(onPreRuns)}function initRuntime(){runtimeInitialized=true;if(!Module[\\\"noFSInit\\\"]&&!FS.initialized)FS.init();TTY.init();wasmExports[\\\"w\\\"]();FS.ignorePermissions=false}function preMain(){}function postRun(){if(Module[\\\"postRun\\\"]){if(typeof Module[\\\"postRun\\\"]==\\\"function\\\")Module[\\\"postRun\\\"]=[Module[\\\"postRun\\\"]];while(Module[\\\"postRun\\\"].length){addOnPostRun(Module[\\\"postRun\\\"].shift())}}callRuntimeCallbacks(onPostRuns)}var runDependencies=0;var dependenciesFulfilled=null;function getUniqueRunDependency(id){return id}function addRunDependency(id){runDependencies++;Module[\\\"monitorRunDependencies\\\"]?.(runDependencies)}function removeRunDependency(id){runDependencies--;Module[\\\"monitorRunDependencies\\\"]?.(runDependencies);if(runDependencies==0){if(dependenciesFulfilled){var callback=dependenciesFulfilled;dependenciesFulfilled=null;callback()}}}function abort(what){Module[\\\"onAbort\\\"]?.(what);what=\\\"Aborted(\\\"+what+\\\")\\\";err(what);ABORT=true;what+=\\\". Build with -sASSERTIONS for more info.\\\";if(runtimeInitialized){___trap()}var e=new WebAssembly.RuntimeError(what);throw e}var wasmBinaryFile;function findWasmBinary(){return locateFile(\\\"wllama.wasm\\\")}function getBinarySync(file){if(file==wasmBinaryFile&&wasmBinary){return new Uint8Array(wasmBinary)}if(readBinary){return readBinary(file)}throw\\\"both async and sync fetching of the wasm failed\\\"}async function getWasmBinary(binaryFile){if(!wasmBinary){try{var response=await readAsync(binaryFile);return new Uint8Array(response)}catch{}}return getBinarySync(binaryFile)}async function instantiateArrayBuffer(binaryFile,imports){try{var binary=await getWasmBinary(binaryFile);var instance=await WebAssembly.instantiate(binary,imports);return instance}catch(reason){err(`failed to asynchronously prepare wasm: ${reason}`);abort(reason)}}async function instantiateAsync(binary,binaryFile,imports){if(!binary&&typeof WebAssembly.instantiateStreaming==\\\"function\\\"&&!isFileURI(binaryFile)&&!ENVIRONMENT_IS_NODE){try{var response=fetch(binaryFile,{credentials:\\\"same-origin\\\"});var instantiationResult=await WebAssembly.instantiateStreaming(response,imports);return instantiationResult}catch(reason){err(`wasm streaming compile failed: ${reason}`);err(\\\"falling back to ArrayBuffer instantiation\\\")}}return instantiateArrayBuffer(binaryFile,imports)}function getWasmImports(){return{a:wasmImports}}async function createWasm(){function receiveInstance(instance,module){wasmExports=instance.exports;wasmExports=applySignatureConversions(wasmExports);wasmMemory=wasmExports[\\\"v\\\"];updateMemoryViews();removeRunDependency(\\\"wasm-instantiate\\\");return wasmExports}addRunDependency(\\\"wasm-instantiate\\\");function receiveInstantiationResult(result){return receiveInstance(result[\\\"instance\\\"])}var info=getWasmImports();if(Module[\\\"instantiateWasm\\\"]){return new Promise((resolve,reject)=>{Module[\\\"instantiateWasm\\\"](info,(mod,inst)=>{receiveInstance(mod,inst);resolve(mod.exports)})})}wasmBinaryFile??=findWasmBinary();var result=await instantiateAsync(wasmBinary,wasmBinaryFile,info);var exports=receiveInstantiationResult(result);return exports}class ExitStatus{name=\\\"ExitStatus\\\";constructor(status){this.message=`Program terminated with exit(${status})`;this.status=status}}Module[\\\"ExitStatus\\\"]=ExitStatus;var callRuntimeCallbacks=callbacks=>{while(callbacks.length>0){callbacks.shift()(Module)}};Module[\\\"callRuntimeCallbacks\\\"]=callRuntimeCallbacks;var onPostRuns=[];Module[\\\"onPostRuns\\\"]=onPostRuns;var addOnPostRun=cb=>onPostRuns.unshift(cb);Module[\\\"addOnPostRun\\\"]=addOnPostRun;var onPreRuns=[];Module[\\\"onPreRuns\\\"]=onPreRuns;var addOnPreRun=cb=>onPreRuns.unshift(cb);Module[\\\"addOnPreRun\\\"]=addOnPreRun;function getValue(ptr,type=\\\"i8\\\"){if(type.endsWith(\\\"*\\\"))type=\\\"*\\\";switch(type){case\\\"i1\\\":return HEAP8[ptr>>>0];case\\\"i8\\\":return HEAP8[ptr>>>0];case\\\"i16\\\":return HEAP16[ptr>>>1>>>0];case\\\"i32\\\":return HEAP32[ptr>>>2>>>0];case\\\"i64\\\":return HEAP64[ptr>>>3];case\\\"float\\\":return HEAPF32[ptr>>>2>>>0];case\\\"double\\\":return HEAPF64[ptr>>>3>>>0];case\\\"*\\\":return HEAPU32[ptr>>>2>>>0];default:abort(`invalid type for getValue: ${type}`)}}Module[\\\"getValue\\\"]=getValue;var noExitRuntime=Module[\\\"noExitRuntime\\\"]||true;Module[\\\"noExitRuntime\\\"]=noExitRuntime;function setValue(ptr,value,type=\\\"i8\\\"){if(type.endsWith(\\\"*\\\"))type=\\\"*\\\";switch(type){case\\\"i1\\\":HEAP8[ptr>>>0]=value;break;case\\\"i8\\\":HEAP8[ptr>>>0]=value;break;case\\\"i16\\\":HEAP16[ptr>>>1>>>0]=value;break;case\\\"i32\\\":HEAP32[ptr>>>2>>>0]=value;break;case\\\"i64\\\":HEAP64[ptr>>>3]=BigInt(value);break;case\\\"float\\\":HEAPF32[ptr>>>2>>>0]=value;break;case\\\"double\\\":HEAPF64[ptr>>>3>>>0]=value;break;case\\\"*\\\":HEAPU32[ptr>>>2>>>0]=value;break;default:abort(`invalid type for setValue: ${type}`)}}Module[\\\"setValue\\\"]=setValue;var syscallGetVarargI=()=>{var ret=HEAP32[+SYSCALLS.varargs>>>2>>>0];SYSCALLS.varargs+=4;return ret};Module[\\\"syscallGetVarargI\\\"]=syscallGetVarargI;var syscallGetVarargP=syscallGetVarargI;Module[\\\"syscallGetVarargP\\\"]=syscallGetVarargP;var PATH={isAbs:path=>path.charAt(0)===\\\"/\\\",splitPath:filename=>{var splitPathRe=/^(\\\\/?|)([\\\\s\\\\S]*?)((?:\\\\.{1,2}|[^\\\\/]+?|)(\\\\.[^.\\\\/]*|))(?:[\\\\/]*)$/;return splitPathRe.exec(filename).slice(1)},normalizeArray:(parts,allowAboveRoot)=>{var up=0;for(var i=parts.length-1;i>=0;i--){var last=parts[i];if(last===\\\".\\\"){parts.splice(i,1)}else if(last===\\\"..\\\"){parts.splice(i,1);up++}else if(up){parts.splice(i,1);up--}}if(allowAboveRoot){for(;up;up--){parts.unshift(\\\"..\\\")}}return parts},normalize:path=>{var isAbsolute=PATH.isAbs(path),trailingSlash=path.slice(-1)===\\\"/\\\";path=PATH.normalizeArray(path.split(\\\"/\\\").filter(p=>!!p),!isAbsolute).join(\\\"/\\\");if(!path&&!isAbsolute){path=\\\".\\\"}if(path&&trailingSlash){path+=\\\"/\\\"}return(isAbsolute?\\\"/\\\":\\\"\\\")+path},dirname:path=>{var result=PATH.splitPath(path),root=result[0],dir=result[1];if(!root&&!dir){return\\\".\\\"}if(dir){dir=dir.slice(0,-1)}return root+dir},basename:path=>path&&path.match(/([^\\\\/]+|\\\\/)\\\\/*$/)[1],join:(...paths)=>PATH.normalize(paths.join(\\\"/\\\")),join2:(l,r)=>PATH.normalize(l+\\\"/\\\"+r)};Module[\\\"PATH\\\"]=PATH;var initRandomFill=()=>{if(ENVIRONMENT_IS_NODE){var nodeCrypto=require(\\\"crypto\\\");return view=>nodeCrypto.randomFillSync(view)}return view=>crypto.getRandomValues(view)};Module[\\\"initRandomFill\\\"]=initRandomFill;var randomFill=view=>{(randomFill=initRandomFill())(view)};Module[\\\"randomFill\\\"]=randomFill;var PATH_FS={resolve:(...args)=>{var resolvedPath=\\\"\\\",resolvedAbsolute=false;for(var i=args.length-1;i>=-1&&!resolvedAbsolute;i--){var path=i>=0?args[i]:FS.cwd();if(typeof path!=\\\"string\\\"){throw new TypeError(\\\"Arguments to path.resolve must be strings\\\")}else if(!path){return\\\"\\\"}resolvedPath=path+\\\"/\\\"+resolvedPath;resolvedAbsolute=PATH.isAbs(path)}resolvedPath=PATH.normalizeArray(resolvedPath.split(\\\"/\\\").filter(p=>!!p),!resolvedAbsolute).join(\\\"/\\\");return(resolvedAbsolute?\\\"/\\\":\\\"\\\")+resolvedPath||\\\".\\\"},relative:(from,to)=>{from=PATH_FS.resolve(from).slice(1);to=PATH_FS.resolve(to).slice(1);function trim(arr){var start=0;for(;start<arr.length;start++){if(arr[start]!==\\\"\\\")break}var end=arr.length-1;for(;end>=0;end--){if(arr[end]!==\\\"\\\")break}if(start>end)return[];return arr.slice(start,end-start+1)}var fromParts=trim(from.split(\\\"/\\\"));var toParts=trim(to.split(\\\"/\\\"));var length=Math.min(fromParts.length,toParts.length);var samePartsLength=length;for(var i=0;i<length;i++){if(fromParts[i]!==toParts[i]){samePartsLength=i;break}}var outputParts=[];for(var i=samePartsLength;i<fromParts.length;i++){outputParts.push(\\\"..\\\")}outputParts=outputParts.concat(toParts.slice(samePartsLength));return outputParts.join(\\\"/\\\")}};Module[\\\"PATH_FS\\\"]=PATH_FS;var UTF8Decoder=typeof TextDecoder!=\\\"undefined\\\"?new TextDecoder:undefined;Module[\\\"UTF8Decoder\\\"]=UTF8Decoder;var UTF8ArrayToString=(heapOrArray,idx=0,maxBytesToRead=NaN)=>{idx>>>=0;var endIdx=idx+maxBytesToRead;var endPtr=idx;while(heapOrArray[endPtr]&&!(endPtr>=endIdx))++endPtr;if(endPtr-idx>16&&heapOrArray.buffer&&UTF8Decoder){return UTF8Decoder.decode(heapOrArray.subarray(idx,endPtr))}var str=\\\"\\\";while(idx<endPtr){var u0=heapOrArray[idx++];if(!(u0&128)){str+=String.fromCharCode(u0);continue}var u1=heapOrArray[idx++]&63;if((u0&224)==192){str+=String.fromCharCode((u0&31)<<6|u1);continue}var u2=heapOrArray[idx++]&63;if((u0&240)==224){u0=(u0&15)<<12|u1<<6|u2}else{u0=(u0&7)<<18|u1<<12|u2<<6|heapOrArray[idx++]&63}if(u0<65536){str+=String.fromCharCode(u0)}else{var ch=u0-65536;str+=String.fromCharCode(55296|ch>>10,56320|ch&1023)}}return str};Module[\\\"UTF8ArrayToString\\\"]=UTF8ArrayToString;var FS_stdin_getChar_buffer=[];Module[\\\"FS_stdin_getChar_buffer\\\"]=FS_stdin_getChar_buffer;var lengthBytesUTF8=str=>{var len=0;for(var i=0;i<str.length;++i){var c=str.charCodeAt(i);if(c<=127){len++}else if(c<=2047){len+=2}else if(c>=55296&&c<=57343){len+=4;++i}else{len+=3}}return len};Module[\\\"lengthBytesUTF8\\\"]=lengthBytesUTF8;var stringToUTF8Array=(str,heap,outIdx,maxBytesToWrite)=>{outIdx>>>=0;if(!(maxBytesToWrite>0))return 0;var startIdx=outIdx;var endIdx=outIdx+maxBytesToWrite-1;for(var i=0;i<str.length;++i){var u=str.charCodeAt(i);if(u>=55296&&u<=57343){var u1=str.charCodeAt(++i);u=65536+((u&1023)<<10)|u1&1023}if(u<=127){if(outIdx>=endIdx)break;heap[outIdx++>>>0]=u}else if(u<=2047){if(outIdx+1>=endIdx)break;heap[outIdx++>>>0]=192|u>>6;heap[outIdx++>>>0]=128|u&63}else if(u<=65535){if(outIdx+2>=endIdx)break;heap[outIdx++>>>0]=224|u>>12;heap[outIdx++>>>0]=128|u>>6&63;heap[outIdx++>>>0]=128|u&63}else{if(outIdx+3>=endIdx)break;heap[outIdx++>>>0]=240|u>>18;heap[outIdx++>>>0]=128|u>>12&63;heap[outIdx++>>>0]=128|u>>6&63;heap[outIdx++>>>0]=128|u&63}}heap[outIdx>>>0]=0;return outIdx-startIdx};Module[\\\"stringToUTF8Array\\\"]=stringToUTF8Array;var intArrayFromString=(stringy,dontAddNull,length)=>{var len=length>0?length:lengthBytesUTF8(stringy)+1;var u8array=new Array(len);var numBytesWritten=stringToUTF8Array(stringy,u8array,0,u8array.length);if(dontAddNull)u8array.length=numBytesWritten;return u8array};Module[\\\"intArrayFromString\\\"]=intArrayFromString;var FS_stdin_getChar=()=>{if(!FS_stdin_getChar_buffer.length){var result=null;if(ENVIRONMENT_IS_NODE){var BUFSIZE=256;var buf=Buffer.alloc(BUFSIZE);var bytesRead=0;var fd=process.stdin.fd;try{bytesRead=fs.readSync(fd,buf,0,BUFSIZE)}catch(e){if(e.toString().includes(\\\"EOF\\\"))bytesRead=0;else throw e}if(bytesRead>0){result=buf.slice(0,bytesRead).toString(\\\"utf-8\\\")}}else if(typeof window!=\\\"undefined\\\"&&typeof window.prompt==\\\"function\\\"){result=window.prompt(\\\"Input: \\\");if(result!==null){result+=\\\"\\\\n\\\"}}else{}if(!result){return null}FS_stdin_getChar_buffer=intArrayFromString(result,true)}return FS_stdin_getChar_buffer.shift()};Module[\\\"FS_stdin_getChar\\\"]=FS_stdin_getChar;var TTY={ttys:[],init(){},shutdown(){},register(dev,ops){TTY.ttys[dev]={input:[],output:[],ops};FS.registerDevice(dev,TTY.stream_ops)},stream_ops:{open(stream){var tty=TTY.ttys[stream.node.rdev];if(!tty){throw new FS.ErrnoError(43)}stream.tty=tty;stream.seekable=false},close(stream){stream.tty.ops.fsync(stream.tty)},fsync(stream){stream.tty.ops.fsync(stream.tty)},read(stream,buffer,offset,length,pos){if(!stream.tty||!stream.tty.ops.get_char){throw new FS.ErrnoError(60)}var bytesRead=0;for(var i=0;i<length;i++){var result;try{result=stream.tty.ops.get_char(stream.tty)}catch(e){throw new FS.ErrnoError(29)}if(result===undefined&&bytesRead===0){throw new FS.ErrnoError(6)}if(result===null||result===undefined)break;bytesRead++;buffer[offset+i]=result}if(bytesRead){stream.node.atime=Date.now()}return bytesRead},write(stream,buffer,offset,length,pos){if(!stream.tty||!stream.tty.ops.put_char){throw new FS.ErrnoError(60)}try{for(var i=0;i<length;i++){stream.tty.ops.put_char(stream.tty,buffer[offset+i])}}catch(e){throw new FS.ErrnoError(29)}if(length){stream.node.mtime=stream.node.ctime=Date.now()}return i}},default_tty_ops:{get_char(tty){return FS_stdin_getChar()},put_char(tty,val){if(val===null||val===10){out(UTF8ArrayToString(tty.output));tty.output=[]}else{if(val!=0)tty.output.push(val)}},fsync(tty){if(tty.output?.length>0){out(UTF8ArrayToString(tty.output));tty.output=[]}},ioctl_tcgets(tty){return{c_iflag:25856,c_oflag:5,c_cflag:191,c_lflag:35387,c_cc:[3,28,127,21,4,0,1,0,17,19,26,0,18,15,23,22,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]}},ioctl_tcsets(tty,optional_actions,data){return 0},ioctl_tiocgwinsz(tty){return[24,80]}},default_tty1_ops:{put_char(tty,val){if(val===null||val===10){err(UTF8ArrayToString(tty.output));tty.output=[]}else{if(val!=0)tty.output.push(val)}},fsync(tty){if(tty.output?.length>0){err(UTF8ArrayToString(tty.output));tty.output=[]}}}};Module[\\\"TTY\\\"]=TTY;var zeroMemory=(address,size)=>{HEAPU8.fill(0,address,address+size)};Module[\\\"zeroMemory\\\"]=zeroMemory;var alignMemory=(size,alignment)=>Math.ceil(size/alignment)*alignment;Module[\\\"alignMemory\\\"]=alignMemory;var mmapAlloc=size=>{size=alignMemory(size,65536);var ptr=_emscripten_builtin_memalign(65536,size);if(ptr)zeroMemory(ptr,size);return ptr};Module[\\\"mmapAlloc\\\"]=mmapAlloc;var MEMFS={ops_table:null,mount(mount){return MEMFS.createNode(null,\\\"/\\\",16895,0)},createNode(parent,name,mode,dev){if(FS.isBlkdev(mode)||FS.isFIFO(mode)){throw new FS.ErrnoError(63)}MEMFS.ops_table||={dir:{node:{getattr:MEMFS.node_ops.getattr,setattr:MEMFS.node_ops.setattr,lookup:MEMFS.node_ops.lookup,mknod:MEMFS.node_ops.mknod,rename:MEMFS.node_ops.rename,unlink:MEMFS.node_ops.unlink,rmdir:MEMFS.node_ops.rmdir,readdir:MEMFS.node_ops.readdir,symlink:MEMFS.node_ops.symlink},stream:{llseek:MEMFS.stream_ops.llseek}},file:{node:{getattr:MEMFS.node_ops.getattr,setattr:MEMFS.node_ops.setattr},stream:{llseek:MEMFS.stream_ops.llseek,read:MEMFS.stream_ops.read,write:MEMFS.stream_ops.write,allocate:MEMFS.stream_ops.allocate,mmap:MEMFS.stream_ops.mmap,msync:MEMFS.stream_ops.msync}},link:{node:{getattr:MEMFS.node_ops.getattr,setattr:MEMFS.node_ops.setattr,readlink:MEMFS.node_ops.readlink},stream:{}},chrdev:{node:{getattr:MEMFS.node_ops.getattr,setattr:MEMFS.node_ops.setattr},stream:FS.chrdev_stream_ops}};var node=FS.createNode(parent,name,mode,dev);if(FS.isDir(node.mode)){node.node_ops=MEMFS.ops_table.dir.node;node.stream_ops=MEMFS.ops_table.dir.stream;node.contents={}}else if(FS.isFile(node.mode)){node.node_ops=MEMFS.ops_table.file.node;node.stream_ops=MEMFS.ops_table.file.stream;node.usedBytes=0;node.contents=null}else if(FS.isLink(node.mode)){node.node_ops=MEMFS.ops_table.link.node;node.stream_ops=MEMFS.ops_table.link.stream}else if(FS.isChrdev(node.mode)){node.node_ops=MEMFS.ops_table.chrdev.node;node.stream_ops=MEMFS.ops_table.chrdev.stream}node.atime=node.mtime=node.ctime=Date.now();if(parent){parent.contents[name]=node;parent.atime=parent.mtime=parent.ctime=node.atime}return node},getFileDataAsTypedArray(node){if(!node.contents)return new Uint8Array(0);if(node.contents.subarray)return node.contents.subarray(0,node.usedBytes);return new Uint8Array(node.contents)},expandFileStorage(node,newCapacity){var prevCapacity=node.contents?node.contents.length:0;if(prevCapacity>=newCapacity)return;var CAPACITY_DOUBLING_MAX=1024*1024;newCapacity=Math.max(newCapacity,prevCapacity*(prevCapacity<CAPACITY_DOUBLING_MAX?2:1.125)>>>0);if(prevCapacity!=0)newCapacity=Math.max(newCapacity,256);var oldContents=node.contents;node.contents=new Uint8Array(newCapacity);if(node.usedBytes>0)node.contents.set(oldContents.subarray(0,node.usedBytes),0)},resizeFileStorage(node,newSize){if(node.usedBytes==newSize)return;if(newSize==0){node.contents=null;node.usedBytes=0}else{var oldContents=node.contents;node.contents=new Uint8Array(newSize);if(oldContents){node.contents.set(oldContents.subarray(0,Math.min(newSize,node.usedBytes)))}node.usedBytes=newSize}},node_ops:{getattr(node){var attr={};attr.dev=FS.isChrdev(node.mode)?node.id:1;attr.ino=node.id;attr.mode=node.mode;attr.nlink=1;attr.uid=0;attr.gid=0;attr.rdev=node.rdev;if(FS.isDir(node.mode)){attr.size=4096}else if(FS.isFile(node.mode)){attr.size=node.usedBytes}else if(FS.isLink(node.mode)){attr.size=node.link.length}else{attr.size=0}attr.atime=new Date(node.atime);attr.mtime=new Date(node.mtime);attr.ctime=new Date(node.ctime);attr.blksize=4096;attr.blocks=Math.ceil(attr.size/attr.blksize);return attr},setattr(node,attr){for(const key of[\\\"mode\\\",\\\"atime\\\",\\\"mtime\\\",\\\"ctime\\\"]){if(attr[key]!=null){node[key]=attr[key]}}if(attr.size!==undefined){MEMFS.resizeFileStorage(node,attr.size)}},lookup(parent,name){throw MEMFS.doesNotExistError},mknod(parent,name,mode,dev){return MEMFS.createNode(parent,name,mode,dev)},rename(old_node,new_dir,new_name){var new_node;try{new_node=FS.lookupNode(new_dir,new_name)}catch(e){}if(new_node){if(FS.isDir(old_node.mode)){for(var i in new_node.contents){throw new FS.ErrnoError(55)}}FS.hashRemoveNode(new_node)}delete old_node.parent.contents[old_node.name];new_dir.contents[new_name]=old_node;old_node.name=new_name;new_dir.ctime=new_dir.mtime=old_node.parent.ctime=old_node.parent.mtime=Date.now()},unlink(parent,name){delete parent.contents[name];parent.ctime=parent.mtime=Date.now()},rmdir(parent,name){var node=FS.lookupNode(parent,name);for(var i in node.contents){throw new FS.ErrnoError(55)}delete parent.contents[name];parent.ctime=parent.mtime=Date.now()},readdir(node){return[\\\".\\\",\\\"..\\\",...Object.keys(node.contents)]},symlink(parent,newname,oldpath){var node=MEMFS.createNode(parent,newname,511|40960,0);node.link=oldpath;return node},readlink(node){if(!FS.isLink(node.mode)){throw new FS.ErrnoError(28)}return node.link}},stream_ops:{read(stream,buffer,offset,length,position){var contents=stream.node.contents;if(position>=stream.node.usedBytes)return 0;var size=Math.min(stream.node.usedBytes-position,length);if(size>8&&contents.subarray){buffer.set(contents.subarray(position,position+size),offset)}else{for(var i=0;i<size;i++)buffer[offset+i]=contents[position+i]}return size},write(stream,buffer,offset,length,position,canOwn){if(buffer.buffer===HEAP8.buffer){canOwn=false}if(!length)return 0;var node=stream.node;node.mtime=node.ctime=Date.now();if(buffer.subarray&&(!node.contents||node.contents.subarray)){if(canOwn){node.contents=buffer.subarray(offset,offset+length);node.usedBytes=length;return length}else if(node.usedBytes===0&&position===0){node.contents=buffer.slice(offset,offset+length);node.usedBytes=length;return length}else if(position+length<=node.usedBytes){node.contents.set(buffer.subarray(offset,offset+length),position);return length}}MEMFS.expandFileStorage(node,position+length);if(node.contents.subarray&&buffer.subarray){node.contents.set(buffer.subarray(offset,offset+length),position)}else{for(var i=0;i<length;i++){node.contents[position+i]=buffer[offset+i]}}node.usedBytes=Math.max(node.usedBytes,position+length);return length},llseek(stream,offset,whence){var position=offset;if(whence===1){position+=stream.position}else if(whence===2){if(FS.isFile(stream.node.mode)){position+=stream.node.usedBytes}}if(position<0){throw new FS.ErrnoError(28)}return position},allocate(stream,offset,length){MEMFS.expandFileStorage(stream.node,offset+length);stream.node.usedBytes=Math.max(stream.node.usedBytes,offset+length)},mmap(stream,length,position,prot,flags){if(!FS.isFile(stream.node.mode)){throw new FS.ErrnoError(43)}var ptr;var allocated;var contents=stream.node.contents;if(!(flags&2)&&contents&&contents.buffer===HEAP8.buffer){allocated=false;ptr=contents.byteOffset}else{allocated=true;ptr=mmapAlloc(length);if(!ptr){throw new FS.ErrnoError(48)}if(contents){if(position>0||position+length<contents.length){if(contents.subarray){contents=contents.subarray(position,position+length)}else{contents=Array.prototype.slice.call(contents,position,position+length)}}HEAP8.set(contents,ptr>>>0)}}return{ptr,allocated}},msync(stream,buffer,offset,length,mmapFlags){MEMFS.stream_ops.write(stream,buffer,0,length,offset,false);return 0}}};Module[\\\"MEMFS\\\"]=MEMFS;var asyncLoad=async url=>{var arrayBuffer=await readAsync(url);return new Uint8Array(arrayBuffer)};Module[\\\"asyncLoad\\\"]=asyncLoad;var FS_createDataFile=(parent,name,fileData,canRead,canWrite,canOwn)=>{FS.createDataFile(parent,name,fileData,canRead,canWrite,canOwn)};Module[\\\"FS_createDataFile\\\"]=FS_createDataFile;var preloadPlugins=Module[\\\"preloadPlugins\\\"]||[];Module[\\\"preloadPlugins\\\"]=preloadPlugins;var FS_handledByPreloadPlugin=(byteArray,fullname,finish,onerror)=>{if(typeof Browser!=\\\"undefined\\\")Browser.init();var handled=false;preloadPlugins.forEach(plugin=>{if(handled)return;if(plugin[\\\"canHandle\\\"](fullname)){plugin[\\\"handle\\\"](byteArray,fullname,finish,onerror);handled=true}});return handled};Module[\\\"FS_handledByPreloadPlugin\\\"]=FS_handledByPreloadPlugin;var FS_createPreloadedFile=(parent,name,url,canRead,canWrite,onload,onerror,dontCreateFile,canOwn,preFinish)=>{var fullname=name?PATH_FS.resolve(PATH.join2(parent,name)):parent;var dep=getUniqueRunDependency(`cp ${fullname}`);function processData(byteArray){function finish(byteArray){preFinish?.();if(!dontCreateFile){FS_createDataFile(parent,name,byteArray,canRead,canWrite,canOwn)}onload?.();removeRunDependency(dep)}if(FS_handledByPreloadPlugin(byteArray,fullname,finish,()=>{onerror?.();removeRunDependency(dep)})){return}finish(byteArray)}addRunDependency(dep);if(typeof url==\\\"string\\\"){asyncLoad(url).then(processData,onerror)}else{processData(url)}};Module[\\\"FS_createPreloadedFile\\\"]=FS_createPreloadedFile;var FS_modeStringToFlags=str=>{var flagModes={r:0,\\\"r+\\\":2,w:512|64|1,\\\"w+\\\":512|64|2,a:1024|64|1,\\\"a+\\\":1024|64|2};var flags=flagModes[str];if(typeof flags==\\\"undefined\\\"){throw new Error(`Unknown file open mode: ${str}`)}return flags};Module[\\\"FS_modeStringToFlags\\\"]=FS_modeStringToFlags;var FS_getMode=(canRead,canWrite)=>{var mode=0;if(canRead)mode|=292|73;if(canWrite)mode|=146;return mode};Module[\\\"FS_getMode\\\"]=FS_getMode;var FS={root:null,mounts:[],devices:{},streams:[],nextInode:1,nameTable:null,currentPath:\\\"/\\\",initialized:false,ignorePermissions:true,ErrnoError:class{name=\\\"ErrnoError\\\";constructor(errno){this.errno=errno}},filesystems:null,syncFSRequests:0,readFiles:{},FSStream:class{shared={};get object(){return this.node}set object(val){this.node=val}get isRead(){return(this.flags&2097155)!==1}get isWrite(){return(this.flags&2097155)!==0}get isAppend(){return this.flags&1024}get flags(){return this.shared.flags}set flags(val){this.shared.flags=val}get position(){return this.shared.position}set position(val){this.shared.position=val}},FSNode:class{node_ops={};stream_ops={};readMode=292|73;writeMode=146;mounted=null;constructor(parent,name,mode,rdev){if(!parent){parent=this}this.parent=parent;this.mount=parent.mount;this.id=FS.nextInode++;this.name=name;this.mode=mode;this.rdev=rdev;this.atime=this.mtime=this.ctime=Date.now()}get read(){return(this.mode&this.readMode)===this.readMode}set read(val){val?this.mode|=this.readMode:this.mode&=~this.readMode}get write(){return(this.mode&this.writeMode)===this.writeMode}set write(val){val?this.mode|=this.writeMode:this.mode&=~this.writeMode}get isFolder(){return FS.isDir(this.mode)}get isDevice(){return FS.isChrdev(this.mode)}},lookupPath(path,opts={}){if(!path){throw new FS.ErrnoError(44)}opts.follow_mount??=true;if(!PATH.isAbs(path)){path=FS.cwd()+\\\"/\\\"+path}linkloop:for(var nlinks=0;nlinks<40;nlinks++){var parts=path.split(\\\"/\\\").filter(p=>!!p);var current=FS.root;var current_path=\\\"/\\\";for(var i=0;i<parts.length;i++){var islast=i===parts.length-1;if(islast&&opts.parent){break}if(parts[i]===\\\".\\\"){continue}if(parts[i]===\\\"..\\\"){current_path=PATH.dirname(current_path);current=current.parent;continue}current_path=PATH.join2(current_path,parts[i]);try{current=FS.lookupNode(current,parts[i])}catch(e){if(e?.errno===44&&islast&&opts.noent_okay){return{path:current_path}}throw e}if(FS.isMountpoint(current)&&(!islast||opts.follow_mount)){current=current.mounted.root}if(FS.isLink(current.mode)&&(!islast||opts.follow)){if(!current.node_ops.readlink){throw new FS.ErrnoError(52)}var link=current.node_ops.readlink(current);if(!PATH.isAbs(link)){link=PATH.dirname(current_path)+\\\"/\\\"+link}path=link+\\\"/\\\"+parts.slice(i+1).join(\\\"/\\\");continue linkloop}}return{path:current_path,node:current}}throw new FS.ErrnoError(32)},getPath(node){var path;while(true){if(FS.isRoot(node)){var mount=node.mount.mountpoint;if(!path)return mount;return mount[mount.length-1]!==\\\"/\\\"?`${mount}/${path}`:mount+path}path=path?`${node.name}/${path}`:node.name;node=node.parent}},hashName(parentid,name){var hash=0;for(var i=0;i<name.length;i++){hash=(hash<<5)-hash+name.charCodeAt(i)|0}return(parentid+hash>>>0)%FS.nameTable.length},hashAddNode(node){var hash=FS.hashName(node.parent.id,node.name);node.name_next=FS.nameTable[hash];FS.nameTable[hash]=node},hashRemoveNode(node){var hash=FS.hashName(node.parent.id,node.name);if(FS.nameTable[hash]===node){FS.nameTable[hash]=node.name_next}else{var current=FS.nameTable[hash];while(current){if(current.name_next===node){current.name_next=node.name_next;break}current=current.name_next}}},lookupNode(parent,name){var errCode=FS.mayLookup(parent);if(errCode){throw new FS.ErrnoError(errCode)}var hash=FS.hashName(parent.id,name);for(var node=FS.nameTable[hash];node;node=node.name_next){var nodeName=node.name;if(node.parent.id===parent.id&&nodeName===name){return node}}return FS.lookup(parent,name)},createNode(parent,name,mode,rdev){var node=new FS.FSNode(parent,name,mode,rdev);FS.hashAddNode(node);return node},destroyNode(node){FS.hashRemoveNode(node)},isRoot(node){return node===node.parent},isMountpoint(node){return!!node.mounted},isFile(mode){return(mode&61440)===32768},isDir(mode){return(mode&61440)===16384},isLink(mode){return(mode&61440)===40960},isChrdev(mode){return(mode&61440)===8192},isBlkdev(mode){return(mode&61440)===24576},isFIFO(mode){return(mode&61440)===4096},isSocket(mode){return(mode&49152)===49152},flagsToPermissionString(flag){var perms=[\\\"r\\\",\\\"w\\\",\\\"rw\\\"][flag&3];if(flag&512){perms+=\\\"w\\\"}return perms},nodePermissions(node,perms){if(FS.ignorePermissions){return 0}if(perms.includes(\\\"r\\\")&&!(node.mode&292)){return 2}else if(perms.includes(\\\"w\\\")&&!(node.mode&146)){return 2}else if(perms.includes(\\\"x\\\")&&!(node.mode&73)){return 2}return 0},mayLookup(dir){if(!FS.isDir(dir.mode))return 54;var errCode=FS.nodePermissions(dir,\\\"x\\\");if(errCode)return errCode;if(!dir.node_ops.lookup)return 2;return 0},mayCreate(dir,name){if(!FS.isDir(dir.mode)){return 54}try{var node=FS.lookupNode(dir,name);return 20}catch(e){}return FS.nodePermissions(dir,\\\"wx\\\")},mayDelete(dir,name,isdir){var node;try{node=FS.lookupNode(dir,name)}catch(e){return e.errno}var errCode=FS.nodePermissions(dir,\\\"wx\\\");if(errCode){return errCode}if(isdir){if(!FS.isDir(node.mode)){return 54}if(FS.isRoot(node)||FS.getPath(node)===FS.cwd()){return 10}}else{if(FS.isDir(node.mode)){return 31}}return 0},mayOpen(node,flags){if(!node){return 44}if(FS.isLink(node.mode)){return 32}else if(FS.isDir(node.mode)){if(FS.flagsToPermissionString(flags)!==\\\"r\\\"||flags&(512|64)){return 31}}return FS.nodePermissions(node,FS.flagsToPermissionString(flags))},checkOpExists(op,err){if(!op){throw new FS.ErrnoError(err)}return op},MAX_OPEN_FDS:4096,nextfd(){for(var fd=0;fd<=FS.MAX_OPEN_FDS;fd++){if(!FS.streams[fd]){return fd}}throw new FS.ErrnoError(33)},getStreamChecked(fd){var stream=FS.getStream(fd);if(!stream){throw new FS.ErrnoError(8)}return stream},getStream:fd=>FS.streams[fd],createStream(stream,fd=-1){stream=Object.assign(new FS.FSStream,stream);if(fd==-1){fd=FS.nextfd()}stream.fd=fd;FS.streams[fd]=stream;return stream},closeStream(fd){FS.streams[fd]=null},dupStream(origStream,fd=-1){var stream=FS.createStream(origStream,fd);stream.stream_ops?.dup?.(stream);return stream},doSetAttr(stream,node,attr){var setattr=stream?.stream_ops.setattr;var arg=setattr?stream:node;setattr??=node.node_ops.setattr;FS.checkOpExists(setattr,63);setattr(arg,attr)},chrdev_stream_ops:{open(stream){var device=FS.getDevice(stream.node.rdev);stream.stream_ops=device.stream_ops;stream.stream_ops.open?.(stream)},llseek(){throw new FS.ErrnoError(70)}},major:dev=>dev>>8,minor:dev=>dev&255,makedev:(ma,mi)=>ma<<8|mi,registerDevice(dev,ops){FS.devices[dev]={stream_ops:ops}},getDevice:dev=>FS.devices[dev],getMounts(mount){var mounts=[];var check=[mount];while(check.length){var m=check.pop();mounts.push(m);check.push(...m.mounts)}return mounts},syncfs(populate,callback){if(typeof populate==\\\"function\\\"){callback=populate;populate=false}FS.syncFSRequests++;if(FS.syncFSRequests>1){err(`warning: ${FS.syncFSRequests} FS.syncfs operations in flight at once, probably just doing extra work`)}var mounts=FS.getMounts(FS.root.mount);var completed=0;function doCallback(errCode){FS.syncFSRequests--;return callback(errCode)}function done(errCode){if(errCode){if(!done.errored){done.errored=true;return doCallback(errCode)}return}if(++completed>=mounts.length){doCallback(null)}}mounts.forEach(mount=>{if(!mount.type.syncfs){return done(null)}mount.type.syncfs(mount,populate,done)})},mount(type,opts,mountpoint){var root=mountpoint===\\\"/\\\";var pseudo=!mountpoint;var node;if(root&&FS.root){throw new FS.ErrnoError(10)}else if(!root&&!pseudo){var lookup=FS.lookupPath(mountpoint,{follow_mount:false});mountpoint=lookup.path;node=lookup.node;if(FS.isMountpoint(node)){throw new FS.ErrnoError(10)}if(!FS.isDir(node.mode)){throw new FS.ErrnoError(54)}}var mount={type,opts,mountpoint,mounts:[]};var mountRoot=type.mount(mount);mountRoot.mount=mount;mount.root=mountRoot;if(root){FS.root=mountRoot}else if(node){node.mounted=mount;if(node.mount){node.mount.mounts.push(mount)}}return mountRoot},unmount(mountpoint){var lookup=FS.lookupPath(mountpoint,{follow_mount:false});if(!FS.isMountpoint(lookup.node)){throw new FS.ErrnoError(28)}var node=lookup.node;var mount=node.mounted;var mounts=FS.getMounts(mount);Object.keys(FS.nameTable).forEach(hash=>{var current=FS.nameTable[hash];while(current){var next=current.name_next;if(mounts.includes(current.mount)){FS.destroyNode(current)}current=next}});node.mounted=null;var idx=node.mount.mounts.indexOf(mount);node.mount.mounts.splice(idx,1)},lookup(parent,name){return parent.node_ops.lookup(parent,name)},mknod(path,mode,dev){var lookup=FS.lookupPath(path,{parent:true});var parent=lookup.node;var name=PATH.basename(path);if(!name){throw new FS.ErrnoError(28)}if(name===\\\".\\\"||name===\\\"..\\\"){throw new FS.ErrnoError(20)}var errCode=FS.mayCreate(parent,name);if(errCode){throw new FS.ErrnoError(errCode)}if(!parent.node_ops.mknod){throw new FS.ErrnoError(63)}return parent.node_ops.mknod(parent,name,mode,dev)},statfs(path){return FS.statfsNode(FS.lookupPath(path,{follow:true}).node)},statfsStream(stream){return FS.statfsNode(stream.node)},statfsNode(node){var rtn={bsize:4096,frsize:4096,blocks:1e6,bfree:5e5,bavail:5e5,files:FS.nextInode,ffree:FS.nextInode-1,fsid:42,flags:2,namelen:255};if(node.node_ops.statfs){Object.assign(rtn,node.node_ops.statfs(node.mount.opts.root))}return rtn},create(path,mode=438){mode&=4095;mode|=32768;return FS.mknod(path,mode,0)},mkdir(path,mode=511){mode&=511|512;mode|=16384;return FS.mknod(path,mode,0)},mkdirTree(path,mode){var dirs=path.split(\\\"/\\\");var d=\\\"\\\";for(var i=0;i<dirs.length;++i){if(!dirs[i])continue;d+=\\\"/\\\"+dirs[i];try{FS.mkdir(d,mode)}catch(e){if(e.errno!=20)throw e}}},mkdev(path,mode,dev){if(typeof dev==\\\"undefined\\\"){dev=mode;mode=438}mode|=8192;return FS.mknod(path,mode,dev)},symlink(oldpath,newpath){if(!PATH_FS.resolve(oldpath)){throw new FS.ErrnoError(44)}var lookup=FS.lookupPath(newpath,{parent:true});var parent=lookup.node;if(!parent){throw new FS.ErrnoError(44)}var newname=PATH.basename(newpath);var errCode=FS.mayCreate(parent,newname);if(errCode){throw new FS.ErrnoError(errCode)}if(!parent.node_ops.symlink){throw new FS.ErrnoError(63)}return parent.node_ops.symlink(parent,newname,oldpath)},rename(old_path,new_path){var old_dirname=PATH.dirname(old_path);var new_dirname=PATH.dirname(new_path);var old_name=PATH.basename(old_path);var new_name=PATH.basename(new_path);var lookup,old_dir,new_dir;lookup=FS.lookupPath(old_path,{parent:true});old_dir=lookup.node;lookup=FS.lookupPath(new_path,{parent:true});new_dir=lookup.node;if(!old_dir||!new_dir)throw new FS.ErrnoError(44);if(old_dir.mount!==new_dir.mount){throw new FS.ErrnoError(75)}var old_node=FS.lookupNode(old_dir,old_name);var relative=PATH_FS.relative(old_path,new_dirname);if(relative.charAt(0)!==\\\".\\\"){throw new FS.ErrnoError(28)}relative=PATH_FS.relative(new_path,old_dirname);if(relative.charAt(0)!==\\\".\\\"){throw new FS.ErrnoError(55)}var new_node;try{new_node=FS.lookupNode(new_dir,new_name)}catch(e){}if(old_node===new_node){return}var isdir=FS.isDir(old_node.mode);var errCode=FS.mayDelete(old_dir,old_name,isdir);if(errCode){throw new FS.ErrnoError(errCode)}errCode=new_node?FS.mayDelete(new_dir,new_name,isdir):FS.mayCreate(new_dir,new_name);if(errCode){throw new FS.ErrnoError(errCode)}if(!old_dir.node_ops.rename){throw new FS.ErrnoError(63)}if(FS.isMountpoint(old_node)||new_node&&FS.isMountpoint(new_node)){throw new FS.ErrnoError(10)}if(new_dir!==old_dir){errCode=FS.nodePermissions(old_dir,\\\"w\\\");if(errCode){throw new FS.ErrnoError(errCode)}}FS.hashRemoveNode(old_node);try{old_dir.node_ops.rename(old_node,new_dir,new_name);old_node.parent=new_dir}catch(e){throw e}finally{FS.hashAddNode(old_node)}},rmdir(path){var lookup=FS.lookupPath(path,{parent:true});var parent=lookup.node;var name=PATH.basename(path);var node=FS.lookupNode(parent,name);var errCode=FS.mayDelete(parent,name,true);if(errCode){throw new FS.ErrnoError(errCode)}if(!parent.node_ops.rmdir){throw new FS.ErrnoError(63)}if(FS.isMountpoint(node)){throw new FS.ErrnoError(10)}parent.node_ops.rmdir(parent,name);FS.destroyNode(node)},readdir(path){var lookup=FS.lookupPath(path,{follow:true});var node=lookup.node;var readdir=FS.checkOpExists(node.node_ops.readdir,54);return readdir(node)},unlink(path){var lookup=FS.lookupPath(path,{parent:true});var parent=lookup.node;if(!parent){throw new FS.ErrnoError(44)}var name=PATH.basename(path);var node=FS.lookupNode(parent,name);var errCode=FS.mayDelete(parent,name,false);if(errCode){throw new FS.ErrnoError(errCode)}if(!parent.node_ops.unlink){throw new FS.ErrnoError(63)}if(FS.isMountpoint(node)){throw new FS.ErrnoError(10)}parent.node_ops.unlink(parent,name);FS.destroyNode(node)},readlink(path){var lookup=FS.lookupPath(path);var link=lookup.node;if(!link){throw new FS.ErrnoError(44)}if(!link.node_ops.readlink){throw new FS.ErrnoError(28)}return link.node_ops.readlink(link)},stat(path,dontFollow){var lookup=FS.lookupPath(path,{follow:!dontFollow});var node=lookup.node;var getattr=FS.checkOpExists(node.node_ops.getattr,63);return getattr(node)},fstat(fd){var stream=FS.getStreamChecked(fd);var node=stream.node;var getattr=stream.stream_ops.getattr;var arg=getattr?stream:node;getattr??=node.node_ops.getattr;FS.checkOpExists(getattr,63);return getattr(arg)},lstat(path){return FS.stat(path,true)},doChmod(stream,node,mode,dontFollow){FS.doSetAttr(stream,node,{mode:mode&4095|node.mode&~4095,ctime:Date.now(),dontFollow})},chmod(path,mode,dontFollow){var node;if(typeof path==\\\"string\\\"){var lookup=FS.lookupPath(path,{follow:!dontFollow});node=lookup.node}else{node=path}FS.doChmod(null,node,mode,dontFollow)},lchmod(path,mode){FS.chmod(path,mode,true)},fchmod(fd,mode){var stream=FS.getStreamChecked(fd);FS.doChmod(stream,stream.node,mode,false)},doChown(stream,node,dontFollow){FS.doSetAttr(stream,node,{timestamp:Date.now(),dontFollow})},chown(path,uid,gid,dontFollow){var node;if(typeof path==\\\"string\\\"){var lookup=FS.lookupPath(path,{follow:!dontFollow});node=lookup.node}else{node=path}FS.doChown(null,node,dontFollow)},lchown(path,uid,gid){FS.chown(path,uid,gid,true)},fchown(fd,uid,gid){var stream=FS.getStreamChecked(fd);FS.doChown(stream,stream.node,false)},doTruncate(stream,node,len){if(FS.isDir(node.mode)){throw new FS.ErrnoError(31)}if(!FS.isFile(node.mode)){throw new FS.ErrnoError(28)}var errCode=FS.nodePermissions(node,\\\"w\\\");if(errCode){throw new FS.ErrnoError(errCode)}FS.doSetAttr(stream,node,{size:len,timestamp:Date.now()})},truncate(path,len){if(len<0){throw new FS.ErrnoError(28)}var node;if(typeof path==\\\"string\\\"){var lookup=FS.lookupPath(path,{follow:true});node=lookup.node}else{node=path}FS.doTruncate(null,node,len)},ftruncate(fd,len){var stream=FS.getStreamChecked(fd);if(len<0||(stream.flags&2097155)===0){throw new FS.ErrnoError(28)}FS.doTruncate(stream,stream.node,len)},utime(path,atime,mtime){var lookup=FS.lookupPath(path,{follow:true});var node=lookup.node;var setattr=FS.checkOpExists(node.node_ops.setattr,63);setattr(node,{atime,mtime})},open(path,flags,mode=438){if(path===\\\"\\\"){throw new FS.ErrnoError(44)}flags=typeof flags==\\\"string\\\"?FS_modeStringToFlags(flags):flags;if(flags&64){mode=mode&4095|32768}else{mode=0}var node;var isDirPath;if(typeof path==\\\"object\\\"){node=path}else{isDirPath=path.endsWith(\\\"/\\\");var lookup=FS.lookupPath(path,{follow:!(flags&131072),noent_okay:true});node=lookup.node;path=lookup.path}var created=false;if(flags&64){if(node){if(flags&128){throw new FS.ErrnoError(20)}}else if(isDirPath){throw new FS.ErrnoError(31)}else{node=FS.mknod(path,mode|511,0);created=true}}if(!node){throw new FS.ErrnoError(44)}if(FS.isChrdev(node.mode)){flags&=~512}if(flags&65536&&!FS.isDir(node.mode)){throw new FS.ErrnoError(54)}if(!created){var errCode=FS.mayOpen(node,flags);if(errCode){throw new FS.ErrnoError(errCode)}}if(flags&512&&!created){FS.truncate(node,0)}flags&=~(128|512|131072);var stream=FS.createStream({node,path:FS.getPath(node),flags,seekable:true,position:0,stream_ops:node.stream_ops,ungotten:[],error:false});if(stream.stream_ops.open){stream.stream_ops.open(stream)}if(created){FS.chmod(node,mode&511)}if(Module[\\\"logReadFiles\\\"]&&!(flags&1)){if(!(path in FS.readFiles)){FS.readFiles[path]=1}}return stream},close(stream){if(FS.isClosed(stream)){throw new FS.ErrnoError(8)}if(stream.getdents)stream.getdents=null;try{if(stream.stream_ops.close){stream.stream_ops.close(stream)}}catch(e){throw e}finally{FS.closeStream(stream.fd)}stream.fd=null},isClosed(stream){return stream.fd===null},llseek(stream,offset,whence){if(FS.isClosed(stream)){throw new FS.ErrnoError(8)}if(!stream.seekable||!stream.stream_ops.llseek){throw new FS.ErrnoError(70)}if(whence!=0&&whence!=1&&whence!=2){throw new FS.ErrnoError(28)}stream.position=stream.stream_ops.llseek(stream,offset,whence);stream.ungotten=[];return stream.position},read(stream,buffer,offset,length,position){if(length<0||position<0){throw new FS.ErrnoError(28)}if(FS.isClosed(stream)){throw new FS.ErrnoError(8)}if((stream.flags&2097155)===1){throw new FS.ErrnoError(8)}if(FS.isDir(stream.node.mode)){throw new FS.ErrnoError(31)}if(!stream.stream_ops.read){throw new FS.ErrnoError(28)}var seeking=typeof position!=\\\"undefined\\\";if(!seeking){position=stream.position}else if(!stream.seekable){throw new FS.ErrnoError(70)}var bytesRead=stream.stream_ops.read(stream,buffer,offset,length,position);if(!seeking)stream.position+=bytesRead;return bytesRead},write(stream,buffer,offset,length,position,canOwn){if(length<0||position<0){throw new FS.ErrnoError(28)}if(FS.isClosed(stream)){throw new FS.ErrnoError(8)}if((stream.flags&2097155)===0){throw new FS.ErrnoError(8)}if(FS.isDir(stream.node.mode)){throw new FS.ErrnoError(31)}if(!stream.stream_ops.write){throw new FS.ErrnoError(28)}if(stream.seekable&&stream.flags&1024){FS.llseek(stream,0,2)}var seeking=typeof position!=\\\"undefined\\\";if(!seeking){position=stream.position}else if(!stream.seekable){throw new FS.ErrnoError(70)}var bytesWritten=stream.stream_ops.write(stream,buffer,offset,length,position,canOwn);if(!seeking)stream.position+=bytesWritten;return bytesWritten},allocate(stream,offset,length){if(FS.isClosed(stream)){throw new FS.ErrnoError(8)}if(offset<0||length<=0){throw new FS.ErrnoError(28)}if((stream.flags&2097155)===0){throw new FS.ErrnoError(8)}if(!FS.isFile(stream.node.mode)&&!FS.isDir(stream.node.mode)){throw new FS.ErrnoError(43)}if(!stream.stream_ops.allocate){throw new FS.ErrnoError(138)}stream.stream_ops.allocate(stream,offset,length)},mmap(stream,length,position,prot,flags){if((prot&2)!==0&&(flags&2)===0&&(stream.flags&2097155)!==2){throw new FS.ErrnoError(2)}if((stream.flags&2097155)===1){throw new FS.ErrnoError(2)}if(!stream.stream_ops.mmap){throw new FS.ErrnoError(43)}if(!length){throw new FS.ErrnoError(28)}return stream.stream_ops.mmap(stream,length,position,prot,flags)},msync(stream,buffer,offset,length,mmapFlags){if(!stream.stream_ops.msync){return 0}return stream.stream_ops.msync(stream,buffer,offset,length,mmapFlags)},ioctl(stream,cmd,arg){if(!stream.stream_ops.ioctl){throw new FS.ErrnoError(59)}return stream.stream_ops.ioctl(stream,cmd,arg)},readFile(path,opts={}){opts.flags=opts.flags||0;opts.encoding=opts.encoding||\\\"binary\\\";if(opts.encoding!==\\\"utf8\\\"&&opts.encoding!==\\\"binary\\\"){throw new Error(`Invalid encoding type \\\"${opts.encoding}\\\"`)}var ret;var stream=FS.open(path,opts.flags);var stat=FS.stat(path);var length=stat.size;var buf=new Uint8Array(length);FS.read(stream,buf,0,length,0);if(opts.encoding===\\\"utf8\\\"){ret=UTF8ArrayToString(buf)}else if(opts.encoding===\\\"binary\\\"){ret=buf}FS.close(stream);return ret},writeFile(path,data,opts={}){opts.flags=opts.flags||577;var stream=FS.open(path,opts.flags,opts.mode);if(typeof data==\\\"string\\\"){var buf=new Uint8Array(lengthBytesUTF8(data)+1);var actualNumBytes=stringToUTF8Array(data,buf,0,buf.length);FS.write(stream,buf,0,actualNumBytes,undefined,opts.canOwn)}else if(ArrayBuffer.isView(data)){FS.write(stream,data,0,data.byteLength,undefined,opts.canOwn)}else{throw new Error(\\\"Unsupported data type\\\")}FS.close(stream)},cwd:()=>FS.currentPath,chdir(path){var lookup=FS.lookupPath(path,{follow:true});if(lookup.node===null){throw new FS.ErrnoError(44)}if(!FS.isDir(lookup.node.mode)){throw new FS.ErrnoError(54)}var errCode=FS.nodePermissions(lookup.node,\\\"x\\\");if(errCode){throw new FS.ErrnoError(errCode)}FS.currentPath=lookup.path},createDefaultDirectories(){FS.mkdir(\\\"/tmp\\\");FS.mkdir(\\\"/home\\\");FS.mkdir(\\\"/home/web_user\\\")},createDefaultDevices(){FS.mkdir(\\\"/dev\\\");FS.registerDevice(FS.makedev(1,3),{read:()=>0,write:(stream,buffer,offset,length,pos)=>length,llseek:()=>0});FS.mkdev(\\\"/dev/null\\\",FS.makedev(1,3));TTY.register(FS.makedev(5,0),TTY.default_tty_ops);TTY.register(FS.makedev(6,0),TTY.default_tty1_ops);FS.mkdev(\\\"/dev/tty\\\",FS.makedev(5,0));FS.mkdev(\\\"/dev/tty1\\\",FS.makedev(6,0));var randomBuffer=new Uint8Array(1024),randomLeft=0;var randomByte=()=>{if(randomLeft===0){randomFill(randomBuffer);randomLeft=randomBuffer.byteLength}return randomBuffer[--randomLeft]};FS.createDevice(\\\"/dev\\\",\\\"random\\\",randomByte);FS.createDevice(\\\"/dev\\\",\\\"urandom\\\",randomByte);FS.mkdir(\\\"/dev/shm\\\");FS.mkdir(\\\"/dev/shm/tmp\\\")},createSpecialDirectories(){FS.mkdir(\\\"/proc\\\");var proc_self=FS.mkdir(\\\"/proc/self\\\");FS.mkdir(\\\"/proc/self/fd\\\");FS.mount({mount(){var node=FS.createNode(proc_self,\\\"fd\\\",16895,73);node.stream_ops={llseek:MEMFS.stream_ops.llseek};node.node_ops={lookup(parent,name){var fd=+name;var stream=FS.getStreamChecked(fd);var ret={parent:null,mount:{mountpoint:\\\"fake\\\"},node_ops:{readlink:()=>stream.path},id:fd+1};ret.parent=ret;return ret},readdir(){return Array.from(FS.streams.entries()).filter(([k,v])=>v).map(([k,v])=>k.toString())}};return node}},{},\\\"/proc/self/fd\\\")},createStandardStreams(input,output,error){if(input){FS.createDevice(\\\"/dev\\\",\\\"stdin\\\",input)}else{FS.symlink(\\\"/dev/tty\\\",\\\"/dev/stdin\\\")}if(output){FS.createDevice(\\\"/dev\\\",\\\"stdout\\\",null,output)}else{FS.symlink(\\\"/dev/tty\\\",\\\"/dev/stdout\\\")}if(error){FS.createDevice(\\\"/dev\\\",\\\"stderr\\\",null,error)}else{FS.symlink(\\\"/dev/tty1\\\",\\\"/dev/stderr\\\")}var stdin=FS.open(\\\"/dev/stdin\\\",0);var stdout=FS.open(\\\"/dev/stdout\\\",1);var stderr=FS.open(\\\"/dev/stderr\\\",1)},staticInit(){FS.nameTable=new Array(4096);FS.mount(MEMFS,{},\\\"/\\\");FS.createDefaultDirectories();FS.createDefaultDevices();FS.createSpecialDirectories();FS.filesystems={MEMFS}},init(input,output,error){FS.initialized=true;input??=Module[\\\"stdin\\\"];output??=Module[\\\"stdout\\\"];error??=Module[\\\"stderr\\\"];FS.createStandardStreams(input,output,error)},quit(){FS.initialized=false;for(var i=0;i<FS.streams.length;i++){var stream=FS.streams[i];if(!stream){continue}FS.close(stream)}},findObject(path,dontResolveLastLink){var ret=FS.analyzePath(path,dontResolveLastLink);if(!ret.exists){return null}return ret.object},analyzePath(path,dontResolveLastLink){try{var lookup=FS.lookupPath(path,{follow:!dontResolveLastLink});path=lookup.path}catch(e){}var ret={isRoot:false,exists:false,error:0,name:null,path:null,object:null,parentExists:false,parentPath:null,parentObject:null};try{var lookup=FS.lookupPath(path,{parent:true});ret.parentExists=true;ret.parentPath=lookup.path;ret.parentObject=lookup.node;ret.name=PATH.basename(path);lookup=FS.lookupPath(path,{follow:!dontResolveLastLink});ret.exists=true;ret.path=lookup.path;ret.object=lookup.node;ret.name=lookup.node.name;ret.isRoot=lookup.path===\\\"/\\\"}catch(e){ret.error=e.errno}return ret},createPath(parent,path,canRead,canWrite){parent=typeof parent==\\\"string\\\"?parent:FS.getPath(parent);var parts=path.split(\\\"/\\\").reverse();while(parts.length){var part=parts.pop();if(!part)continue;var current=PATH.join2(parent,part);try{FS.mkdir(current)}catch(e){}parent=current}return current},createFile(parent,name,properties,canRead,canWrite){var path=PATH.join2(typeof parent==\\\"string\\\"?parent:FS.getPath(parent),name);var mode=FS_getMode(canRead,canWrite);return FS.create(path,mode)},createDataFile(parent,name,data,canRead,canWrite,canOwn){var path=name;if(parent){parent=typeof parent==\\\"string\\\"?parent:FS.getPath(parent);path=name?PATH.join2(parent,name):parent}var mode=FS_getMode(canRead,canWrite);var node=FS.create(path,mode);if(data){if(typeof data==\\\"string\\\"){var arr=new Array(data.length);for(var i=0,len=data.length;i<len;++i)arr[i]=data.charCodeAt(i);data=arr}FS.chmod(node,mode|146);var stream=FS.open(node,577);FS.write(stream,data,0,data.length,0,canOwn);FS.close(stream);FS.chmod(node,mode)}},createDevice(parent,name,input,output){var path=PATH.join2(typeof parent==\\\"string\\\"?parent:FS.getPath(parent),name);var mode=FS_getMode(!!input,!!output);FS.createDevice.major??=64;var dev=FS.makedev(FS.createDevice.major++,0);FS.registerDevice(dev,{open(stream){stream.seekable=false},close(stream){if(output?.buffer?.length){output(10)}},read(stream,buffer,offset,length,pos){var bytesRead=0;for(var i=0;i<length;i++){var result;try{result=input()}catch(e){throw new FS.ErrnoError(29)}if(result===undefined&&bytesRead===0){throw new FS.ErrnoError(6)}if(result===null||result===undefined)break;bytesRead++;buffer[offset+i]=result}if(bytesRead){stream.node.atime=Date.now()}return bytesRead},write(stream,buffer,offset,length,pos){for(var i=0;i<length;i++){try{output(buffer[offset+i])}catch(e){throw new FS.ErrnoError(29)}}if(length){stream.node.mtime=stream.node.ctime=Date.now()}return i}});return FS.mkdev(path,mode,dev)},forceLoadFile(obj){if(obj.isDevice||obj.isFolder||obj.link||obj.contents)return true;if(typeof XMLHttpRequest!=\\\"undefined\\\"){throw new Error(\\\"Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.\\\")}else{try{obj.contents=readBinary(obj.url);obj.usedBytes=obj.contents.length}catch(e){throw new FS.ErrnoError(29)}}},createLazyFile(parent,name,url,canRead,canWrite){class LazyUint8Array{lengthKnown=false;chunks=[];get(idx){if(idx>this.length-1||idx<0){return undefined}var chunkOffset=idx%this.chunkSize;var chunkNum=idx/this.chunkSize|0;return this.getter(chunkNum)[chunkOffset]}setDataGetter(getter){this.getter=getter}cacheLength(){var xhr=new XMLHttpRequest;xhr.open(\\\"HEAD\\\",url,false);xhr.send(null);if(!(xhr.status>=200&&xhr.status<300||xhr.status===304))throw new Error(\\\"Couldn't load \\\"+url+\\\". Status: \\\"+xhr.status);var datalength=Number(xhr.getResponseHeader(\\\"Content-length\\\"));var header;var hasByteServing=(header=xhr.getResponseHeader(\\\"Accept-Ranges\\\"))&&header===\\\"bytes\\\";var usesGzip=(header=xhr.getResponseHeader(\\\"Content-Encoding\\\"))&&header===\\\"gzip\\\";var chunkSize=1024*1024;if(!hasByteServing)chunkSize=datalength;var doXHR=(from,to)=>{if(from>to)throw new Error(\\\"invalid range (\\\"+from+\\\", \\\"+to+\\\") or no bytes requested!\\\");if(to>datalength-1)throw new Error(\\\"only \\\"+datalength+\\\" bytes available! programmer error!\\\");var xhr=new XMLHttpRequest;xhr.open(\\\"GET\\\",url,false);if(datalength!==chunkSize)xhr.setRequestHeader(\\\"Range\\\",\\\"bytes=\\\"+from+\\\"-\\\"+to);xhr.responseType=\\\"arraybuffer\\\";if(xhr.overrideMimeType){xhr.overrideMimeType(\\\"text/plain; charset=x-user-defined\\\")}xhr.send(null);if(!(xhr.status>=200&&xhr.status<300||xhr.status===304))throw new Error(\\\"Couldn't load \\\"+url+\\\". Status: \\\"+xhr.status);if(xhr.response!==undefined){return new Uint8Array(xhr.response||[])}return intArrayFromString(xhr.responseText||\\\"\\\",true)};var lazyArray=this;lazyArray.setDataGetter(chunkNum=>{var start=chunkNum*chunkSize;var end=(chunkNum+1)*chunkSize-1;end=Math.min(end,datalength-1);if(typeof lazyArray.chunks[chunkNum]==\\\"undefined\\\"){lazyArray.chunks[chunkNum]=doXHR(start,end)}if(typeof lazyArray.chunks[chunkNum]==\\\"undefined\\\")throw new Error(\\\"doXHR failed!\\\");return lazyArray.chunks[chunkNum]});if(usesGzip||!datalength){chunkSize=datalength=1;datalength=this.getter(0).length;chunkSize=datalength;out(\\\"LazyFiles on gzip forces download of the whole file when length is accessed\\\")}this._length=datalength;this._chunkSize=chunkSize;this.lengthKnown=true}get length(){if(!this.lengthKnown){this.cacheLength()}return this._length}get chunkSize(){if(!this.lengthKnown){this.cacheLength()}return this._chunkSize}}if(typeof XMLHttpRequest!=\\\"undefined\\\"){if(!ENVIRONMENT_IS_WORKER)throw\\\"Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc\\\";var lazyArray=new LazyUint8Array;var properties={isDevice:false,contents:lazyArray}}else{var properties={isDevice:false,url}}var node=FS.createFile(parent,name,properties,canRead,canWrite);if(properties.contents){node.contents=properties.contents}else if(properties.url){node.contents=null;node.url=properties.url}Object.defineProperties(node,{usedBytes:{get:function(){return this.contents.length}}});var stream_ops={};var keys=Object.keys(node.stream_ops);keys.forEach(key=>{var fn=node.stream_ops[key];stream_ops[key]=(...args)=>{FS.forceLoadFile(node);return fn(...args)}});function writeChunks(stream,buffer,offset,length,position){var contents=stream.node.contents;if(position>=contents.length)return 0;var size=Math.min(contents.length-position,length);if(contents.slice){for(var i=0;i<size;i++){buffer[offset+i]=contents[position+i]}}else{for(var i=0;i<size;i++){buffer[offset+i]=contents.get(position+i)}}return size}stream_ops.read=(stream,buffer,offset,length,position)=>{FS.forceLoadFile(node);return writeChunks(stream,buffer,offset,length,position)};stream_ops.mmap=(stream,length,position,prot,flags)=>{FS.forceLoadFile(node);var ptr=mmapAlloc(length);if(!ptr){throw new FS.ErrnoError(48)}writeChunks(stream,HEAP8,ptr,length,position);return{ptr,allocated:true}};node.stream_ops=stream_ops;return node}};Module[\\\"FS\\\"]=FS;var UTF8ToString=(ptr,maxBytesToRead)=>{ptr>>>=0;return ptr?UTF8ArrayToString(HEAPU8,ptr,maxBytesToRead):\\\"\\\"};Module[\\\"UTF8ToString\\\"]=UTF8ToString;var SYSCALLS={DEFAULT_POLLMASK:5,calculateAt(dirfd,path,allowEmpty){if(PATH.isAbs(path)){return path}var dir;if(dirfd===-100){dir=FS.cwd()}else{var dirstream=SYSCALLS.getStreamFromFD(dirfd);dir=dirstream.path}if(path.length==0){if(!allowEmpty){throw new FS.ErrnoError(44)}return dir}return dir+\\\"/\\\"+path},writeStat(buf,stat){HEAP32[buf>>>2>>>0]=stat.dev;HEAP32[buf+4>>>2>>>0]=stat.mode;HEAPU32[buf+8>>>2>>>0]=stat.nlink;HEAP32[buf+12>>>2>>>0]=stat.uid;HEAP32[buf+16>>>2>>>0]=stat.gid;HEAP32[buf+20>>>2>>>0]=stat.rdev;HEAP64[buf+24>>>3]=BigInt(stat.size);HEAP32[buf+32>>>2>>>0]=4096;HEAP32[buf+36>>>2>>>0]=stat.blocks;var atime=stat.atime.getTime();var mtime=stat.mtime.getTime();var ctime=stat.ctime.getTime();HEAP64[buf+40>>>3]=BigInt(Math.floor(atime/1e3));HEAPU32[buf+48>>>2>>>0]=atime%1e3*1e3*1e3;HEAP64[buf+56>>>3]=BigInt(Math.floor(mtime/1e3));HEAPU32[buf+64>>>2>>>0]=mtime%1e3*1e3*1e3;HEAP64[buf+72>>>3]=BigInt(Math.floor(ctime/1e3));HEAPU32[buf+80>>>2>>>0]=ctime%1e3*1e3*1e3;HEAP64[buf+88>>>3]=BigInt(stat.ino);return 0},writeStatFs(buf,stats){HEAP32[buf+4>>>2>>>0]=stats.bsize;HEAP32[buf+40>>>2>>>0]=stats.bsize;HEAP32[buf+8>>>2>>>0]=stats.blocks;HEAP32[buf+12>>>2>>>0]=stats.bfree;HEAP32[buf+16>>>2>>>0]=stats.bavail;HEAP32[buf+20>>>2>>>0]=stats.files;HEAP32[buf+24>>>2>>>0]=stats.ffree;HEAP32[buf+28>>>2>>>0]=stats.fsid;HEAP32[buf+44>>>2>>>0]=stats.flags;HEAP32[buf+36>>>2>>>0]=stats.namelen},doMsync(addr,stream,len,flags,offset){if(!FS.isFile(stream.node.mode)){throw new FS.ErrnoError(43)}if(flags&2){return 0}var buffer=HEAPU8.slice(addr,addr+len);FS.msync(stream,buffer,offset,len,flags)},getStreamFromFD(fd){var stream=FS.getStreamChecked(fd);return stream},varargs:undefined,getStr(ptr){var ret=UTF8ToString(ptr);return ret}};Module[\\\"SYSCALLS\\\"]=SYSCALLS;var INT53_MAX=9007199254740992;Module[\\\"INT53_MAX\\\"]=INT53_MAX;var INT53_MIN=-9007199254740992;Module[\\\"INT53_MIN\\\"]=INT53_MIN;var bigintToI53Checked=num=>num<INT53_MIN||num>INT53_MAX?NaN:Number(num);Module[\\\"bigintToI53Checked\\\"]=bigintToI53Checked;function ___syscall_fcntl64(fd,cmd,varargs){varargs>>>=0;SYSCALLS.varargs=varargs;try{var stream=SYSCALLS.getStreamFromFD(fd);switch(cmd){case 0:{var arg=syscallGetVarargI();if(arg<0){return-28}while(FS.streams[arg]){arg++}var newStream;newStream=FS.dupStream(stream,arg);return newStream.fd}case 1:case 2:return 0;case 3:return stream.flags;case 4:{var arg=syscallGetVarargI();stream.flags|=arg;return 0}case 12:{var arg=syscallGetVarargP();var offset=0;HEAP16[arg+offset>>>1>>>0]=2;return 0}case 13:case 14:return 0}return-28}catch(e){if(typeof FS==\\\"undefined\\\"||!(e.name===\\\"ErrnoError\\\"))throw e;return-e.errno}}Module[\\\"___syscall_fcntl64\\\"]=___syscall_fcntl64;function ___syscall_ioctl(fd,op,varargs){varargs>>>=0;SYSCALLS.varargs=varargs;try{var stream=SYSCALLS.getStreamFromFD(fd);switch(op){case 21509:{if(!stream.tty)return-59;return 0}case 21505:{if(!stream.tty)return-59;if(stream.tty.ops.ioctl_tcgets){var termios=stream.tty.ops.ioctl_tcgets(stream);var argp=syscallGetVarargP();HEAP32[argp>>>2>>>0]=termios.c_iflag||0;HEAP32[argp+4>>>2>>>0]=termios.c_oflag||0;HEAP32[argp+8>>>2>>>0]=termios.c_cflag||0;HEAP32[argp+12>>>2>>>0]=termios.c_lflag||0;for(var i=0;i<32;i++){HEAP8[argp+i+17>>>0]=termios.c_cc[i]||0}return 0}return 0}case 21510:case 21511:case 21512:{if(!stream.tty)return-59;return 0}case 21506:case 21507:case 21508:{if(!stream.tty)return-59;if(stream.tty.ops.ioctl_tcsets){var argp=syscallGetVarargP();var c_iflag=HEAP32[argp>>>2>>>0];var c_oflag=HEAP32[argp+4>>>2>>>0];var c_cflag=HEAP32[argp+8>>>2>>>0];var c_lflag=HEAP32[argp+12>>>2>>>0];var c_cc=[];for(var i=0;i<32;i++){c_cc.push(HEAP8[argp+i+17>>>0])}return stream.tty.ops.ioctl_tcsets(stream.tty,op,{c_iflag,c_oflag,c_cflag,c_lflag,c_cc})}return 0}case 21519:{if(!stream.tty)return-59;var argp=syscallGetVarargP();HEAP32[argp>>>2>>>0]=0;return 0}case 21520:{if(!stream.tty)return-59;return-28}case 21531:{var argp=syscallGetVarargP();return FS.ioctl(stream,op,argp)}case 21523:{if(!stream.tty)return-59;if(stream.tty.ops.ioctl_tiocgwinsz){var winsize=stream.tty.ops.ioctl_tiocgwinsz(stream.tty);var argp=syscallGetVarargP();HEAP16[argp>>>1>>>0]=winsize[0];HEAP16[argp+2>>>1>>>0]=winsize[1]}return 0}case 21524:{if(!stream.tty)return-59;return 0}case 21515:{if(!stream.tty)return-59;return 0}default:return-28}}catch(e){if(typeof FS==\\\"undefined\\\"||!(e.name===\\\"ErrnoError\\\"))throw e;return-e.errno}}Module[\\\"___syscall_ioctl\\\"]=___syscall_ioctl;function ___syscall_openat(dirfd,path,flags,varargs){path>>>=0;varargs>>>=0;SYSCALLS.varargs=varargs;try{path=SYSCALLS.getStr(path);path=SYSCALLS.calculateAt(dirfd,path);var mode=varargs?syscallGetVarargI():0;return FS.open(path,flags,mode).fd}catch(e){if(typeof FS==\\\"undefined\\\"||!(e.name===\\\"ErrnoError\\\"))throw e;return-e.errno}}Module[\\\"___syscall_openat\\\"]=___syscall_openat;var __abort_js=()=>abort(\\\"\\\");Module[\\\"__abort_js\\\"]=__abort_js;var runtimeKeepaliveCounter=0;Module[\\\"runtimeKeepaliveCounter\\\"]=runtimeKeepaliveCounter;var __emscripten_runtime_keepalive_clear=()=>{noExitRuntime=false;runtimeKeepaliveCounter=0};Module[\\\"__emscripten_runtime_keepalive_clear\\\"]=__emscripten_runtime_keepalive_clear;function __mmap_js(len,prot,flags,fd,offset,allocated,addr){len>>>=0;offset=bigintToI53Checked(offset);allocated>>>=0;addr>>>=0;try{if(isNaN(offset))return 61;var stream=SYSCALLS.getStreamFromFD(fd);var res=FS.mmap(stream,len,offset,prot,flags);var ptr=res.ptr;HEAP32[allocated>>>2>>>0]=res.allocated;HEAPU32[addr>>>2>>>0]=ptr;return 0}catch(e){if(typeof FS==\\\"undefined\\\"||!(e.name===\\\"ErrnoError\\\"))throw e;return-e.errno}}Module[\\\"__mmap_js\\\"]=__mmap_js;function __munmap_js(addr,len,prot,flags,fd,offset){addr>>>=0;len>>>=0;offset=bigintToI53Checked(offset);try{var stream=SYSCALLS.getStreamFromFD(fd);if(prot&2){SYSCALLS.doMsync(addr,stream,len,flags,offset)}}catch(e){if(typeof FS==\\\"undefined\\\"||!(e.name===\\\"ErrnoError\\\"))throw e;return-e.errno}}Module[\\\"__munmap_js\\\"]=__munmap_js;var timers={};Module[\\\"timers\\\"]=timers;var handleException=e=>{if(e instanceof ExitStatus||e==\\\"unwind\\\"){return EXITSTATUS}quit_(1,e)};Module[\\\"handleException\\\"]=handleException;var keepRuntimeAlive=()=>noExitRuntime||runtimeKeepaliveCounter>0;Module[\\\"keepRuntimeAlive\\\"]=keepRuntimeAlive;var _proc_exit=code=>{EXITSTATUS=code;if(!keepRuntimeAlive()){Module[\\\"onExit\\\"]?.(code);ABORT=true}quit_(code,new ExitStatus(code))};Module[\\\"_proc_exit\\\"]=_proc_exit;var exitJS=(status,implicit)=>{EXITSTATUS=status;_proc_exit(status)};Module[\\\"exitJS\\\"]=exitJS;var _exit=exitJS;Module[\\\"_exit\\\"]=_exit;var maybeExit=()=>{if(!keepRuntimeAlive()){try{_exit(EXITSTATUS)}catch(e){handleException(e)}}};Module[\\\"maybeExit\\\"]=maybeExit;var callUserCallback=func=>{if(ABORT){return}try{func();maybeExit()}catch(e){handleException(e)}};Module[\\\"callUserCallback\\\"]=callUserCallback;var _emscripten_get_now=()=>performance.now();Module[\\\"_emscripten_get_now\\\"]=_emscripten_get_now;var __setitimer_js=(which,timeout_ms)=>{if(timers[which]){clearTimeout(timers[which].id);delete timers[which]}if(!timeout_ms)return 0;var id=setTimeout(()=>{delete timers[which];callUserCallback(()=>__emscripten_timeout(which,_emscripten_get_now()))},timeout_ms);timers[which]={id,timeout_ms};return 0};Module[\\\"__setitimer_js\\\"]=__setitimer_js;var stringToUTF8=(str,outPtr,maxBytesToWrite)=>stringToUTF8Array(str,HEAPU8,outPtr,maxBytesToWrite);Module[\\\"stringToUTF8\\\"]=stringToUTF8;var __tzset_js=function(timezone,daylight,std_name,dst_name){timezone>>>=0;daylight>>>=0;std_name>>>=0;dst_name>>>=0;var currentYear=(new Date).getFullYear();var winter=new Date(currentYear,0,1);var summer=new Date(currentYear,6,1);var winterOffset=winter.getTimezoneOffset();var summerOffset=summer.getTimezoneOffset();var stdTimezoneOffset=Math.max(winterOffset,summerOffset);HEAPU32[timezone>>>2>>>0]=stdTimezoneOffset*60;HEAP32[daylight>>>2>>>0]=Number(winterOffset!=summerOffset);var extractZone=timezoneOffset=>{var sign=timezoneOffset>=0?\\\"-\\\":\\\"+\\\";var absOffset=Math.abs(timezoneOffset);var hours=String(Math.floor(absOffset/60)).padStart(2,\\\"0\\\");var minutes=String(absOffset%60).padStart(2,\\\"0\\\");return`UTC${sign}${hours}${minutes}`};var winterName=extractZone(winterOffset);var summerName=extractZone(summerOffset);if(summerOffset<winterOffset){stringToUTF8(winterName,std_name,17);stringToUTF8(summerName,dst_name,17)}else{stringToUTF8(winterName,dst_name,17);stringToUTF8(summerName,std_name,17)}};Module[\\\"__tzset_js\\\"]=__tzset_js;var _emscripten_date_now=()=>Date.now();Module[\\\"_emscripten_date_now\\\"]=_emscripten_date_now;var nowIsMonotonic=1;Module[\\\"nowIsMonotonic\\\"]=nowIsMonotonic;var checkWasiClock=clock_id=>clock_id>=0&&clock_id<=3;Module[\\\"checkWasiClock\\\"]=checkWasiClock;function _clock_time_get(clk_id,ignored_precision,ptime){ignored_precision=bigintToI53Checked(ignored_precision);ptime>>>=0;if(!checkWasiClock(clk_id)){return 28}var now;if(clk_id===0){now=_emscripten_date_now()}else if(nowIsMonotonic){now=_emscripten_get_now()}else{return 52}var nsec=Math.round(now*1e3*1e3);HEAP64[ptime>>>3]=BigInt(nsec);return 0}Module[\\\"_clock_time_get\\\"]=_clock_time_get;var getHeapMax=()=>4294901760;Module[\\\"getHeapMax\\\"]=getHeapMax;function _emscripten_get_heap_max(){return getHeapMax()}Module[\\\"_emscripten_get_heap_max\\\"]=_emscripten_get_heap_max;var growMemory=size=>{var b=wasmMemory.buffer;var pages=(size-b.byteLength+65535)/65536|0;try{wasmMemory.grow(pages);updateMemoryViews();return 1}catch(e){}};Module[\\\"growMemory\\\"]=growMemory;function _emscripten_resize_heap(requestedSize){requestedSize>>>=0;var oldSize=HEAPU8.length;var maxHeapSize=getHeapMax();if(requestedSize>maxHeapSize){return false}for(var cutDown=1;cutDown<=4;cutDown*=2){var overGrownHeapSize=oldSize*(1+.2/cutDown);overGrownHeapSize=Math.min(overGrownHeapSize,requestedSize+100663296);var newSize=Math.min(maxHeapSize,alignMemory(Math.max(requestedSize,overGrownHeapSize),65536));var replacement=growMemory(newSize);if(replacement){return true}}return false}Module[\\\"_emscripten_resize_heap\\\"]=_emscripten_resize_heap;var ENV={};Module[\\\"ENV\\\"]=ENV;var getExecutableName=()=>thisProgram||\\\"./this.program\\\";Module[\\\"getExecutableName\\\"]=getExecutableName;var getEnvStrings=()=>{if(!getEnvStrings.strings){var lang=(typeof navigator==\\\"object\\\"&&navigator.languages&&navigator.languages[0]||\\\"C\\\").replace(\\\"-\\\",\\\"_\\\")+\\\".UTF-8\\\";var env={USER:\\\"web_user\\\",LOGNAME:\\\"web_user\\\",PATH:\\\"/\\\",PWD:\\\"/\\\",HOME:\\\"/home/web_user\\\",LANG:lang,_:getExecutableName()};for(var x in ENV){if(ENV[x]===undefined)delete env[x];else env[x]=ENV[x]}var strings=[];for(var x in env){strings.push(`${x}=${env[x]}`)}getEnvStrings.strings=strings}return getEnvStrings.strings};Module[\\\"getEnvStrings\\\"]=getEnvStrings;var stringToAscii=(str,buffer)=>{for(var i=0;i<str.length;++i){HEAP8[buffer++>>>0]=str.charCodeAt(i)}HEAP8[buffer>>>0]=0};Module[\\\"stringToAscii\\\"]=stringToAscii;var _environ_get=function(__environ,environ_buf){__environ>>>=0;environ_buf>>>=0;var bufSize=0;getEnvStrings().forEach((string,i)=>{var ptr=environ_buf+bufSize;HEAPU32[__environ+i*4>>>2>>>0]=ptr;stringToAscii(string,ptr);bufSize+=string.length+1});return 0};Module[\\\"_environ_get\\\"]=_environ_get;var _environ_sizes_get=function(penviron_count,penviron_buf_size){penviron_count>>>=0;penviron_buf_size>>>=0;var strings=getEnvStrings();HEAPU32[penviron_count>>>2>>>0]=strings.length;var bufSize=0;strings.forEach(string=>bufSize+=string.length+1);HEAPU32[penviron_buf_size>>>2>>>0]=bufSize;return 0};Module[\\\"_environ_sizes_get\\\"]=_environ_sizes_get;function _fd_close(fd){try{var stream=SYSCALLS.getStreamFromFD(fd);FS.close(stream);return 0}catch(e){if(typeof FS==\\\"undefined\\\"||!(e.name===\\\"ErrnoError\\\"))throw e;return e.errno}}Module[\\\"_fd_close\\\"]=_fd_close;var doReadv=(stream,iov,iovcnt,offset)=>{var ret=0;for(var i=0;i<iovcnt;i++){var ptr=HEAPU32[iov>>>2>>>0];var len=HEAPU32[iov+4>>>2>>>0];iov+=8;var curr=FS.read(stream,HEAP8,ptr,len,offset);if(curr<0)return-1;ret+=curr;if(curr<len)break;if(typeof offset!=\\\"undefined\\\"){offset+=curr}}return ret};Module[\\\"doReadv\\\"]=doReadv;function _fd_read(fd,iov,iovcnt,pnum){iov>>>=0;iovcnt>>>=0;pnum>>>=0;try{var stream=SYSCALLS.getStreamFromFD(fd);var num=doReadv(stream,iov,iovcnt);HEAPU32[pnum>>>2>>>0]=num;return 0}catch(e){if(typeof FS==\\\"undefined\\\"||!(e.name===\\\"ErrnoError\\\"))throw e;return e.errno}}Module[\\\"_fd_read\\\"]=_fd_read;function _fd_seek(fd,offset,whence,newOffset){offset=bigintToI53Checked(offset);newOffset>>>=0;try{if(isNaN(offset))return 61;var stream=SYSCALLS.getStreamFromFD(fd);FS.llseek(stream,offset,whence);HEAP64[newOffset>>>3]=BigInt(stream.position);if(stream.getdents&&offset===0&&whence===0)stream.getdents=null;return 0}catch(e){if(typeof FS==\\\"undefined\\\"||!(e.name===\\\"ErrnoError\\\"))throw e;return e.errno}}Module[\\\"_fd_seek\\\"]=_fd_seek;var doWritev=(stream,iov,iovcnt,offset)=>{var ret=0;for(var i=0;i<iovcnt;i++){var ptr=HEAPU32[iov>>>2>>>0];var len=HEAPU32[iov+4>>>2>>>0];iov+=8;var curr=FS.write(stream,HEAP8,ptr,len,offset);if(curr<0)return-1;ret+=curr;if(curr<len){break}if(typeof offset!=\\\"undefined\\\"){offset+=curr}}return ret};Module[\\\"doWritev\\\"]=doWritev;function _fd_write(fd,iov,iovcnt,pnum){iov>>>=0;iovcnt>>>=0;pnum>>>=0;try{var stream=SYSCALLS.getStreamFromFD(fd);var num=doWritev(stream,iov,iovcnt);HEAPU32[pnum>>>2>>>0]=num;return 0}catch(e){if(typeof FS==\\\"undefined\\\"||!(e.name===\\\"ErrnoError\\\"))throw e;return e.errno}}Module[\\\"_fd_write\\\"]=_fd_write;function _random_get(buffer,size){buffer>>>=0;size>>>=0;try{randomFill(HEAPU8.subarray(buffer>>>0,buffer+size>>>0));return 0}catch(e){if(typeof FS==\\\"undefined\\\"||!(e.name===\\\"ErrnoError\\\"))throw e;return e.errno}}Module[\\\"_random_get\\\"]=_random_get;var getCFunc=ident=>{var func=Module[\\\"_\\\"+ident];return func};Module[\\\"getCFunc\\\"]=getCFunc;var writeArrayToMemory=(array,buffer)=>{HEAP8.set(array,buffer>>>0)};Module[\\\"writeArrayToMemory\\\"]=writeArrayToMemory;var stackAlloc=sz=>__emscripten_stack_alloc(sz);Module[\\\"stackAlloc\\\"]=stackAlloc;var stringToUTF8OnStack=str=>{var size=lengthBytesUTF8(str)+1;var ret=stackAlloc(size);stringToUTF8(str,ret,size);return ret};Module[\\\"stringToUTF8OnStack\\\"]=stringToUTF8OnStack;var stackSave=()=>_emscripten_stack_get_current();Module[\\\"stackSave\\\"]=stackSave;var stackRestore=val=>__emscripten_stack_restore(val);Module[\\\"stackRestore\\\"]=stackRestore;var ccall=(ident,returnType,argTypes,args,opts)=>{var toC={string:str=>{var ret=0;if(str!==null&&str!==undefined&&str!==0){ret=stringToUTF8OnStack(str)}return ret},array:arr=>{var ret=stackAlloc(arr.length);writeArrayToMemory(arr,ret);return ret}};function convertReturnValue(ret){if(returnType===\\\"string\\\"){return UTF8ToString(ret)}if(returnType===\\\"boolean\\\")return Boolean(ret);return ret}var func=getCFunc(ident);var cArgs=[];var stack=0;if(args){for(var i=0;i<args.length;i++){var converter=toC[argTypes[i]];if(converter){if(stack===0)stack=stackSave();cArgs[i]=converter(args[i])}else{cArgs[i]=args[i]}}}var ret=func(...cArgs);function onDone(ret){if(stack!==0)stackRestore(stack);return convertReturnValue(ret)}ret=onDone(ret);return ret};Module[\\\"ccall\\\"]=ccall;var cwrap=(ident,returnType,argTypes,opts)=>{var numericArgs=!argTypes||argTypes.every(type=>type===\\\"number\\\"||type===\\\"boolean\\\");var numericRet=returnType!==\\\"string\\\";if(numericRet&&numericArgs&&!opts){return getCFunc(ident)}return(...args)=>ccall(ident,returnType,argTypes,args,opts)};Module[\\\"cwrap\\\"]=cwrap;var FS_createPath=FS.createPath;Module[\\\"FS_createPath\\\"]=FS_createPath;var FS_unlink=path=>FS.unlink(path);Module[\\\"FS_unlink\\\"]=FS_unlink;var FS_createLazyFile=FS.createLazyFile;Module[\\\"FS_createLazyFile\\\"]=FS_createLazyFile;var FS_createDevice=FS.createDevice;Module[\\\"FS_createDevice\\\"]=FS_createDevice;FS.createPreloadedFile=FS_createPreloadedFile;FS.staticInit();Module[\\\"FS_createPath\\\"]=FS.createPath;Module[\\\"FS_createDataFile\\\"]=FS.createDataFile;Module[\\\"FS_createPreloadedFile\\\"]=FS.createPreloadedFile;Module[\\\"FS_unlink\\\"]=FS.unlink;Module[\\\"FS_createLazyFile\\\"]=FS.createLazyFile;Module[\\\"FS_createDevice\\\"]=FS.createDevice;MEMFS.doesNotExistError=new FS.ErrnoError(44);MEMFS.doesNotExistError.stack=\\\"<generic error, no stack>\\\";var wasmImports={b:___syscall_fcntl64,f:___syscall_ioctl,g:___syscall_openat,u:__abort_js,j:__emscripten_runtime_keepalive_clear,o:__mmap_js,p:__munmap_js,k:__setitimer_js,q:__tzset_js,t:_clock_time_get,i:_emscripten_date_now,n:_emscripten_get_heap_max,m:_emscripten_resize_heap,s:_environ_get,c:_environ_sizes_get,a:_fd_close,e:_fd_read,r:_fd_seek,d:_fd_write,h:_proc_exit,l:_random_get};var wasmExports;createWasm();var ___wasm_call_ctors=()=>(___wasm_call_ctors=wasmExports[\\\"w\\\"])();var _wllama_malloc=Module[\\\"_wllama_malloc\\\"]=(a0,a1)=>(_wllama_malloc=Module[\\\"_wllama_malloc\\\"]=wasmExports[\\\"x\\\"])(a0,a1);var _wllama_start=Module[\\\"_wllama_start\\\"]=()=>(_wllama_start=Module[\\\"_wllama_start\\\"]=wasmExports[\\\"y\\\"])();var _wllama_action=Module[\\\"_wllama_action\\\"]=(a0,a1)=>(_wllama_action=Module[\\\"_wllama_action\\\"]=wasmExports[\\\"z\\\"])(a0,a1);var _wllama_exit=Module[\\\"_wllama_exit\\\"]=()=>(_wllama_exit=Module[\\\"_wllama_exit\\\"]=wasmExports[\\\"A\\\"])();var _wllama_debug=Module[\\\"_wllama_debug\\\"]=()=>(_wllama_debug=Module[\\\"_wllama_debug\\\"]=wasmExports[\\\"B\\\"])();var _main=Module[\\\"_main\\\"]=(a0,a1)=>(_main=Module[\\\"_main\\\"]=wasmExports[\\\"C\\\"])(a0,a1);var _emscripten_builtin_memalign=(a0,a1)=>(_emscripten_builtin_memalign=wasmExports[\\\"E\\\"])(a0,a1);var __emscripten_timeout=(a0,a1)=>(__emscripten_timeout=wasmExports[\\\"F\\\"])(a0,a1);var ___trap=()=>(___trap=wasmExports[\\\"G\\\"])();var __emscripten_stack_restore=a0=>(__emscripten_stack_restore=wasmExports[\\\"H\\\"])(a0);var __emscripten_stack_alloc=a0=>(__emscripten_stack_alloc=wasmExports[\\\"I\\\"])(a0);var _emscripten_stack_get_current=()=>(_emscripten_stack_get_current=wasmExports[\\\"J\\\"])();function applySignatureConversions(wasmExports){wasmExports=Object.assign({},wasmExports);var makeWrapper_ppp=f=>(a0,a1)=>f(a0,a1)>>>0;var makeWrapper_pp=f=>a0=>f(a0)>>>0;var makeWrapper_p=f=>()=>f()>>>0;wasmExports[\\\"E\\\"]=makeWrapper_ppp(wasmExports[\\\"E\\\"]);wasmExports[\\\"I\\\"]=makeWrapper_pp(wasmExports[\\\"I\\\"]);wasmExports[\\\"J\\\"]=makeWrapper_p(wasmExports[\\\"J\\\"]);return wasmExports}Module[\\\"addRunDependency\\\"]=addRunDependency;Module[\\\"removeRunDependency\\\"]=removeRunDependency;Module[\\\"ccall\\\"]=ccall;Module[\\\"cwrap\\\"]=cwrap;Module[\\\"FS_createPreloadedFile\\\"]=FS_createPreloadedFile;Module[\\\"FS_unlink\\\"]=FS_unlink;Module[\\\"FS_createPath\\\"]=FS_createPath;Module[\\\"FS_createDevice\\\"]=FS_createDevice;Module[\\\"FS_createDataFile\\\"]=FS_createDataFile;Module[\\\"FS_createLazyFile\\\"]=FS_createLazyFile;function callMain(){var entryFunction=_main;var argc=0;var argv=0;try{var ret=entryFunction(argc,argv);exitJS(ret,true);return ret}catch(e){return handleException(e)}}function run(){if(runDependencies>0){dependenciesFulfilled=run;return}preRun();if(runDependencies>0){dependenciesFulfilled=run;return}function doRun(){Module[\\\"calledRun\\\"]=true;if(ABORT)return;initRuntime();preMain();Module[\\\"onRuntimeInitialized\\\"]?.();var noInitialRun=Module[\\\"noInitialRun\\\"];if(!noInitialRun)callMain();postRun()}if(Module[\\\"setStatus\\\"]){Module[\\\"setStatus\\\"](\\\"Running...\\\");setTimeout(()=>{setTimeout(()=>Module[\\\"setStatus\\\"](\\\"\\\"),1);doRun()},1)}else{doRun()}}if(Module[\\\"preInit\\\"]){if(typeof Module[\\\"preInit\\\"]==\\\"function\\\")Module[\\\"preInit\\\"]=[Module[\\\"preInit\\\"]];while(Module[\\\"preInit\\\"].length>0){Module[\\\"preInit\\\"].pop()()}}run();\\n\";\n\n", "/**\n * Module code will be copied into worker.\n *\n * Messages between main <==> worker:\n *\n * From main thread to worker:\n * - Send direction: { verb, args, callbackId }\n * - Result direction: { callbackId, result } or { callbackId, err }\n *\n * Signal from worker to main:\n * - Unidirection: { verb, args }\n */\n\nimport { glueDeserialize, glueSerialize } from './glue/glue';\nimport type { GlueMsg } from './glue/messages';\nimport { createWorker, isSafariMobile } from './utils';\nimport {\n  LLAMA_CPP_WORKER_CODE,\n  WLLAMA_MULTI_THREAD_CODE,\n  WLLAMA_SINGLE_THREAD_CODE,\n} from './workers-code/generated';\n\ninterface Logger {\n  debug: typeof console.debug;\n  log: typeof console.log;\n  warn: typeof console.warn;\n  error: typeof console.error;\n}\n\ninterface TaskParam {\n  verb:\n    | 'module.init'\n    | 'fs.alloc'\n    | 'fs.write'\n    | 'wllama.start'\n    | 'wllama.action'\n    | 'wllama.exit'\n    | 'wllama.debug';\n  args: any[];\n  callbackId: number;\n}\n\ninterface Task {\n  resolve: any;\n  reject: any;\n  param: TaskParam;\n  buffers?: ArrayBuffer[] | undefined;\n}\n\nexport class ProxyToWorker {\n  logger: Logger;\n  suppressNativeLog: boolean;\n  taskQueue: Task[] = [];\n  taskId: number = 1;\n  resultQueue: Task[] = [];\n  busy = false; // is the work loop is running?\n  worker?: Worker;\n  pathConfig: any;\n  multiThread: boolean;\n  nbThread: number;\n\n  constructor(\n    pathConfig: any,\n    nbThread: number = 1,\n    suppressNativeLog: boolean,\n    logger: Logger\n  ) {\n    this.pathConfig = pathConfig;\n    this.nbThread = nbThread;\n    this.multiThread = nbThread > 1;\n    this.logger = logger;\n    this.suppressNativeLog = suppressNativeLog;\n  }\n\n  async moduleInit(ggufFiles: { name: string; blob: Blob }[]): Promise<void> {\n    if (!this.pathConfig['wllama.wasm']) {\n      throw new Error('\"single-thread/wllama.wasm\" is missing from pathConfig');\n    }\n    let moduleCode = this.multiThread\n      ? WLLAMA_MULTI_THREAD_CODE\n      : WLLAMA_SINGLE_THREAD_CODE;\n    let mainModuleCode = moduleCode.replace('var Module', 'var ___Module');\n    const runOptions = {\n      pathConfig: this.pathConfig,\n      nbThread: this.nbThread,\n    };\n    const completeCode: string = [\n      `const RUN_OPTIONS = ${JSON.stringify(runOptions)};`,\n      `function wModuleInit() { ${mainModuleCode}; return Module; }`,\n      LLAMA_CPP_WORKER_CODE,\n    ].join(';\\n\\n');\n    this.worker = createWorker(completeCode);\n    this.worker.onmessage = this.onRecvMsg.bind(this);\n    this.worker.onerror = this.logger.error;\n\n    const res = await this.pushTask({\n      verb: 'module.init',\n      args: [new Blob([moduleCode], { type: 'text/javascript' })],\n      callbackId: this.taskId++,\n    });\n\n    // allocate all files\n    const nativeFiles: ({ id: number } & (typeof ggufFiles)[number])[] = [];\n    for (const file of ggufFiles) {\n      const id = await this.fileAlloc(file.name, file.blob.size);\n      nativeFiles.push({ id, ...file });\n    }\n\n    // stream files\n    await Promise.all(\n      nativeFiles.map((file) => {\n        return this.fileWrite(file.id, file.blob);\n      })\n    );\n\n    return res;\n  }\n\n  async wllamaStart(): Promise<number> {\n    const result = await this.pushTask({\n      verb: 'wllama.start',\n      args: [],\n      callbackId: this.taskId++,\n    });\n    const parsedResult = this.parseResult(result);\n    return parsedResult;\n  }\n\n  async wllamaAction<T extends GlueMsg>(\n    name: string,\n    body: GlueMsg\n  ): Promise<T> {\n    const encodedMsg = glueSerialize(body);\n    const result = await this.pushTask({\n      verb: 'wllama.action',\n      args: [name, encodedMsg],\n      callbackId: this.taskId++,\n    });\n    const parsedResult = glueDeserialize(result);\n    return parsedResult as T;\n  }\n\n  async wllamaExit(): Promise<void> {\n    if (this.worker) {\n      const result = await this.pushTask({\n        verb: 'wllama.exit',\n        args: [],\n        callbackId: this.taskId++,\n      });\n      this.parseResult(result); // only check for exceptions\n      this.worker.terminate();\n    }\n  }\n\n  async wllamaDebug(): Promise<any> {\n    const result = await this.pushTask({\n      verb: 'wllama.debug',\n      args: [],\n      callbackId: this.taskId++,\n    });\n    return JSON.parse(result);\n  }\n\n  ///////////////////////////////////////\n\n  /**\n   * Allocate a new file in heapfs\n   * @returns fileId, to be used by fileWrite()\n   */\n  private async fileAlloc(fileName: string, size: number): Promise<number> {\n    const result = await this.pushTask({\n      verb: 'fs.alloc',\n      args: [fileName, size],\n      callbackId: this.taskId++,\n    });\n    return result.fileId;\n  }\n\n  /**\n   * Write a Blob to heapfs\n   */\n  private async fileWrite(fileId: number, blob: Blob): Promise<void> {\n    const reader = blob.stream().getReader();\n    let offset = 0;\n    while (true) {\n      const { done, value } = await reader.read();\n      if (done) break;\n      const size = value.byteLength;\n      await this.pushTask(\n        {\n          verb: 'fs.write',\n          args: [fileId, value, offset],\n          callbackId: this.taskId++,\n        },\n        // @ts-ignore Type 'ArrayBufferLike' is not assignable to type 'ArrayBuffer'\n        [value.buffer]\n      );\n      offset += size;\n    }\n  }\n\n  /**\n   * Parse JSON result returned by cpp code.\n   * Throw new Error if \"__exception\" is present in the response\n   *\n   * TODO: get rid of this function once everything is migrated to Glue\n   */\n  private parseResult(result: any): any {\n    const parsedResult = JSON.parse(result);\n    if (parsedResult && parsedResult['error']) {\n      throw new Error('Unknown error, please see console.log');\n    }\n    return parsedResult;\n  }\n\n  /**\n   * Push a new task to taskQueue\n   */\n  private pushTask(param: TaskParam, buffers?: ArrayBuffer[]) {\n    return new Promise<any>((resolve, reject) => {\n      this.taskQueue.push({ resolve, reject, param, buffers });\n      this.runTaskLoop();\n    });\n  }\n\n  /**\n   * Main loop for processing tasks\n   */\n  private async runTaskLoop() {\n    if (this.busy) {\n      return; // another loop is already running\n    }\n    this.busy = true;\n    while (true) {\n      const task = this.taskQueue.shift();\n      if (!task) break; // no more tasks\n      this.resultQueue.push(task);\n      // TODO @ngxson : Safari mobile doesn't support transferable ArrayBuffer\n      this.worker!!.postMessage(\n        task.param,\n        isSafariMobile()\n          ? undefined\n          : {\n              transfer: task.buffers ?? [],\n            }\n      );\n    }\n    this.busy = false;\n  }\n\n  /**\n   * Handle messages from worker\n   */\n  private onRecvMsg(e: MessageEvent<any>) {\n    if (!e.data) return; // ignore\n    const { verb, args } = e.data;\n    if (verb && verb.startsWith('console.')) {\n      if (this.suppressNativeLog) {\n        return;\n      }\n      if (verb.endsWith('debug')) this.logger.debug(...args);\n      if (verb.endsWith('log')) this.logger.log(...args);\n      if (verb.endsWith('warn')) this.logger.warn(...args);\n      if (verb.endsWith('error')) this.logger.error(...args);\n      return;\n    } else if (verb === 'signal.abort') {\n      this.abort(args[0]);\n    }\n\n    const { callbackId, result, err } = e.data;\n    if (callbackId) {\n      const idx = this.resultQueue.findIndex(\n        (t) => t.param.callbackId === callbackId\n      );\n      if (idx !== -1) {\n        const waitingTask = this.resultQueue.splice(idx, 1)[0];\n        if (err) waitingTask.reject(err);\n        else waitingTask.resolve(result);\n      } else {\n        this.logger.error(\n          `Cannot find waiting task with callbackId = ${callbackId}`\n        );\n      }\n    }\n  }\n\n  private abort(text: string) {\n    while (this.resultQueue.length > 0) {\n      const waitingTask = this.resultQueue.pop();\n      if (!waitingTask) break;\n      waitingTask.reject(\n        new Error(\n          `Received abort signal from llama.cpp; Message: ${text || '(empty)'}`\n        )\n      );\n    }\n  }\n}\n", "import type { DownloadProgressCallback } from './model-manager';\nimport { createWorker, isSafariMobile } from './utils';\nimport { OPFS_UTILS_WORKER_CODE } from './workers-code/generated';\n\nconst PREFIX_METADATA = '__metadata__';\n\nexport type DownloadOptions = {\n  /**\n   * Callback function to track download progress\n   */\n  progressCallback?: DownloadProgressCallback;\n  /**\n   * Custom headers for the request. Useful for authentication (e.g. Bearer token)\n   */\n  headers?: Record<string, string>;\n  /**\n   * Abort signal for the request\n   */\n  signal?: AbortSignal;\n};\n\n// To prevent breaking change, we fill etag with a pre-defined value\nexport const POLYFILL_ETAG = 'polyfill_for_older_version';\n\nexport interface CacheEntry {\n  /**\n   * File name in OPFS, in the format: `${hashSHA1(fullURL)}_${fileName}`\n   */\n  name: string;\n  /**\n   * Size of file (in bytes)\n   */\n  size: number;\n  /**\n   * Other metadata\n   */\n  metadata: CacheEntryMetadata;\n}\n\nexport interface CacheEntryMetadata {\n  /**\n   * ETag header from remote request\n   * https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/ETag\n   */\n  etag: string;\n  /**\n   * Remote file size (in bytes), used for integrity check\n   */\n  originalSize: number;\n  /**\n   * Original URL of the remote model. Unused for now\n   */\n  originalURL: string;\n}\n\n/**\n * Cache implementation using OPFS (Origin private file system)\n *\n * This class is also responsible for downloading files from the internet.\n */\nclass CacheManager {\n  /**\n   * Convert a given URL into file name in cache.\n   *\n   * Format of the file name: `${hashSHA1(fullURL)}_${fileName}`\n   */\n  async getNameFromURL(url: string): Promise<string> {\n    return await urlToFileName(url, '');\n  }\n\n  /**\n   * @deprecated Use `download()` instead\n   *\n   * Write a new file to cache. This will overwrite existing file.\n   *\n   * @param name The file name returned by `getNameFromURL()` or `list()`\n   */\n  async write(\n    name: string,\n    stream: ReadableStream,\n    metadata: CacheEntryMetadata\n  ): Promise<void> {\n    this.writeMetadata(name, metadata); // no need await\n    return await opfsWrite(name, stream);\n  }\n\n  async download(url: string, options: DownloadOptions = {}): Promise<void> {\n    const worker = createWorker(OPFS_UTILS_WORKER_CODE);\n    let aborted = false;\n    if (options.signal) {\n      aborted = options.signal.aborted;\n      const mSignal = options.signal;\n      mSignal.addEventListener('abort', () => {\n        aborted = true;\n        worker.postMessage({ action: 'download-abort' });\n      });\n      delete options.signal;\n    }\n    const metadataFileName: string = await urlToFileName(url, PREFIX_METADATA);\n    const filename: string = await urlToFileName(url, '');\n    return await new Promise((resolve, reject) => {\n      worker.postMessage({\n        action: 'download',\n        url,\n        filename,\n        metadataFileName,\n        options: { headers: options.headers, aborted },\n      });\n      worker.onmessage = (e: MessageEvent<any>) => {\n        if (e.data.ok) {\n          worker.terminate();\n          resolve();\n        } else if (e.data.err) {\n          worker.terminate();\n          reject(e.data.err);\n        } else if (e.data.progress) {\n          const progress: { loaded: number; total: number } = e.data.progress;\n          options.progressCallback?.(progress);\n        } else {\n          // should never happen\n          reject(new Error('Unknown message from worker'));\n          console.error('Unknown message from worker', e.data);\n        }\n      };\n    });\n  }\n\n  /**\n   * Open a file in cache for reading\n   *\n   * @param nameOrURL The file name returned by `getNameFromURL()` or `list()`, or the original URL of the remote file\n   * @returns Blob, or null if file does not exist\n   */\n  async open(nameOrURL: string): Promise<Blob | null> {\n    return await opfsOpen(nameOrURL);\n  }\n\n  /**\n   * Get the size of a file in stored cache\n   *\n   * NOTE: in case the download is stopped mid-way (i.e. user close browser tab), the file maybe corrupted, size maybe different from `metadata.originalSize`\n   *\n   * @param name The file name returned by `getNameFromURL()` or `list()`\n   * @returns number of bytes, or -1 if file does not exist\n   */\n  async getSize(name: string): Promise<number> {\n    return await opfsFileSize(name);\n  }\n\n  /**\n   * Get metadata of a cached file\n   */\n  async getMetadata(name: string): Promise<CacheEntryMetadata | null> {\n    const stream = await opfsOpen(name, PREFIX_METADATA);\n    const cachedSize = await this.getSize(name);\n    if (!stream) {\n      return cachedSize > 0\n        ? // files created by older version of wllama doesn't have metadata, we will try to polyfill it\n          {\n            etag: POLYFILL_ETAG,\n            originalSize: cachedSize,\n            originalURL: '',\n          }\n        : // if cached file not found, we don't have metadata at all\n          null;\n    }\n    try {\n      const meta = await new Response(stream).json();\n      return meta;\n    } catch (e) {\n      // worst case: metadata is somehow corrupted, we will re-download the model\n      return null;\n    }\n  }\n\n  /**\n   * List all files currently in cache\n   */\n  async list(): Promise<CacheEntry[]> {\n    const cacheDir = await getCacheDir();\n    const result: CacheEntry[] = [];\n    const metadataMap: Record<string, CacheEntryMetadata> = {};\n    // @ts-ignore\n    for await (let [name, handler] of cacheDir.entries()) {\n      if (handler.kind === 'file' && name.startsWith(PREFIX_METADATA)) {\n        const stream = (\n          await (handler as FileSystemFileHandle).getFile()\n        ).stream();\n        const meta = await new Response(stream).json().catch((_) => null);\n        metadataMap[name.replace(PREFIX_METADATA, '')] = meta;\n      }\n    }\n    // @ts-ignore\n    for await (let [name, handler] of cacheDir.entries()) {\n      if (handler.kind === 'file' && !name.startsWith(PREFIX_METADATA)) {\n        result.push({\n          name,\n          size: await (handler as FileSystemFileHandle)\n            .getFile()\n            .then((f) => f.size),\n          metadata: metadataMap[name] || {\n            // try to polyfill for old versions\n            originalSize: (await (handler as FileSystemFileHandle).getFile())\n              .size,\n            originalURL: '',\n            etag: '',\n          },\n        });\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Clear all files currently in cache\n   */\n  async clear(): Promise<void> {\n    await this.deleteMany(() => true);\n  }\n\n  /**\n   * Delete a single file in cache\n   *\n   * @param nameOrURL Can be either an URL or a name returned by `getNameFromURL()` or `list()`\n   */\n  async delete(nameOrURL: string): Promise<void> {\n    const name2 = await this.getNameFromURL(nameOrURL);\n    await this.deleteMany(\n      (entry) => entry.name === nameOrURL || entry.name === name2\n    );\n  }\n\n  /**\n   * Delete multiple files in cache.\n   *\n   * @param predicate A predicate like `array.filter(item => boolean)`\n   */\n  async deleteMany(predicate: (e: CacheEntry) => boolean): Promise<void> {\n    const cacheDir = await getCacheDir();\n    const list = await this.list();\n    for (const item of list) {\n      if (predicate(item)) {\n        cacheDir.removeEntry(item.name);\n      }\n    }\n  }\n\n  /**\n   * Write the metadata of the file to disk.\n   *\n   * This function is separated from `write()` for compatibility reason. In older version of wllama, there was no metadata for cached file, so when newer version of wllama loads a file created by older version, it will try to polyfill the metadata.\n   */\n  async writeMetadata(\n    name: string,\n    metadata: CacheEntryMetadata\n  ): Promise<void> {\n    const blob = new Blob([JSON.stringify(metadata)], { type: 'text/plain' });\n    await opfsWrite(name, blob.stream(), PREFIX_METADATA);\n  }\n}\n\nexport default CacheManager;\n\n/**\n * Write to OPFS file from ReadableStream\n */\nasync function opfsWrite(\n  key: string,\n  stream: ReadableStream,\n  prefix = ''\n): Promise<void> {\n  try {\n    const fileName = await urlToFileName(key, prefix);\n    const writable = await opfsWriteViaWorker(fileName);\n    await writable.truncate(0); // clear file content\n    const reader = stream.getReader();\n    while (true) {\n      const { done, value } = await reader.read();\n      if (done) break;\n      await writable.write(value);\n    }\n    await writable.close();\n  } catch (e) {\n    console.error('opfsWrite', e);\n  }\n}\n\n/**\n * Opens a file in OPFS for reading\n * @returns ReadableStream\n */\nasync function opfsOpen(\n  originalURLOrName: string,\n  prefix = ''\n): Promise<File | null> {\n  const getFileHandler = async (fname: string) => {\n    try {\n      const cacheDir = await getCacheDir();\n      const fileHandler = await cacheDir.getFileHandle(fname);\n      return await fileHandler.getFile();\n    } catch (e) {\n      // TODO: check if exception is NotFoundError\n      return null;\n    }\n  };\n  let handler = await getFileHandler(originalURLOrName);\n  if (handler) {\n    return handler;\n  }\n  // retry if needed\n  const fileName = await urlToFileName(originalURLOrName, prefix);\n  handler = await getFileHandler(fileName);\n  return handler;\n}\n\n/**\n * Get file size of a file in OPFS\n * @returns number of bytes, or -1 if file does not exist\n */\nasync function opfsFileSize(originalURL: string, prefix = ''): Promise<number> {\n  try {\n    const cacheDir = await getCacheDir();\n    const fileName = await urlToFileName(originalURL, prefix);\n    const fileHandler = await cacheDir.getFileHandle(fileName);\n    const file = await fileHandler.getFile();\n    return file.size;\n  } catch (e) {\n    // TODO: check if exception is NotFoundError\n    return -1;\n  }\n}\n\nasync function urlToFileName(url: string, prefix: string) {\n  const hashBuffer = await crypto.subtle.digest(\n    'SHA-1',\n    new TextEncoder().encode(url)\n  );\n  const hashArray = Array.from(new Uint8Array(hashBuffer));\n  const hashHex = hashArray\n    .map((b) => b.toString(16).padStart(2, '0'))\n    .join('');\n  return `${prefix}${hashHex}_${url.split('/').pop()}`;\n}\n\nasync function getCacheDir() {\n  const opfsRoot = await navigator.storage.getDirectory();\n  const cacheDir = await opfsRoot.getDirectoryHandle('cache', { create: true });\n  return cacheDir;\n}\n\nasync function opfsWriteViaWorker(fileName: string): Promise<{\n  truncate(offset: number): Promise<void>;\n  write(value: Uint8Array): Promise<void>;\n  close(): Promise<void>;\n}> {\n  const worker = createWorker(OPFS_UTILS_WORKER_CODE);\n  let pResolve: (v: any) => void;\n  let pReject: (v: any) => void;\n  worker.onmessage = (e: MessageEvent<any>) => {\n    if (e.data.ok) pResolve(null);\n    else if (e.data.err) pReject(e.data.err);\n  };\n  const workerExec = (data: {\n    open?: string;\n    value?: Uint8Array;\n    done?: boolean;\n  }) =>\n    new Promise<void>((resolve, reject) => {\n      pResolve = resolve;\n      pReject = reject;\n      // TODO @ngxson : Safari mobile doesn't support transferable ArrayBuffer\n      worker.postMessage(\n        data,\n        isSafariMobile()\n          ? undefined\n          : {\n              transfer: data.value ? [data.value.buffer] : [],\n            }\n      );\n    });\n  await workerExec({ open: fileName });\n  return {\n    truncate: async () => {\n      /* noop */\n    },\n    write: (value) => workerExec({ value }),\n    close: async () => {\n      await workerExec({ done: true });\n      worker.terminate();\n    },\n  };\n}\n", "import CacheManager, {\n  type CacheEntry,\n  type DownloadOptions,\n} from './cache-manager';\nimport { isValidGgufFile, sumArr } from './utils';\nimport { WllamaError, type WllamaLogger } from './wllama';\n\nconst DEFAULT_PARALLEL_DOWNLOADS = 3;\n\n/**\n * Callback function to track download progress\n */\nexport type DownloadProgressCallback = (opts: {\n  /**\n   * Number of bytes loaded (sum of all shards)\n   */\n  loaded: number;\n  /**\n   * Total number of bytes (sum of all shards)\n   */\n  total: number;\n}) => any;\n\n/**\n * Status of the model validation\n */\nexport enum ModelValidationStatus {\n  VALID = 'valid',\n  INVALID = 'invalid',\n  DELETED = 'deleted',\n}\n\n/**\n * Parameters for ModelManager constructor\n */\nexport interface ModelManagerParams {\n  cacheManager?: CacheManager;\n  logger?: WllamaLogger;\n  /**\n   * Number of parallel downloads\n   *\n   * Default: 3\n   */\n  parallelDownloads?: number | undefined;\n  /**\n   * Allow offline mode\n   *\n   * Default: false\n   */\n  allowOffline?: boolean | undefined;\n}\n\n/**\n * Model class\n *\n * One model can have multiple shards, each shard is a GGUF file.\n */\nexport class Model {\n  private modelManager: ModelManager;\n  constructor(\n    modelManager: ModelManager,\n    url: string,\n    savedFiles?: CacheEntry[]\n  ) {\n    this.modelManager = modelManager;\n    this.url = url;\n    if (savedFiles) {\n      // this file is already in cache\n      this.files = this.getAllFiles(savedFiles);\n      this.size = sumArr(this.files.map((f) => f.metadata.originalSize));\n    } else {\n      // this file is not in cache, we are about to download it\n      this.files = [];\n      this.size = 0;\n    }\n  }\n  /**\n   * URL to the GGUF file (in case it contains multiple shards, the URL should point to the first shard)\n   *\n   * This URL will be used to identify the model in the cache. There can't be 2 models with the same URL.\n   */\n  url: string;\n  /**\n   * Size in bytes (total size of all shards).\n   *\n   * A value of -1 means the model is deleted from the cache. You must call `ModelManager.downloadModel` to re-download the model.\n   */\n  size: number;\n  /**\n   * List of all shards in the cache, sorted by original URL (ascending order)\n   */\n  files: CacheEntry[];\n  /**\n   * Open and get a list of all shards as Blobs\n   */\n  async open(): Promise<Blob[]> {\n    if (this.size === -1) {\n      throw new WllamaError(\n        `Model is deleted from the cache; Call ModelManager.downloadModel to re-download the model`,\n        'load_error'\n      );\n    }\n    const blobs: Blob[] = [];\n    for (const file of this.files) {\n      const blob = await this.modelManager.cacheManager.open(file.name);\n      if (!blob) {\n        throw new Error(\n          `Failed to open file ${file.name}; Hint: the model may be invalid, please refresh it`\n        );\n      }\n      blobs.push(blob);\n    }\n    return blobs;\n  }\n  /**\n   * Validate the model files.\n   *\n   * If the model is invalid, the model manager will not be able to use it. You must call `refresh` to re-download the model.\n   *\n   * Cases that model is invalid:\n   * - The model is deleted from the cache\n   * - The model files are missing (or the download is interrupted)\n   */\n  validate(): ModelValidationStatus {\n    const nbShards = ModelManager.parseModelUrl(this.url).length;\n    if (this.size === -1) {\n      return ModelValidationStatus.DELETED;\n    }\n    if (this.size < 16 || this.files.length !== nbShards) {\n      return ModelValidationStatus.INVALID;\n    }\n    for (const file of this.files) {\n      if (!file.metadata || file.metadata.originalSize !== file.size) {\n        return ModelValidationStatus.INVALID;\n      }\n    }\n    return ModelValidationStatus.VALID;\n  }\n  /**\n   * In case the model is invalid, call this function to re-download the model\n   */\n  async refresh(options: DownloadOptions = {}): Promise<void> {\n    const urls = ModelManager.parseModelUrl(this.url);\n    const works = urls.map((url, index) => ({\n      url,\n      index,\n    }));\n    this.modelManager.logger.debug('Downloading model files:', urls);\n    const nParallel =\n      this.modelManager.params.parallelDownloads ?? DEFAULT_PARALLEL_DOWNLOADS;\n    const totalSize = await this.getTotalDownloadSize(urls);\n    const loadedSize: number[] = [];\n    const worker = async () => {\n      while (works.length > 0) {\n        const w = works.shift();\n        if (!w) break;\n        await this.modelManager.cacheManager.download(w.url, {\n          ...options,\n          progressCallback: ({ loaded }) => {\n            loadedSize[w.index] = loaded;\n            options.progressCallback?.({\n              loaded: sumArr(loadedSize),\n              total: totalSize,\n            });\n          },\n        });\n      }\n    };\n    const promises: Promise<void>[] = [];\n    for (let i = 0; i < nParallel; i++) {\n      promises.push(worker());\n      loadedSize.push(0);\n    }\n    await Promise.all(promises);\n    this.files = this.getAllFiles(await this.modelManager.cacheManager.list());\n    this.size = this.files.reduce((acc, f) => acc + f.metadata.originalSize, 0);\n  }\n  /**\n   * Remove the model from the cache\n   */\n  async remove(): Promise<void> {\n    this.files = this.getAllFiles(await this.modelManager.cacheManager.list());\n    await this.modelManager.cacheManager.deleteMany(\n      (f) => !!this.files.find((file) => file.name === f.name)\n    );\n    this.size = -1;\n  }\n\n  private getAllFiles(savedFiles: CacheEntry[]): CacheEntry[] {\n    const allUrls = new Set(ModelManager.parseModelUrl(this.url));\n    const allFiles: CacheEntry[] = [];\n    for (const url of allUrls) {\n      const file = savedFiles.find((f) => f.metadata.originalURL === url);\n      if (!file) {\n        throw new Error(`Model file not found: ${url}`);\n      }\n      allFiles.push(file);\n    }\n    allFiles.sort((a, b) =>\n      a.metadata.originalURL.localeCompare(b.metadata.originalURL)\n    );\n    return allFiles;\n  }\n\n  private async getTotalDownloadSize(urls: string[]): Promise<number> {\n    const responses = await Promise.all(\n      urls.map((url) => fetch(url, { method: 'HEAD' }))\n    );\n    const sizes = responses.map((res) =>\n      Number(res.headers.get('content-length') || '0')\n    );\n    return sumArr(sizes);\n  }\n}\n\nexport class ModelManager {\n  // The CacheManager singleton, can be accessed by user\n  public cacheManager: CacheManager;\n\n  public params: ModelManagerParams;\n  public logger: WllamaLogger;\n\n  constructor(params: ModelManagerParams = {}) {\n    this.cacheManager = params.cacheManager || new CacheManager();\n    this.params = params;\n    this.logger = params.logger || console;\n  }\n\n  /**\n   * Parses a model URL and returns an array of URLs based on the following patterns:\n   * - If the input URL is an array, it returns the array itself.\n   * - If the input URL is a string in the `gguf-split` format, it returns an array containing the URL of each shard in ascending order.\n   * - Otherwise, it returns an array containing the input URL as a single element array.\n   * @param modelUrl URL or list of URLs\n   */\n  static parseModelUrl(modelUrl: string | string[]): string[] {\n    if (Array.isArray(modelUrl)) {\n      return modelUrl;\n    }\n    const urlPartsRegex = /-(\\d{5})-of-(\\d{5})\\.gguf(?:\\?.*)?$/;\n    const queryMatch = modelUrl.match(/\\.gguf(\\?.*)?$/);\n    const queryParams = queryMatch?.[1] ?? '';\n    const matches = modelUrl.match(urlPartsRegex);\n    if (!matches) {\n      return [modelUrl];\n    }\n    const baseURL = modelUrl.replace(urlPartsRegex, '');\n    const total = matches[2];\n    const paddedShardIds = Array.from({ length: Number(total) }, (_, index) =>\n      (index + 1).toString().padStart(5, '0')\n    );\n    return paddedShardIds.map(\n      (current) => `${baseURL}-${current}-of-${total}.gguf${queryParams}`\n    );\n  }\n\n  /**\n   * Get all models in the cache\n   */\n  async getModels(opts: { includeInvalid?: boolean } = {}): Promise<Model[]> {\n    const cachedFiles = await this.cacheManager.list();\n    let models: Model[] = [];\n    for (const file of cachedFiles) {\n      const shards = ModelManager.parseModelUrl(file.metadata.originalURL);\n      const isFirstShard =\n        shards.length === 1 || shards[0] === file.metadata.originalURL;\n      if (isFirstShard) {\n        models.push(new Model(this, file.metadata.originalURL, cachedFiles));\n      }\n    }\n    if (!opts.includeInvalid) {\n      models = models.filter(\n        (m) => m.validate() === ModelValidationStatus.VALID\n      );\n    }\n    return models;\n  }\n\n  /**\n   * Download a model from the given URL.\n   *\n   * The URL must end with `.gguf`\n   */\n  async downloadModel(\n    url: string,\n    options: DownloadOptions = {}\n  ): Promise<Model> {\n    if (!isValidGgufFile(url)) {\n      throw new WllamaError(\n        `Invalid model URL: ${url}; URL must ends with \".gguf\"`,\n        'download_error'\n      );\n    }\n    const model = new Model(this, url, undefined);\n    const validity = model.validate();\n    if (validity !== ModelValidationStatus.VALID) {\n      await model.refresh(options);\n    }\n    return model;\n  }\n\n  /**\n   * Get a model from the cache or download it if it's not available.\n   */\n  async getModelOrDownload(\n    url: string,\n    options: DownloadOptions = {}\n  ): Promise<Model> {\n    const models = await this.getModels();\n    const model = models.find((m) => m.url === url);\n    if (model) {\n      options.progressCallback?.({ loaded: model.size, total: model.size });\n      return model;\n    }\n    return this.downloadModel(url, options);\n  }\n\n  /**\n   * Remove all models from the cache\n   */\n  async clear(): Promise<void> {\n    await this.cacheManager.clear();\n  }\n}\n", "import { ProxyToWorker } from './worker';\nimport {\n  absoluteUrl,\n  bufToText,\n  cbToAsyncIter,\n  checkEnvironmentCompatible,\n  isString,\n  isSupportMultiThread,\n  joinBuffers,\n  sortFileByShard,\n  isValidGgufFile,\n} from './utils';\nimport CacheManager, { type DownloadOptions } from './cache-manager';\nimport { ModelManager, Model } from './model-manager';\nimport type {\n  GlueMsgChatFormatRes,\n  GlueMsgDecodeRes,\n  GlueMsgDetokenizeRes,\n  GlueMsgGetEmbeddingsRes,\n  GlueMsgGetKvClearRes,\n  GlueMsgGetKvRemoveRes,\n  GlueMsgGetLogitsRes,\n  GlueMsgGetVocabRes,\n  GlueMsgLoadRes,\n  GlueMsgLookupTokenRes,\n  GlueMsgSamplingAcceptRes,\n  GlueMsgSamplingSampleRes,\n  GlueMsgSetOptionsRes,\n  GlueMsgStatusRes,\n  GlueMsgTestBenchmarkRes,\n  GlueMsgTestPerplexityRes,\n  GlueMsgTokenizeRes,\n} from './glue/messages';\nimport { LIBLLAMA_VERSION } from './workers-code/generated';\n\nconst HF_MODEL_ID_REGEX = /^([a-zA-Z0-9_\\-\\.]+)\\/([a-zA-Z0-9_\\-\\.]+)$/;\nconst HF_MODEL_ID_REGEX_EXPLAIN =\n  \"Hugging Face model ID is incorrect. Only regular alphanumeric characters, '-', '.' and '_' supported\";\n\nexport interface WllamaLogger {\n  debug: typeof console.debug;\n  log: typeof console.log;\n  warn: typeof console.warn;\n  error: typeof console.error;\n}\n\n// TODO: bring back useCache\nexport interface WllamaConfig {\n  /**\n   * If true, suppress all log messages from native CPP code\n   */\n  suppressNativeLog?: boolean;\n  /**\n   * Custom logger functions\n   */\n  logger?: WllamaLogger;\n  /**\n   * Maximum number of parallel files to be downloaded\n   *\n   * Default: parallelDownloads = 3\n   */\n  parallelDownloads?: number;\n  /**\n   * Allow offline mode. If true, the model will be loaded from cache if it's available.\n   *\n   * Default: allowOffline = false\n   */\n  allowOffline?: boolean;\n  /**\n   * Custom cache manager (only for advanced usage)\n   */\n  cacheManager?: CacheManager;\n  /**\n   * Custom model manager (only for advanced usage)\n   */\n  modelManager?: ModelManager;\n}\n\nexport interface WllamaChatMessage {\n  role: 'system' | 'user' | 'assistant';\n  content: string;\n}\n\nexport interface AssetsPathConfig {\n  'single-thread/wllama.wasm': string;\n  'multi-thread/wllama.wasm'?: string;\n}\n\nexport interface LoadModelConfig {\n  seed?: number;\n  n_ctx?: number;\n  n_batch?: number;\n  // by default, on multi-thread build, we take half number of available threads (hardwareConcurrency / 2)\n  n_threads?: number;\n  embeddings?: boolean;\n  offload_kqv?: boolean;\n  pooling_type?:\n    | 'LLAMA_POOLING_TYPE_UNSPECIFIED'\n    | 'LLAMA_POOLING_TYPE_NONE'\n    | 'LLAMA_POOLING_TYPE_MEAN'\n    | 'LLAMA_POOLING_TYPE_CLS';\n  // context extending\n  rope_scaling_type?:\n    | 'LLAMA_ROPE_SCALING_TYPE_UNSPECIFIED'\n    | 'LLAMA_ROPE_SCALING_TYPE_NONE'\n    | 'LLAMA_ROPE_SCALING_TYPE_LINEAR'\n    | 'LLAMA_ROPE_SCALING_TYPE_YARN';\n  rope_freq_base?: number;\n  rope_freq_scale?: number;\n  yarn_ext_factor?: number;\n  yarn_attn_factor?: number;\n  yarn_beta_fast?: number;\n  yarn_beta_slow?: number;\n  yarn_orig_ctx?: number;\n  // TODO: add group attention\n  // optimizations\n  cache_type_k?: 'f32' | 'f16' | 'q8_0' | 'q5_1' | 'q5_0' | 'q4_1' | 'q4_0';\n  cache_type_v?: 'f32' | 'f16' | 'q8_0' | 'q5_1' | 'q5_0' | 'q4_1' | 'q4_0';\n  flash_attn?: boolean; // true is auto, false is disabled\n}\n\nexport interface SamplingConfig {\n  // See sampling.h for more details\n  mirostat?: number | undefined; // 0 = disabled, 1 = mirostat, 2 = mirostat 2.0\n  mirostat_eta?: number | undefined;\n  mirostat_tau?: number | undefined;\n  samplers_sequence?: string[] | undefined; // unused for now\n  temp?: number | undefined; // temperature\n  top_p?: number | undefined;\n  top_k?: number | undefined;\n  penalty_last_n?: number | undefined;\n  penalty_repeat?: number | undefined;\n  penalty_freq?: number | undefined;\n  penalty_present?: number | undefined;\n  dynatemp_range?: number | undefined;\n  dynatemp_exponent?: number | undefined;\n  grammar?: string;\n  n_prev?: number | undefined;\n  n_probs?: number | undefined;\n  min_p?: number | undefined;\n  typ_p?: number | undefined;\n  typical_p?: number | undefined;\n  logit_bias?: { token: number; bias: number }[] | undefined;\n}\n\nexport interface CompletionChunk {\n  token: number;\n  piece: Uint8Array;\n  currentText: string;\n}\n\nexport interface CompletionOptions {\n  /**\n   * When processing input prompt, we don't need to get output tokens. Only used by llama_decode()\n   * Default: false\n   */\n  skipLogits?: boolean;\n  /**\n   * Optional abort signal to stop the generation.\n   * This can also be used to stop during prompt processing. In this case, it will throw WllamaAbortError.\n   */\n  abortSignal?: AbortSignal;\n  /**\n   * If true, return an AsyncIterable instead of a string\n   */\n  stream?: boolean;\n}\n\nexport interface ChatCompletionOptions {\n  nPredict?: number;\n  onNewToken?(\n    token: number,\n    piece: Uint8Array,\n    currentText: string,\n    optionals: {\n      /**\n       * DEPRECATED, use ChatCompletionOptions[\"abortSignal\"] instead\n       */\n      abortSignal: () => any;\n    }\n  ): any;\n  sampling?: SamplingConfig;\n  /**\n   * List of custom token IDs for stopping the generation.\n   * Note: To convert from text to token ID, use lookupToken()\n   */\n  stopTokens?: number[];\n  /**\n   * Equivalent to `cache_prompt` option in llama.cpp server.\n   * Useful for chat, because it skip evaluating the history part of the conversation.\n   */\n  useCache?: boolean;\n  /**\n   * Optional abort signal to stop the generation.\n   * This can also be used to stop during prompt processing (with a bit of delay.)\n   */\n  abortSignal?: AbortSignal;\n  /**\n   * If true, return an AsyncIterable instead of a string\n   */\n  stream?: boolean;\n}\n\nexport interface ModelMetadata {\n  hparams: {\n    nVocab: number;\n    nCtxTrain: number;\n    nEmbd: number;\n    nLayer: number;\n  };\n  meta: Record<string, string>;\n}\n\nexport interface ContextOptions {\n  /**\n   * Allow switching between embeddings / generation mode. Useful for models like GritLM.\n   */\n  embeddings: boolean;\n}\n\nexport interface LoadedContextInfo {\n  n_vocab: number;\n  n_ctx: number;\n  n_batch: number;\n  n_ubatch: number;\n  n_ctx_train: number;\n  n_embd: number;\n  n_layer: number;\n  metadata: Record<string, string>;\n  token_bos: number;\n  token_eos: number;\n  token_eot: number;\n  list_tokens_eog: number[];\n  has_encoder: boolean;\n  token_decoder_start: number;\n  add_bos_token: boolean;\n  add_eos_token: boolean;\n}\n\n/**\n * Logger preset with debug messages suppressed\n */\nexport const LoggerWithoutDebug = {\n  ...console,\n  debug: () => {},\n};\n\nexport type WllamaErrorType =\n  | 'model_not_loaded'\n  | 'download_error'\n  | 'load_error'\n  | 'kv_cache_full'\n  | 'unknown_error'\n  | 'inference_error';\n\nexport class WllamaError extends Error {\n  type: WllamaErrorType;\n  constructor(message: string, type: WllamaErrorType = 'unknown_error') {\n    super(message);\n    this.type = type;\n  }\n}\n\n/**\n * AbortError is thrown when the user wants to abort the current operation.\n * This is equivalent to AbortError in Fetch API.\n */\nexport class WllamaAbortError extends Error {\n  override name: string = 'AbortError';\n  constructor() {\n    super('Operation aborted');\n  }\n}\n\nexport class Wllama {\n  // The CacheManager and ModelManager are singleton, can be accessed by user\n  public cacheManager: CacheManager;\n  public modelManager: ModelManager;\n\n  private proxy: ProxyToWorker = null as any;\n  private config: WllamaConfig;\n  private pathConfig: AssetsPathConfig;\n  private useMultiThread: boolean = false;\n  private nbThreads: number = 1;\n  private useEmbeddings: boolean = false;\n  // available when loaded\n  private loadedContextInfo: LoadedContextInfo = null as any;\n  private bosToken: number = -1;\n  private eosToken: number = -1;\n  private eotToken: number = -1;\n  private eogTokens: Set<number> = new Set();\n  private addBosToken: boolean = false;\n  private addEosToken: boolean = false;\n  private chatTemplate?: string;\n  private metadata?: ModelMetadata;\n  private samplingConfig: SamplingConfig = {};\n  private hasEncoder: boolean = false;\n  private decoderStartToken: number = -1;\n  private nCachedTokens: number = 0;\n\n  constructor(pathConfig: AssetsPathConfig, wllamaConfig: WllamaConfig = {}) {\n    checkEnvironmentCompatible();\n    if (!pathConfig) throw new WllamaError('AssetsPathConfig is required');\n    this.pathConfig = pathConfig;\n    this.config = wllamaConfig;\n    this.cacheManager = wllamaConfig.cacheManager ?? new CacheManager();\n    this.modelManager =\n      wllamaConfig.modelManager ??\n      new ModelManager({\n        cacheManager: this.cacheManager,\n        logger: wllamaConfig.logger ?? console,\n        parallelDownloads: wllamaConfig.parallelDownloads,\n        allowOffline: wllamaConfig.allowOffline,\n      });\n  }\n\n  private logger() {\n    return this.config.logger ?? console;\n  }\n\n  private checkModelLoaded() {\n    if (!this.isModelLoaded()) {\n      throw new WllamaError(\n        'loadModel() is not yet called',\n        'model_not_loaded'\n      );\n    }\n  }\n\n  /**\n   * Get the libllama version string, e.g. \"b6327-4d74393\".\n   *\n   * @returns version string embedded at build time.\n   */\n  static getLibllamaVersion(): string {\n    return LIBLLAMA_VERSION;\n  }\n\n  /**\n   * Check if the model is loaded via `loadModel()`\n   */\n  isModelLoaded(): boolean {\n    return !!this.proxy && !!this.metadata;\n  }\n\n  /**\n   * Get token ID associated to BOS (begin of sentence) token.\n   *\n   * NOTE: This can only being used after `loadModel` is called.\n   *\n   * @returns -1 if the model is not loaded.\n   */\n  getBOS(): number {\n    return this.bosToken;\n  }\n\n  /**\n   * Get token ID associated to EOS (end of sentence) token.\n   *\n   * NOTE: This can only being used after `loadModel` is called.\n   *\n   * @returns -1 if the model is not loaded.\n   */\n  getEOS(): number {\n    return this.eosToken;\n  }\n\n  /**\n   * Get token ID associated to EOT (end of turn) token.\n   *\n   * NOTE: This can only being used after `loadModel` is called.\n   *\n   * @returns -1 if the model is not loaded.\n   */\n  getEOT(): number {\n    return this.eotToken;\n  }\n\n  /**\n   * Check if a given token is end-of-generation token (e.g. EOS, EOT, etc.)\n   *\n   * @param token the token ID to be checked\n   * @returns true if the token is EOS, EOT, or any other end-of-generation tokens\n   */\n  isTokenEOG(token: number): boolean {\n    return (\n      token === this.eosToken ||\n      token === this.eotToken ||\n      this.eogTokens.has(token)\n    );\n  }\n\n  /**\n   * Get token ID associated to token used by decoder, to start generating output sequence(only usable for encoder-decoder architecture). In other words, encoder uses normal BOS and decoder uses this token.\n   *\n   * NOTE: This can only being used after `loadModel` is called.\n   *\n   * @returns -1 if the model is not loaded.\n   */\n  getDecoderStartToken(): number {\n    return this.decoderStartToken;\n  }\n\n  /**\n   * Get model hyper-parameters and metadata\n   *\n   * NOTE: This can only being used after `loadModel` is called.\n   *\n   * @returns ModelMetadata\n   */\n  getModelMetadata(): ModelMetadata {\n    this.checkModelLoaded();\n    return this.metadata!;\n  }\n\n  /**\n   * Check if we're currently using multi-thread build.\n   *\n   * NOTE: This can only being used after `loadModel` is called.\n   *\n   * @returns true if multi-thread is used.\n   */\n  isMultithread(): boolean {\n    this.checkModelLoaded();\n    return this.useMultiThread;\n  }\n\n  /**\n   * Get number of threads used in the current context.\n   *\n   * NOTE: This can only being used after `loadModel` is called.\n   *\n   * @returns number of threads\n   */\n  getNumThreads(): number {\n    this.checkModelLoaded();\n    return this.useMultiThread ? this.nbThreads : 1;\n  }\n\n  /**\n   * Check if the current model uses encoder-decoder architecture\n   *\n   * NOTE: This can only being used after `loadModel` is called.\n   *\n   * @returns true if multi-thread is used.\n   */\n  isEncoderDecoderArchitecture(): boolean {\n    this.checkModelLoaded();\n    return this.hasEncoder;\n  }\n\n  /**\n   * Must we add BOS token to the tokenized sequence?\n   *\n   * NOTE: This can only being used after `loadModel` is called.\n   *\n   * @returns true if BOS token must be added to the sequence\n   */\n  mustAddBosToken(): boolean {\n    this.checkModelLoaded();\n    return this.addBosToken;\n  }\n\n  /**\n   * Must we add EOS token to the tokenized sequence?\n   *\n   * NOTE: This can only being used after `loadModel` is called.\n   *\n   * @returns true if EOS token must be added to the sequence\n   */\n  mustAddEosToken(): boolean {\n    this.checkModelLoaded();\n    return this.addEosToken;\n  }\n\n  /**\n   * Get the jinja chat template comes with the model. It only available if the original model (before converting to gguf) has the template in `tokenizer_config.json`\n   *\n   * NOTE: This can only being used after `loadModel` is called.\n   *\n   * @returns the jinja template. null if there is no template in gguf\n   */\n  getChatTemplate(): string | null {\n    this.checkModelLoaded();\n    return this.chatTemplate ?? null;\n  }\n\n  /**\n   * Load model from a given URL (or a list of URLs, in case the model is splitted into smaller files)\n   * - If the model already been downloaded (via `downloadModel()`), then we will use the cached model\n   * - Else, we download the model from internet\n   * @param modelUrl URL to the GGUF file. If the model is splitted, pass the URL to the first shard.\n   * @param config\n   */\n  async loadModelFromUrl(\n    modelUrl: string | string[],\n    config: LoadModelConfig & DownloadOptions & { useCache?: boolean } = {}\n  ): Promise<void> {\n    const url: string = isString(modelUrl) ? (modelUrl as string) : modelUrl[0];\n    const useCache = config.useCache ?? true;\n    const model = useCache\n      ? await this.modelManager.getModelOrDownload(url, config)\n      : await this.modelManager.downloadModel(url, config);\n    const blobs = await model.open();\n    return await this.loadModel(blobs, config);\n  }\n\n  /**\n   * Load model from a given Hugging Face model ID and file path.\n   *\n   * @param modelId The HF model ID, for example: 'ggml-org/models'\n   * @param filePath The GGUF file path, for example: 'tinyllamas/stories15M-q4_0.gguf'\n   * @param config\n   */\n  async loadModelFromHF(\n    modelId: string,\n    filePath: string,\n    config: LoadModelConfig & DownloadOptions & { useCache?: boolean } = {}\n  ) {\n    if (!modelId.match(HF_MODEL_ID_REGEX)) {\n      throw new WllamaError(HF_MODEL_ID_REGEX_EXPLAIN, 'download_error');\n    }\n    if (!isValidGgufFile(filePath)) {\n      throw new WllamaError('Only GGUF file is supported', 'download_error');\n    }\n    return await this.loadModelFromUrl(\n      `https://huggingface.co/${modelId}/resolve/main/${filePath}`,\n      config\n    );\n  }\n\n  /**\n   * Load model from a given list of Blob.\n   *\n   * You can pass multiple buffers into the function (in case the model contains multiple shards).\n   *\n   * @param ggufBlobsOrModel Can be either list of Blobs (in case you use local file), or a Model object (in case you use ModelManager)\n   * @param config LoadModelConfig\n   */\n  async loadModel(\n    ggufBlobsOrModel: Blob[] | Model,\n    config: LoadModelConfig = {}\n  ): Promise<void> {\n    const blobs: Blob[] =\n      ggufBlobsOrModel instanceof Model\n        ? await ggufBlobsOrModel.open()\n        : [...(ggufBlobsOrModel as Blob[])]; // copy array\n    if (blobs.some((b) => b.size === 0)) {\n      throw new WllamaError(\n        'Input model (or splits) must be non-empty Blob or File',\n        'load_error'\n      );\n    }\n    sortFileByShard(blobs);\n    if (this.proxy) {\n      throw new WllamaError('Module is already initialized', 'load_error');\n    }\n    // detect if we can use multi-thread\n    const supportMultiThread = await isSupportMultiThread();\n    if (!supportMultiThread) {\n      this.logger().warn(\n        'Multi-threads are not supported in this environment, falling back to single-thread'\n      );\n    }\n    const hasPathMultiThread = !!this.pathConfig['multi-thread/wllama.wasm'];\n    if (!hasPathMultiThread) {\n      this.logger().warn(\n        'Missing paths to \"multi-thread/wllama.wasm\", falling back to single-thread'\n      );\n    }\n    const hwConccurency = Math.floor((navigator.hardwareConcurrency || 1) / 2);\n    const nbThreads = config.n_threads ?? hwConccurency;\n    this.nbThreads = nbThreads;\n    this.useMultiThread =\n      supportMultiThread && hasPathMultiThread && nbThreads > 1;\n    const mPathConfig = this.useMultiThread\n      ? {\n          'wllama.wasm': absoluteUrl(\n            this.pathConfig['multi-thread/wllama.wasm']!!\n          ),\n        }\n      : {\n          'wllama.wasm': absoluteUrl(\n            this.pathConfig['single-thread/wllama.wasm']\n          ),\n        };\n    this.proxy = new ProxyToWorker(\n      mPathConfig,\n      this.useMultiThread ? nbThreads : 1,\n      this.config.suppressNativeLog ?? false,\n      this.logger()\n    );\n    const modelFiles = blobs.map((blob, i) => ({\n      name: `model-${i}.gguf`,\n      blob,\n    }));\n    await this.proxy.moduleInit(modelFiles);\n    // run it\n    const startResult: any = await this.proxy.wllamaStart();\n    if (!startResult.success) {\n      throw new WllamaError(\n        `Error while calling start function, result = ${startResult}`\n      );\n    }\n    // load the model\n    const loadResult: GlueMsgLoadRes = await this.proxy.wllamaAction('load', {\n      _name: 'load_req',\n      use_mmap: true,\n      use_mlock: true,\n      n_gpu_layers: 0, // not supported for now\n      seed: config.seed || Math.floor(Math.random() * 100000),\n      n_ctx: config.n_ctx || 1024,\n      n_threads: this.useMultiThread ? nbThreads : 1,\n      n_ctx_auto: false, // not supported for now\n      model_paths: modelFiles.map((f) => `models/${f.name}`),\n      embeddings: config.embeddings,\n      offload_kqv: config.offload_kqv,\n      n_batch: config.n_batch,\n      pooling_type: config.pooling_type as string,\n      rope_scaling_type: config.rope_scaling_type as string,\n      rope_freq_base: config.rope_freq_base,\n      rope_freq_scale: config.rope_freq_scale,\n      yarn_ext_factor: config.yarn_ext_factor,\n      yarn_attn_factor: config.yarn_attn_factor,\n      yarn_beta_fast: config.yarn_beta_fast,\n      yarn_beta_slow: config.yarn_beta_slow,\n      yarn_orig_ctx: config.yarn_orig_ctx,\n      cache_type_k: config.cache_type_k as string,\n      cache_type_v: config.cache_type_v as string,\n      n_seq_max: 1, // only support single sequence for now\n      flash_attn: config.flash_attn,\n      swa_full: true, // TODO: properly support SWA\n    });\n    const loadedCtxInfo: LoadedContextInfo = {\n      ...loadResult,\n      metadata: {},\n    };\n    for (let i = 0; i < loadResult.metadata_key.length; i++) {\n      loadedCtxInfo.metadata[loadResult.metadata_key[i]] =\n        loadResult.metadata_val[i];\n    }\n    this.bosToken = loadedCtxInfo.token_bos;\n    this.eosToken = loadedCtxInfo.token_eos;\n    this.eotToken = loadedCtxInfo.token_eot;\n    this.useEmbeddings = !!config.embeddings;\n    this.metadata = {\n      hparams: {\n        nVocab: loadedCtxInfo.n_vocab,\n        nCtxTrain: loadedCtxInfo.n_ctx_train,\n        nEmbd: loadedCtxInfo.n_embd,\n        nLayer: loadedCtxInfo.n_layer,\n      },\n      meta: loadedCtxInfo.metadata,\n    };\n    this.hasEncoder = !!loadedCtxInfo.has_encoder;\n    this.decoderStartToken = loadedCtxInfo.token_decoder_start;\n    this.addBosToken = loadedCtxInfo.add_bos_token;\n    this.addEosToken = loadedCtxInfo.add_eos_token;\n    this.chatTemplate = loadedCtxInfo.metadata['tokenizer.chat_template'];\n    this.loadedContextInfo = loadedCtxInfo;\n    this.eogTokens = new Set(loadedCtxInfo.list_tokens_eog);\n    this.logger().debug({ loadedCtxInfo });\n  }\n\n  getLoadedContextInfo(): LoadedContextInfo {\n    this.checkModelLoaded();\n    if (!this.loadedContextInfo) {\n      throw new WllamaError('Loaded context info is not available');\n    }\n    // copy object\n    return { ...this.loadedContextInfo };\n  }\n\n  //////////////////////////////////////////////\n  // High level API\n\n  /**\n   * Calculate embedding vector for a given text.\n   * By default, BOS and EOS tokens will be added automatically. You can use the \"skipBOS\" and \"skipEOS\" option to disable it.\n   * @param text Input text\n   * @returns An embedding vector\n   */\n  async createEmbedding(\n    text: string,\n    options: {\n      skipBOS?: boolean;\n      skipEOS?: boolean;\n    } = {}\n  ): Promise<number[]> {\n    this.checkModelLoaded();\n    const opt = {\n      skipBOS: false,\n      skipEOS: false,\n      ...options,\n    };\n    await this.samplingInit(this.samplingConfig);\n    await this.kvClear();\n    const tokens = await this.tokenize(text);\n    if (this.bosToken && !opt.skipBOS) {\n      tokens.unshift(this.bosToken);\n    }\n    if (this.eosToken && !opt.skipEOS) {\n      tokens.push(this.eosToken);\n    }\n    const result = await this.embeddings(tokens);\n    return result;\n  }\n\n  /**\n   * Make completion for a given chat messages.\n   *\n   * NOTE: this function uses the chat template (if available) to format the chat messages. If the template is not available, it will use the default format (chatml). It can throw an error if the chat template is not compatible.\n   *\n   * @param messages Chat messages\n   * @param options\n   * @returns Output completion text (only the completion part)\n   */\n  async createChatCompletion(\n    messages: WllamaChatMessage[],\n    options: ChatCompletionOptions & { stream?: false }\n  ): Promise<string>;\n  async createChatCompletion(\n    messages: WllamaChatMessage[],\n    options: ChatCompletionOptions & { stream: true }\n  ): Promise<AsyncIterable<CompletionChunk>>;\n  async createChatCompletion(\n    messages: WllamaChatMessage[],\n    options: ChatCompletionOptions\n  ): Promise<string | AsyncIterable<CompletionChunk>> {\n    const prompt = await this.formatChat(messages, true);\n    return options.stream\n      ? await this.createCompletionGenerator(prompt, options)\n      : await this.createCompletion(prompt, { ...options, stream: false });\n  }\n\n  /**\n   * Make completion for a given text.\n   * @param prompt Input text\n   * @param options\n   * @returns Output completion text (only the completion part)\n   */\n  async createCompletion(\n    prompt: string,\n    options: ChatCompletionOptions & { stream?: false }\n  ): Promise<string>;\n  async createCompletion(\n    prompt: string,\n    options: ChatCompletionOptions & { stream: true }\n  ): Promise<AsyncIterable<CompletionChunk>>;\n  async createCompletion(\n    prompt: string,\n    options: ChatCompletionOptions\n  ): Promise<string | AsyncIterable<CompletionChunk>> {\n    return options.stream\n      ? await this.createCompletionGenerator(prompt, options)\n      : await this.createCompletionImpl(prompt, { ...options, stream: false });\n  }\n\n  /**\n   * Private implementation of createCompletion\n   */\n  private async createCompletionImpl(\n    prompt: string,\n    options: ChatCompletionOptions\n  ): Promise<string> {\n    this.checkModelLoaded();\n    this.samplingConfig = options.sampling ?? {};\n    await this.samplingInit(this.samplingConfig);\n    const stopTokens = new Set(options.stopTokens ?? []);\n    // process prompt\n    let tokens = await this.tokenize(prompt, true);\n    if (this.addBosToken && tokens[0] !== this.bosToken) {\n      tokens.unshift(this.bosToken);\n    }\n    // maybe reuse KV cache\n    if (options.useCache) {\n      tokens = await this.computeNonCachedTokens(tokens);\n    } else {\n      await this.kvClear();\n    }\n    // decode/encode tokens\n    await this.samplingAccept(tokens);\n    if (this.isEncoderDecoderArchitecture()) {\n      await this.encode(tokens);\n      await this.decode([this.getDecoderStartToken()], {});\n    } else {\n      await this.decode(tokens, {});\n    }\n    let outBuf = new Uint8Array();\n    // abort signal\n    let abort = false;\n    // abortSignalFn is a legacy function, use options.abortSignal instead\n    const abortSignalFn = () => {\n      abort = true;\n    };\n    // predict next tokens\n    for (let i = 0; i < (options.nPredict ?? Infinity); i++) {\n      const sampled = await this.samplingSample();\n      if (this.isTokenEOG(sampled.token) || stopTokens.has(sampled.token)) {\n        break; // stop token\n      }\n      // @ts-ignore Type 'Uint8Array<ArrayBufferLike>' is not assignable to type 'Uint8Array<ArrayBuffer>'\n      outBuf = joinBuffers([outBuf, sampled.piece]);\n      if (options.onNewToken) {\n        options.onNewToken(sampled.token, sampled.piece, bufToText(outBuf), {\n          abortSignal: abortSignalFn, // legacy\n        });\n      }\n      if (abort || options.abortSignal?.aborted) {\n        break; // abort signal is set\n      }\n      // decode next token\n      await this.samplingAccept([sampled.token]);\n      await this.decode([sampled.token], {});\n    }\n    return bufToText(outBuf);\n  }\n\n  /**\n   * Same with `createCompletion`, but returns an async iterator instead.\n   */\n  private createCompletionGenerator(\n    prompt: string,\n    options: Exclude<ChatCompletionOptions, 'onNewToken'>\n  ): Promise<AsyncIterable<CompletionChunk>> {\n    return new Promise((resolve, reject) => {\n      const createGenerator = cbToAsyncIter(\n        (callback: (val?: CompletionChunk, done?: boolean) => void) => {\n          this.createCompletionImpl(prompt, {\n            ...options,\n            onNewToken: (token, piece, currentText) => {\n              callback({ token, piece, currentText }, false);\n            },\n          })\n            .catch(reject)\n            .then(() => {\n              callback(undefined, true);\n            });\n        }\n      );\n      resolve(createGenerator());\n    });\n  }\n\n  //////////////////////////////////////////////\n  // Low level API\n\n  /**\n   * Create or reset the ctx_sampling\n   * @param config\n   * @param pastTokens In case re-initializing the ctx_sampling, you can re-import past tokens into the new context\n   */\n  async samplingInit(\n    config: SamplingConfig,\n    pastTokens: number[] = []\n  ): Promise<void> {\n    this.checkModelLoaded();\n    this.samplingConfig = config;\n    const logitBias = config.logit_bias ?? [];\n    const logitBiasTok = logitBias.map((b) => b.token);\n    const logitBiasVal = logitBias.map((b) => b.bias);\n    const result = await this.proxy.wllamaAction<GlueMsgSamplingAcceptRes>(\n      'sampling_init',\n      {\n        _name: 'sint_req',\n        ...config,\n        logit_bias_toks: logitBiasTok,\n        logit_bias_vals: logitBiasVal,\n        tokens: pastTokens,\n      }\n    );\n    if (!result.success) {\n      throw new WllamaError('Failed to initialize sampling');\n    }\n  }\n\n  /**\n   * Get a list of pieces in vocab.\n   * NOTE: This function is slow, should only be used once.\n   * @returns A list of Uint8Array. The nth element in the list associated to nth token in vocab\n   */\n  async getVocab(): Promise<Uint8Array[]> {\n    this.checkModelLoaded();\n    const result = await this.proxy.wllamaAction<GlueMsgGetVocabRes>(\n      'get_vocab',\n      {\n        _name: 'gvoc_req',\n      }\n    );\n    return result.vocab;\n  }\n\n  /**\n   * Lookup to see if a token exist in vocab or not. Useful for searching special tokens like \"<|im_start|>\"\n   * NOTE: It will match the whole token, so do not use it as a replacement for tokenize()\n   * @param piece\n   * @returns Token ID associated to the given piece. Returns -1 if cannot find the token.\n   */\n  async lookupToken(piece: string): Promise<number> {\n    this.checkModelLoaded();\n    const result = await this.proxy.wllamaAction<GlueMsgLookupTokenRes>(\n      'lookup_token',\n      {\n        _name: 'lkup_req',\n        piece,\n      }\n    );\n    if (!result.success) {\n      return -1;\n    } else {\n      return result.token as number;\n    }\n  }\n\n  /**\n   * Convert a given text to list of tokens\n   * @param text\n   * @param special Should split special tokens?\n   * @returns List of token ID\n   */\n  async tokenize(text: string, special: boolean = true): Promise<number[]> {\n    this.checkModelLoaded();\n    const result = await this.proxy.wllamaAction<GlueMsgTokenizeRes>(\n      'tokenize',\n      {\n        _name: 'tokn_req',\n        text,\n        special: !!special,\n      }\n    );\n    return result.tokens;\n  }\n\n  /**\n   * Convert a list of tokens to text\n   * @param tokens\n   * @param returnString Return a string instead of Uint8Array\n   * @returns Uint8Array, which maybe an unfinished unicode\n   */\n  async detokenize(tokens: number[], returnString?: false): Promise<Uint8Array>;\n  async detokenize(tokens: number[], returnString: true): Promise<string>;\n  async detokenize(\n    tokens: number[],\n    returnString: true | false = false\n  ): Promise<Uint8Array | string> {\n    this.checkModelLoaded();\n    const result = await this.proxy.wllamaAction<GlueMsgDetokenizeRes>(\n      'detokenize',\n      {\n        _name: 'dtkn_req',\n        tokens,\n      }\n    );\n    return returnString ? bufToText(result.buffer) : result.buffer;\n  }\n\n  /**\n   * Run llama_decode()\n   * @param tokens A list of tokens to be decoded\n   * @param options Additional options\n   * @returns n_past (number of tokens so far in the sequence)\n   */\n  async decode(\n    tokens: number[],\n    options: CompletionOptions\n  ): Promise<{ nPast: number }> {\n    this.checkModelLoaded();\n    if (this.useEmbeddings) {\n      throw new WllamaError(\n        'embeddings is enabled. Use wllama.setOptions({ embeddings: false }) to disable it.'\n      );\n    }\n    if (tokens.length === 0) {\n      // do not call llama_decode if list of tokens is empty\n      return {\n        nPast: this.nCachedTokens,\n      };\n    }\n    if (this.nCachedTokens + tokens.length > this.loadedContextInfo.n_ctx) {\n      throw new WllamaError(\n        'Running out of context cache. Please increase n_ctx when loading the model',\n        'kv_cache_full'\n      );\n    }\n    const batches = this.breakTokensIntoBatches(\n      tokens,\n      this.loadedContextInfo.n_batch\n    );\n    let result: any;\n    for (let i = 0; i < batches.length; i++) {\n      if (options?.abortSignal?.aborted) {\n        throw new WllamaAbortError();\n      }\n      const isNotLast = batches.length > 1 && i < batches.length - 1;\n      result = await this.proxy.wllamaAction<GlueMsgDecodeRes>('decode', {\n        _name: 'deco_req',\n        tokens: batches[i],\n        skip_logits: options.skipLogits || isNotLast,\n      });\n      if (result.error) {\n        throw new WllamaError(result.error);\n      } else if (!result.success) {\n        throw new WllamaError('Cannot encode, unknown error');\n      }\n    }\n    this.nCachedTokens = result.n_past;\n    return { nPast: result.n_past };\n  }\n\n  /**\n   * Run llama_encode()\n   * @param tokens A list of tokens to be encoded\n   * @param options Additional options\n   * @returns n_past (number of tokens so far in the sequence)\n   */\n  async encode(\n    tokens: number[],\n    options?: CompletionOptions\n  ): Promise<{ nPast: number }> {\n    this.checkModelLoaded();\n    if (!this.hasEncoder) {\n      throw new WllamaError(\n        'This model does not use encoder-decoder architecture.',\n        'inference_error'\n      );\n    }\n    if (this.useEmbeddings) {\n      throw new WllamaError(\n        'embeddings is enabled. Use wllama.setOptions({ embeddings: false }) to disable it.',\n        'inference_error'\n      );\n    }\n    if (tokens.length === 0) {\n      // do not call llama_encode if list of tokens is empty\n      return {\n        nPast: this.nCachedTokens,\n      };\n    }\n    if (this.nCachedTokens + tokens.length > this.loadedContextInfo.n_ctx) {\n      throw new WllamaError(\n        'Running out of context cache. Please increase n_ctx when loading the model',\n        'kv_cache_full'\n      );\n    }\n    const batches = this.breakTokensIntoBatches(\n      tokens,\n      this.loadedContextInfo.n_batch\n    );\n    let result: any;\n    for (let i = 0; i < batches.length; i++) {\n      if (options?.abortSignal?.aborted) {\n        throw new WllamaAbortError();\n      }\n      result = await this.proxy.wllamaAction<GlueMsgDecodeRes>('encode', {\n        _name: 'enco_req',\n        tokens: batches[i],\n      });\n      if (result.error) {\n        throw new WllamaError(result.error);\n      } else if (!result.success) {\n        throw new WllamaError('Cannot encode, unknown error');\n      }\n    }\n    this.nCachedTokens = result.n_past;\n    return { nPast: result.n_past };\n  }\n\n  private breakTokensIntoBatches(\n    tokens: number[],\n    maxBatchSize: number\n  ): number[][] {\n    const batches: number[][] = [];\n    for (let i = 0; i < tokens.length; i += maxBatchSize) {\n      batches.push(tokens.slice(i, i + maxBatchSize));\n    }\n    return batches;\n  }\n\n  /**\n   * Sample a new token (remember to samplingInit() at least once before calling this function)\n   * @returns the token ID and its detokenized value (which maybe an unfinished unicode)\n   */\n  async samplingSample(): Promise<{ piece: Uint8Array; token: number }> {\n    this.checkModelLoaded();\n    const result = await this.proxy.wllamaAction<GlueMsgSamplingSampleRes>(\n      'sampling_sample',\n      {\n        _name: 'ssam_req',\n      }\n    );\n    return {\n      piece: result.piece,\n      token: result.token,\n    };\n  }\n\n  /**\n   * Accept and save a new token to ctx_sampling\n   * @param tokens\n   */\n  async samplingAccept(tokens: number[]): Promise<void> {\n    this.checkModelLoaded();\n    const result = await this.proxy.wllamaAction<GlueMsgSamplingAcceptRes>(\n      'sampling_accept',\n      {\n        _name: 'sacc_req',\n        tokens,\n      }\n    );\n    if (!result.success) {\n      throw new WllamaError('samplingAccept unknown error');\n    }\n  }\n\n  /**\n   * Get softmax-ed probability of logits, can be used for custom sampling\n   * @param topK Get top K tokens having highest logits value. If topK == -1, we return all n_vocab logits, but this is not recommended because it's slow.\n   */\n  async getLogits(topK: number = 40): Promise<{ token: number; p: number }[]> {\n    this.checkModelLoaded();\n    const result = await this.proxy.wllamaAction<GlueMsgGetLogitsRes>(\n      'get_logits',\n      {\n        _name: 'glog_req',\n        top_k: topK,\n      }\n    );\n    const logits: { token: number; p: number }[] = [];\n    for (let i = 0; i < result.tokens.length; i++) {\n      logits.push({\n        token: result.tokens[i],\n        p: result.probs[i],\n      });\n    }\n    return logits;\n  }\n\n  /**\n   * Calculate embeddings for a given list of tokens. Output vector is always normalized\n   * @param tokens\n   * @returns A list of number represents an embedding vector of N dimensions\n   */\n  async embeddings(tokens: number[]): Promise<number[]> {\n    this.checkModelLoaded();\n    if (!this.useEmbeddings) {\n      throw new WllamaError(\n        'embeddings is disabled. Use wllama.setOptions({ embeddings: true }) to enable it.',\n        'inference_error'\n      );\n    }\n    if (this.nCachedTokens > 0) {\n      this.logger().warn(\n        'Embeddings: KV cache is not empty, this may produce incorrect results'\n      );\n    }\n    if (this.nCachedTokens + tokens.length > this.loadedContextInfo.n_ctx) {\n      throw new WllamaError(\n        'Running out of context cache. Please increase n_ctx when loading the model',\n        'kv_cache_full'\n      );\n    }\n    if (tokens.length > this.loadedContextInfo.n_batch) {\n      throw new WllamaError(\n        'Embedding tokens does not fit into batch. Please increase n_batch when loading the model',\n        'inference_error'\n      );\n    }\n    if (tokens.length > this.loadedContextInfo.n_ubatch) {\n      throw new WllamaError(\n        'Embedding tokens does not fit into physical batch. Please increase n_ubatch when loading the model',\n        'inference_error'\n      );\n    }\n    const result = await this.proxy.wllamaAction<GlueMsgGetEmbeddingsRes>(\n      'embeddings',\n      {\n        _name: 'gemb_req',\n        tokens,\n      }\n    );\n    if (!result.success) {\n      throw new WllamaError('embeddings unknown error');\n    } else {\n      return result.embeddings;\n    }\n  }\n\n  /**\n   * Remove and shift some tokens from KV cache.\n   * Keep n_keep, remove n_discard then shift the rest\n   * @param nKeep\n   * @param nDiscard\n   */\n  async kvRemove(nKeep: number, nDiscard: number): Promise<void> {\n    this.checkModelLoaded();\n    if (nDiscard === 0) return;\n    const result = await this.proxy.wllamaAction<GlueMsgGetKvRemoveRes>(\n      'kv_remove',\n      {\n        _name: 'kvcr_req',\n        n_keep: nKeep,\n        n_discard: nDiscard,\n      }\n    );\n    if (!result.success) {\n      throw new WllamaError('kvRemove unknown error');\n    }\n    // When nDiscard is negative (-1), it means remove everything after nKeep\n    if (nDiscard < 0) {\n      this.nCachedTokens = nKeep;\n    } else {\n      this.nCachedTokens -= nDiscard;\n    }\n  }\n\n  /**\n   * Clear all tokens in KV cache\n   */\n  async kvClear(): Promise<void> {\n    this.checkModelLoaded();\n    const result = await this.proxy.wllamaAction<GlueMsgGetKvClearRes>(\n      'kv_clear',\n      {\n        _name: 'kvcc_req',\n      }\n    );\n    if (!result.success) {\n      throw new WllamaError('kvClear unknown error');\n    }\n    this.nCachedTokens = 0;\n  }\n\n  /**\n   * Save session to file (virtual file system)\n   * TODO: add ability to download the file\n   * @param filePath\n   * @returns List of tokens saved to the file\n   */\n  // async sessionSave(filePath: string): Promise<{ tokens: number[] }> {\n  //   this.checkModelLoaded();\n  //   const result = await this.proxy.wllamaAction('session_save', {\n  //     session_path: filePath,\n  //   });\n  //   return result;\n  // }\n\n  /**\n   * Load session from file (virtual file system)\n   * TODO: add ability to download the file\n   * @param filePath\n   */\n  // async sessionLoad(filePath: string): Promise<void> {\n  //   this.checkModelLoaded();\n  //   const result = await this.proxy.wllamaAction('session_load', {\n  //     session_path: filePath,\n  //   });\n  //   if (result.error) {\n  //     throw new WllamaError(result.error);\n  //   } else if (!result.success) {\n  //     throw new WllamaError('sessionLoad unknown error');\n  //   }\n  //   const cachedTokens = await this.getCachedTokens();\n  //   this.nCachedTokens = cachedTokens.length;\n  // }\n\n  /**\n   * Apply chat template to a list of messages\n   *\n   * @param messages list of messages\n   * @param addAssistant whether to add assistant prompt at the end\n   * @param template (optional) custom template, see llama-server --chat-template argument for more details\n   * @returns formatted chat\n   */\n  async formatChat(\n    messages: WllamaChatMessage[],\n    addAssistant: boolean,\n    template?: string\n  ): Promise<string> {\n    this.checkModelLoaded();\n    const roles = messages.map((m) => m.role);\n    const contents = messages.map((m) => m.content);\n    const result = await this.proxy.wllamaAction<GlueMsgChatFormatRes>(\n      'chat_format',\n      {\n        _name: 'cfmt_req',\n        roles,\n        contents,\n        tmpl: template,\n        add_ass: addAssistant,\n      }\n    );\n    if (!result.success) {\n      throw new WllamaError('formatChat unknown error');\n    }\n    return result.formatted_chat;\n  }\n\n  /**\n   * Set options for underlaying llama_context\n   */\n  async setOptions(opt: ContextOptions): Promise<void> {\n    this.checkModelLoaded();\n    await this.proxy.wllamaAction<GlueMsgSetOptionsRes>('set_options', {\n      _name: 'opti_req',\n      ...opt,\n    });\n    this.useEmbeddings = opt.embeddings;\n  }\n\n  /**\n   * Unload the model and free all memory.\n   *\n   * Note: This function will NOT crash if model is not yet loaded\n   */\n  async exit(): Promise<void> {\n    await this.proxy?.wllamaExit();\n    this.proxy = null as any;\n  }\n\n  /**\n   * get debug info\n   */\n  async _getDebugInfo(): Promise<any> {\n    this.checkModelLoaded();\n    return await this.proxy.wllamaDebug();\n  }\n\n  /**\n   * benchmark function, only used internally\n   */\n  async _testBenchmark(\n    type: 'tg' | 'pp',\n    nSamples: number\n  ): Promise<{ t_ms: number }> {\n    this.checkModelLoaded();\n    return await this.proxy.wllamaAction<GlueMsgTestBenchmarkRes>(\n      'test_benchmark',\n      {\n        _name: 'tben_req',\n        type,\n        n_samples: nSamples,\n      }\n    );\n  }\n\n  /**\n   * perplexity function, only used internally\n   */\n  async _testPerplexity(tokens: number[]): Promise<{ ppl: number }> {\n    this.checkModelLoaded();\n    return await this.proxy.wllamaAction<GlueMsgTestPerplexityRes>(\n      'test_perplexity',\n      {\n        _name: 'tper_req',\n        tokens,\n      }\n    );\n  }\n\n  ///// Prompt cache utils /////\n  private async getCachedTokens(): Promise<number[]> {\n    this.checkModelLoaded();\n    const result = await this.proxy.wllamaAction<GlueMsgStatusRes>(\n      'current_status',\n      {\n        _name: 'stat_req',\n      }\n    );\n    return result.tokens;\n  }\n\n  /**\n   * Compare the input sequence and cachedToken, then return the part that is not in cache.\n   * This function also remove mismatch part in cache (via kvRemove)\n   */\n  private async computeNonCachedTokens(seq: number[]): Promise<number[]> {\n    const cachedTokens = await this.getCachedTokens();\n    let nKeep = 0;\n    for (; nKeep < Math.min(cachedTokens.length, seq.length); nKeep++) {\n      if (cachedTokens[nKeep] !== seq[nKeep]) {\n        break;\n      }\n    }\n    this.logger().debug(`Cache nKeep=${nKeep}`);\n    try {\n      await this.kvRemove(nKeep, -1);\n      return seq.slice(nKeep, seq.length);\n    } catch (e) {\n      this.logger().warn('Failed to rollback KV cache, clearing it instead');\n      await this.kvClear();\n      return seq;\n    }\n  }\n\n  // TODO: add current_status\n}\n", "/**\n * TEA WASM LLM - Internal wllama Loader\n *\n * This module loads wllama internally, eliminating the need for external\n * npm dependencies. The wllama WASM files are bundled as static assets.\n *\n * Architecture:\n * - wllama WASM files are copied to assets/ during build\n * - This loader initializes wllama with the bundled assets\n * - Auto-detects single-thread vs multi-thread support\n * - Provides simplified API: initLlm, chat, embed, chatStream\n */\n\n// @ts-expect-error - wllama types may not be perfect\nimport { Wllama } from '@wllama/wllama';\n\n// Type for wllama configuration - defined locally to avoid type import issues\ninterface WllamaConfig {\n  n_threads?: number;\n  [key: string]: unknown;\n}\n\nimport {\n  loadBundledModel,\n  type BundledModelConfig,\n} from './model-loader';\n\nimport {\n  getCacheStats,\n  clearCache,\n  type CacheStats,\n} from './model-cache';\n\n/**\n * Wllama configuration paths for bundled WASM files\n * These files are copied to the package during build\n */\nexport interface WllamaAssetPaths {\n  'single-thread/wllama.wasm': string;\n  'multi-thread/wllama.wasm': string;\n}\n\n/**\n * Default asset paths relative to package root\n */\nexport function getDefaultAssetPaths(basePath: string = '.'): WllamaAssetPaths {\n  return {\n    'single-thread/wllama.wasm': `${basePath}/assets/single-thread/wllama.wasm`,\n    'multi-thread/wllama.wasm': `${basePath}/assets/multi-thread/wllama.wasm`,\n  };\n}\n\n/**\n * LLM initialization configuration\n */\nexport interface InitLlmConfig {\n  /** URL or path to the GGUF model file */\n  modelUrl?: string;\n\n  /** Base path for model files (used with manifest) */\n  modelBasePath?: string;\n\n  /** Progress callback during model download */\n  onProgress?: (loaded: number, total: number) => void;\n\n  /** Callback when LLM is ready */\n  onReady?: () => void;\n\n  /** Use IndexedDB cache for model (default: true) */\n  useCache?: boolean;\n\n  /** Force single-thread mode (default: auto-detect) */\n  singleThread?: boolean;\n\n  /** Number of threads to use (default: auto) */\n  nThreads?: number;\n\n  /** Number of GPU layers (-1 = auto, 0 = CPU only) */\n  nGpuLayers?: number;\n\n  /** Context size (default: 2048) */\n  nCtx?: number;\n\n  /** Verbose logging */\n  verbose?: boolean;\n\n  /** Custom asset paths for wllama WASM files */\n  assetPaths?: WllamaAssetPaths;\n\n  /** Use CDN for wllama WASM files instead of bundled */\n  useCdn?: boolean;\n}\n\n/**\n * Chat completion options\n */\nexport interface ChatOptions {\n  /** Maximum tokens to generate (default: 100) */\n  maxTokens?: number;\n\n  /** Temperature (0.0 - 2.0, default: 0.7) */\n  temperature?: number;\n\n  /** Top-p nucleus sampling (default: 0.9) */\n  topP?: number;\n\n  /** Top-k sampling (0 = disabled) */\n  topK?: number;\n\n  /** Stop sequences */\n  stop?: string[];\n\n  /** System prompt */\n  system?: string;\n}\n\n/**\n * Chat response\n */\nexport interface ChatResponse {\n  /** Generated text content */\n  content: string;\n\n  /** Token usage statistics */\n  usage?: {\n    promptTokens: number;\n    completionTokens: number;\n    totalTokens: number;\n  };\n}\n\n/**\n * Embedding response\n */\nexport interface EmbedResponse {\n  /** Embedding vector */\n  vector: Float32Array;\n\n  /** Dimension of the embedding */\n  dimension: number;\n}\n\n/**\n * Token callback for streaming\n */\nexport type TokenCallback = (token: string) => void;\n\n// Global wllama instance\nlet wllamaInstance: Wllama | null = null;\nlet isInitialized = false;\nlet modelLoaded = false;\n\n/**\n * Get CDN paths for wllama WASM files\n * Uses jsDelivr CDN with the @wllama/wllama package\n */\nfunction getCdnPaths(): WllamaAssetPaths {\n  const CDN_BASE = 'https://cdn.jsdelivr.net/npm/@wllama/wllama/esm';\n  return {\n    'single-thread/wllama.wasm': `${CDN_BASE}/single-thread/wllama.wasm`,\n    'multi-thread/wllama.wasm': `${CDN_BASE}/multi-thread/wllama.wasm`,\n  };\n}\n\n/**\n * Check if SharedArrayBuffer is available (for multi-threading)\n */\nexport function hasSharedArrayBuffer(): boolean {\n  try {\n    return typeof SharedArrayBuffer !== 'undefined';\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Check if COOP/COEP headers are properly set for multi-threading\n */\nexport function hasCoopCoep(): boolean {\n  try {\n    // Check if we can use SharedArrayBuffer\n    if (!hasSharedArrayBuffer()) return false;\n\n    // Try to actually create a SharedArrayBuffer\n    new SharedArrayBuffer(1);\n    return true;\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Initialize the bundled LLM engine\n *\n * This function:\n * 1. Loads the bundled wllama WASM files\n * 2. Downloads/caches the model from modelUrl\n * 3. Initializes wllama with the model\n *\n * @example\n * ```typescript\n * await initLlm({\n *   modelUrl: 'https://huggingface.co/.../Phi-4-mini-Q3_K_S.gguf',\n *   onProgress: (loaded, total) => console.log(`${loaded}/${total}`),\n *   onReady: () => console.log('Ready!'),\n * });\n * ```\n */\nexport async function initLlm(config: InitLlmConfig = {}): Promise<void> {\n  const {\n    modelUrl,\n    modelBasePath,\n    onProgress,\n    onReady,\n    useCache = true,\n    singleThread = false,\n    nThreads,\n    nGpuLayers = 0,\n    nCtx = 2048,\n    verbose = false,\n    assetPaths,\n    useCdn = false,\n  } = config;\n\n  const log = (msg: string) => {\n    if (verbose) console.log(`[TEA-LLM] ${msg}`);\n  };\n\n  // Determine threading capability\n  const multiThreadSupported = hasCoopCoep() && !singleThread;\n  log(`Multi-threading: ${multiThreadSupported ? 'enabled' : 'disabled'}`);\n\n  // Get wllama asset paths\n  const paths = useCdn ? getCdnPaths() : (assetPaths || getDefaultAssetPaths());\n  log(`Using wllama assets: ${useCdn ? 'CDN' : 'bundled'}`);\n\n  // Initialize wllama\n  if (!wllamaInstance) {\n    log('Creating wllama instance...');\n\n    const wllamaConfig: Partial<WllamaConfig> = {\n      // Optionally disable multi-threading\n      ...(singleThread ? { n_threads: 1 } : {}),\n      ...(nThreads ? { n_threads: nThreads } : {}),\n    };\n\n    wllamaInstance = new Wllama(paths, wllamaConfig);\n    isInitialized = true;\n  }\n\n  // Load model if URL provided\n  if (modelUrl || modelBasePath) {\n    log('Loading model...');\n\n    let modelData: Uint8Array;\n\n    if (modelBasePath) {\n      // Use manifest-based loading with caching\n      modelData = await loadBundledModel({\n        modelBasePath,\n        useCache,\n        onProgress,\n        verbose,\n      } as BundledModelConfig);\n    } else if (modelUrl) {\n      // Direct URL loading\n      log(`Fetching from: ${modelUrl}`);\n\n      // First check cache\n      if (useCache) {\n        const stats = await getCacheStats();\n        if (stats.modelCount > 0) {\n          log('Cache has models, checking...');\n          // For direct URL, we'd need to implement URL-based cache lookup\n          // For now, fall through to download\n        }\n      }\n\n      const response = await fetch(modelUrl);\n      if (!response.ok) {\n        throw new Error(`Failed to fetch model: ${response.status} ${response.statusText}`);\n      }\n\n      const reader = response.body?.getReader();\n      if (!reader) {\n        throw new Error('Response body not readable');\n      }\n\n      const contentLength = parseInt(response.headers.get('Content-Length') || '0', 10);\n      const chunks: Uint8Array[] = [];\n      let loaded = 0;\n\n      while (true) {\n        const { done, value } = await reader.read();\n        if (done) break;\n        chunks.push(value);\n        loaded += value.length;\n        onProgress?.(loaded, contentLength);\n      }\n\n      modelData = new Uint8Array(loaded);\n      let offset = 0;\n      for (const chunk of chunks) {\n        modelData.set(chunk, offset);\n        offset += chunk.length;\n      }\n    } else {\n      throw new Error('Either modelUrl or modelBasePath must be provided');\n    }\n\n    // Load into wllama\n    log('Loading model into wllama...');\n    await wllamaInstance.loadModel(modelData, {\n      n_gpu_layers: nGpuLayers,\n      n_ctx: nCtx,\n    });\n\n    modelLoaded = true;\n    log('Model loaded successfully');\n  }\n\n  onReady?.();\n}\n\n/**\n * Check if the LLM is initialized and ready\n */\nexport function isLlmReady(): boolean {\n  return isInitialized && modelLoaded;\n}\n\n/**\n * Generate a chat completion\n *\n * @example\n * ```typescript\n * const response = await chat(\"What is 2+2?\", {\n *   maxTokens: 50,\n *   temperature: 0.7,\n * });\n * console.log(response.content);\n * ```\n */\nexport async function chat(\n  prompt: string,\n  options: ChatOptions = {}\n): Promise<ChatResponse> {\n  if (!wllamaInstance || !modelLoaded) {\n    throw new Error('LLM not initialized. Call initLlm() first.');\n  }\n\n  const {\n    maxTokens = 100,\n    temperature = 0.7,\n    topP = 0.9,\n    topK = 0,\n    stop = [],\n    system,\n  } = options;\n\n  // Build full prompt with system message if provided\n  let fullPrompt = prompt;\n  if (system) {\n    // Use standard chat template format\n    fullPrompt = `<|system|>\\n${system}\\n<|user|>\\n${prompt}\\n<|assistant|>\\n`;\n  }\n\n  const result = await wllamaInstance.createCompletion(fullPrompt, {\n    nPredict: maxTokens,\n    sampling: {\n      temp: temperature,\n      top_p: topP,\n      top_k: topK,\n    },\n    stopTokens: stop,\n  });\n\n  return {\n    content: result,\n    usage: {\n      // wllama doesn't provide token counts directly, estimate from length\n      promptTokens: Math.ceil(fullPrompt.length / 4),\n      completionTokens: Math.ceil(result.length / 4),\n      totalTokens: Math.ceil((fullPrompt.length + result.length) / 4),\n    },\n  };\n}\n\n/**\n * Generate a chat completion with streaming tokens\n *\n * @example\n * ```typescript\n * await chatStream(\"Tell me a story\", (token) => {\n *   process.stdout.write(token);\n * }, { maxTokens: 200 });\n * ```\n */\nexport async function chatStream(\n  prompt: string,\n  onToken: TokenCallback,\n  options: ChatOptions = {}\n): Promise<ChatResponse> {\n  if (!wllamaInstance || !modelLoaded) {\n    throw new Error('LLM not initialized. Call initLlm() first.');\n  }\n\n  const {\n    maxTokens = 100,\n    temperature = 0.7,\n    topP = 0.9,\n    topK = 0,\n    stop = [],\n    system,\n  } = options;\n\n  // Build full prompt with system message if provided\n  let fullPrompt = prompt;\n  if (system) {\n    fullPrompt = `<|system|>\\n${system}\\n<|user|>\\n${prompt}\\n<|assistant|>\\n`;\n  }\n\n  let fullContent = '';\n\n  await wllamaInstance.createCompletion(fullPrompt, {\n    nPredict: maxTokens,\n    sampling: {\n      temp: temperature,\n      top_p: topP,\n      top_k: topK,\n    },\n    stopTokens: stop,\n    onNewToken: (_token: number, piece: string) => {\n      fullContent += piece;\n      onToken(piece);\n    },\n  });\n\n  return {\n    content: fullContent,\n    usage: {\n      promptTokens: Math.ceil(fullPrompt.length / 4),\n      completionTokens: Math.ceil(fullContent.length / 4),\n      totalTokens: Math.ceil((fullPrompt.length + fullContent.length) / 4),\n    },\n  };\n}\n\n/**\n * Generate text embeddings\n *\n * @example\n * ```typescript\n * const embedding = await embed(\"Hello world\");\n * console.log(embedding.vector); // Float32Array\n * ```\n */\nexport async function embed(text: string): Promise<EmbedResponse> {\n  if (!wllamaInstance || !modelLoaded) {\n    throw new Error('LLM not initialized. Call initLlm() first.');\n  }\n\n  const vector = await wllamaInstance.createEmbedding(text);\n\n  return {\n    vector: new Float32Array(vector),\n    dimension: vector.length,\n  };\n}\n\n/**\n * Dispose of the LLM instance and free resources\n */\nexport async function disposeLlm(): Promise<void> {\n  if (wllamaInstance) {\n    await wllamaInstance.exit();\n    wllamaInstance = null;\n    isInitialized = false;\n    modelLoaded = false;\n  }\n}\n\n/**\n * Get the underlying wllama instance for advanced usage\n * (backward compatibility for users migrating from callback API)\n */\nexport function getWllamaInstance(): Wllama | null {\n  return wllamaInstance;\n}\n\n/**\n * Get model cache statistics\n */\nexport async function getLlmCacheStats(): Promise<CacheStats> {\n  return getCacheStats();\n}\n\n/**\n * Clear the model cache\n */\nexport async function clearLlmCache(): Promise<void> {\n  return clearCache();\n}\n"],
  "mappings": "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QAAQ;AAAA,QACR,cAAc;AAAA,MAChB;AAAA,MACA;AAAA,QACE,QAAQ;AAAA,QACR,QAAQ;AAAA,QACR,cAAc;AAAA,MAChB;AAAA,MACA;AAAA,QACE,QAAQ;AAAA,QACR,QAAQ;AAAA,QACR,cAAc;AAAA,MAChB;AAAA,MACA;AAAA,QACE,QAAQ;AAAA,QACR,QAAQ;AAAA,QACR,cAAc;AAAA,MAChB;AAAA,MACA;AAAA,QACE,QAAQ;AAAA,QACR,QAAQ;AAAA,QACR,cAAc;AAAA,MAChB;AAAA,MACA;AAAA,QACE,QAAQ;AAAA,QACR,QAAQ;AAAA,QACR,cAAc;AAAA,MAChB;AAAA,MACA;AAAA,QACE,QAAQ;AAAA,QACR,QAAQ;AAAA,QACR,cAAc;AAAA,MAChB;AAAA,MACA;AAAA,QACE,QAAQ;AAAA,QACR,QAAQ;AAAA,QACR,cAAc;AAAA,MAChB;AAAA,MACA;AAAA,QACE,QAAQ;AAAA,QACR,QAAQ;AAAA,QACR,cAAc;AAAA,MAChB;AAAA,MACA;AAAA,QACE,QAAQ;AAAA,QACR,QAAQ;AAAA,QACR,cAAc;AAAA,MAChB;AAAA,MACA;AAAA,QACE,QAAQ;AAAA,QACR,QAAQ;AAAA,QACR,cAAc;AAAA,MAChB;AAAA,MACA;AAAA,QACE,QAAQ;AAAA,QACR,QAAQ;AAAA,QACR,cAAc;AAAA,MAChB;AAAA,MACA;AAAA,QACE,QAAQ;AAAA,QACR,QAAQ;AAAA,QACR,cAAc;AAAA,MAChB;AAAA,MACA;AAAA,QACE,QAAQ;AAAA,QACR,QAAQ;AAAA,QACR,cAAc;AAAA,MAChB;AAAA,MACA;AAAA,QACE,QAAQ;AAAA,QACR,QAAQ;AAAA,QACR,cAAc;AAAA,MAChB;AAAA,MACA;AAAA,QACE,QAAQ;AAAA,QACR,QAAQ;AAAA,QACR,cAAc;AAAA,MAChB;AAAA,MACA;AAAA,QACE,QAAQ;AAAA,QACR,QAAQ;AAAA,QACR,cAAc;AAAA,MAChB;AAAA,MACA;AAAA,QACE,QAAQ;AAAA,QACR,QAAQ;AAAA,QACR,cAAc;AAAA,MAChB;AAAA,MACA;AAAA,QACE,QAAQ;AAAA,QACR,QAAQ;AAAA,QA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",
  "names": ["version", "formatBytes", "version", "e", "version"]
}
