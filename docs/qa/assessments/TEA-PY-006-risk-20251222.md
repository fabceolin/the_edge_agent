# Risk Profile: Story TEA-PY-006

Date: 2025-12-22
Reviewer: Quinn (Test Architect)

## Executive Summary

- Total Risks Identified: 7
- Critical Risks: 0
- High Risks: 2
- Medium Risks: 3
- Low Risks: 2
- Risk Score: 71/100 (calculated)

This story addresses a flaky test caused by race conditions in thread-local Lua runtime management. The primary risks are introducing new concurrency bugs during the fix and potential performance regressions. Overall risk is manageable with proper testing.

## Risk Matrix

| Risk ID   | Description                                        | Probability | Impact     | Score | Priority |
|-----------|---------------------------------------------------|-------------|------------|-------|----------|
| TECH-001  | Fix introduces new race condition                  | Medium (2)  | High (3)   | 6     | High     |
| PERF-001  | Runtime creation overhead increases                | Medium (2)  | High (3)   | 6     | High     |
| TECH-002  | Thread pool reuse edge cases not fully addressed   | Medium (2)  | Medium (2) | 4     | Medium   |
| OPS-001   | CI flakiness persists after fix                    | Medium (2)  | Medium (2) | 4     | Medium   |
| TECH-003  | Memory growth from orphaned Lua runtimes           | Low (1)     | High (3)   | 3     | Low      |
| DATA-001  | Lua state corruption in edge cases                 | Low (1)     | High (3)   | 3     | Low      |
| TECH-004  | Breaking change to sequential execution behavior   | Low (1)     | Medium (2) | 2     | Low      |

## High Risks Requiring Attention

### 1. TECH-001: Fix Introduces New Race Condition

**Score: 6 (High)**
**Probability**: Medium - Threading code is inherently complex; subtle bugs are common
**Impact**: High - Could cause data corruption, test failures, or production issues

**Root Cause Analysis:**
- The current `_get_lua_runtime()` implementation uses `threading.local()` which has known edge cases
- Option A (dict with lock) introduces shared mutable state requiring careful synchronization
- Option B (fresh runtime per thread) is simpler but changes semantics

**Mitigation:**
| Strategy | Actions |
|----------|---------|
| Preventive | Use Option B (simplest implementation, lowest risk of bugs) |
| Preventive | Double-checked locking if Option A chosen |
| Detective | Add stress tests with 50+ iterations |
| Detective | Use `pytest-xdist` for concurrent test execution |

**Testing Focus:**
- Stress test with high thread count (20+)
- Race condition detection via repeated runs
- ThreadSanitizer if available

---

### 2. PERF-001: Runtime Creation Overhead Increases

**Score: 6 (High)**
**Probability**: Medium - Creating fresh LuaRuntime per branch adds overhead
**Impact**: High - Could slow down parallel Lua workflows significantly

**Root Cause Analysis:**
- Current design reuses runtimes for efficiency
- Option B creates fresh runtime for each non-main thread
- LuaRuntime creation is ~1-10ms per instance

**Mitigation:**
| Strategy | Actions |
|----------|---------|
| Preventive | Benchmark before/after implementation |
| Preventive | Ensure LuaRuntime creation stays <10ms |
| Detective | Add performance regression test |
| Corrective | Consider pooling if overhead is unacceptable |

**Testing Focus:**
- `test_lua_runtime_creation_overhead` must pass (<10ms)
- Benchmark parallel branch execution time
- Profile under production-like load

---

## Medium Risks

### 3. TECH-002: Thread Pool Reuse Edge Cases Not Fully Addressed

**Score: 4 (Medium)**
**Probability**: Medium - ThreadPoolExecutor thread reuse is documented behavior
**Impact**: Medium - Could cause intermittent isolation failures

**Mitigation:**
- Use fresh runtime per call (Option B) instead of thread-local storage
- Add explicit test for thread reuse scenario
- Document thread pool behavior in code comments

---

### 4. OPS-001: CI Flakiness Persists After Fix

**Score: 4 (Medium)**
**Probability**: Medium - Race conditions are notoriously hard to fix completely
**Impact**: Medium - Would require additional investigation cycles

**Mitigation:**
- Run 10+ consecutive full suite runs before declaring fix complete
- Use deterministic thread scheduling in tests if possible
- Add CI retry logic as temporary safety net

---

## Low Risks

### 5. TECH-003: Memory Growth from Orphaned Lua Runtimes

**Score: 3 (Low)**
**Probability**: Low - Runtimes should be garbage collected with threads
**Impact**: High - Memory leaks in long-running processes

**Mitigation:**
- Monitor memory usage during stress tests
- If Option A used, add cleanup mechanism for stale thread IDs
- Profile memory with `memory_profiler`

---

### 6. DATA-001: Lua State Corruption in Edge Cases

**Score: 3 (Low)**
**Probability**: Low - Proper isolation should prevent this
**Impact**: High - Could cause incorrect computation results

**Mitigation:**
- Existing isolation tests validate state independence
- Add assertions for runtime identity in parallel tests
- Log runtime IDs during debugging

---

### 7. TECH-004: Breaking Change to Sequential Execution Behavior

**Score: 2 (Low)**
**Probability**: Low - Main thread detection is straightforward
**Impact**: Medium - Could break existing workflows relying on shared state

**Mitigation:**
- Ensure main thread still reuses runtime (backward compat)
- `test_sequential_can_reuse_runtime` validates this
- Document behavior change if any

---

## Risk Distribution

### By Category

| Category    | Total | High | Medium | Low |
|-------------|-------|------|--------|-----|
| Technical   | 4     | 1    | 1      | 2   |
| Performance | 1     | 1    | 0      | 0   |
| Operational | 1     | 0    | 1      | 0   |
| Data        | 1     | 0    | 0      | 1   |
| Security    | 0     | 0    | 0      | 0   |
| Business    | 0     | 0    | 0      | 0   |

### By Component

| Component                  | Risks |
|---------------------------|-------|
| yaml_engine.py            | 5     |
| test_lua_isolation.py     | 1     |
| CI Pipeline               | 1     |

---

## Risk-Based Testing Strategy

### Priority 1: High Risk Tests

| Test | Risk Mitigated | Type |
|------|---------------|------|
| Stress test (50+ iterations) | TECH-001 | Integration |
| Performance benchmark | PERF-001 | Unit |
| Thread pool reuse test | TECH-002 | Unit |
| 10 consecutive suite runs | OPS-001 | E2E |

### Priority 2: Medium Risk Tests

| Test | Risk Mitigated | Type |
|------|---------------|------|
| Thread ID isolation verification | TECH-002 | Unit |
| CI reproducibility test | OPS-001 | E2E |

### Priority 3: Low Risk Tests

| Test | Risk Mitigated | Type |
|------|---------------|------|
| Memory profiling | TECH-003 | Integration |
| Lua state corruption check | DATA-001 | Unit |
| Sequential reuse validation | TECH-004 | Unit |

---

## Risk Acceptance Criteria

### Must Fix Before Production

- All high risks (score 6) must have mitigations in place
- No critical risks allowed

### Can Deploy with Mitigation

- Medium risks with compensating controls (tests, monitoring)
- Performance regression <10% acceptable

### Accepted Risks

None at this time. All identified risks require mitigation.

---

## Monitoring Requirements

Post-deployment monitoring for:

| Risk Category | Metric | Alert Threshold |
|--------------|--------|-----------------|
| Performance | LuaRuntime creation time | >10ms average |
| Operational | Test flakiness rate | >1% failure rate |
| Technical | Memory usage growth | >20% increase per hour |

---

## Risk Review Triggers

Review and update risk profile when:

- Implementation approach changes (Option A vs B vs C)
- New race condition patterns discovered
- Performance benchmarks reveal issues
- Memory profiling shows unexpected growth
- Additional thread pool edge cases identified

---

## Recommendations Summary

### Must Fix

1. Choose simplest implementation (Option B recommended) to minimize TECH-001
2. Add comprehensive stress test before declaring fix complete
3. Benchmark LuaRuntime creation to validate PERF-001 mitigation

### Monitor

1. CI test pass rate after merge
2. Memory usage in long-running test suites
3. Performance metrics in production Lua workflows
