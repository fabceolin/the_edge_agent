# Test Design: Story 44.2 - Trace Context Propagation

Date: 2026-01-13
Designer: Quinn (Test Architect)

## Test Strategy Overview

- Total test scenarios: 32
- Unit tests: 14 (44%)
- Integration tests: 14 (44%)
- E2E tests: 4 (12%)
- Priority distribution: P0: 12, P1: 14, P2: 6

## Test Scenarios by Acceptance Criteria

### AC1: Multi-LLM Nesting - All LLM calls appear as child spans

#### Scenarios

| ID | Level | Priority | Test | Justification |
|----|-------|----------|------|---------------|
| 44.2-INT-001 | Integration | P0 | Two sequential LLM calls share same parent trace | Core multi-LLM requirement |
| 44.2-INT-002 | Integration | P0 | Three LLM calls in sequence all nest correctly | Extended sequential validation |
| 44.2-INT-003 | Integration | P1 | LLM call from nested node function maintains context | Deep call stack handling |
| 44.2-UNIT-001 | Unit | P1 | `TraceContext` struct correctly stores trace hierarchy | Data structure correctness |

### AC2: Correct Parent-Child - `parent_span_id` linking

#### Scenarios

| ID | Level | Priority | Test | Justification |
|----|-------|----------|------|---------------|
| 44.2-UNIT-002 | Unit | P0 | Span creation generates valid `span_id` | ID generation correctness |
| 44.2-UNIT-003 | Unit | P0 | Child span correctly references `parent_span_id` | Parent-child linkage |
| 44.2-INT-004 | Integration | P0 | Event sequence maintains correct parent-child chain | Chain integrity |
| 44.2-UNIT-004 | Unit | P1 | Span IDs are unique within trace | Uniqueness validation |

### AC3: Trace ID Consistency - Same `trace_id` throughout

#### Scenarios

| ID | Level | Priority | Test | Justification |
|----|-------|----------|------|---------------|
| 44.2-UNIT-005 | Unit | P0 | `trace_id` remains constant across context operations | Core invariant |
| 44.2-INT-005 | Integration | P0 | All events in execution share same `trace_id` | Execution-wide consistency |
| 44.2-INT-006 | Integration | P1 | `trace_id` consistent across node boundaries | Node transition handling |

### AC4: Parallel Flow Support - Parallel branches maintain context

#### Scenarios

| ID | Level | Priority | Test | Justification |
|----|-------|----------|------|---------------|
| 44.2-INT-007 | Integration | P0 | Two parallel branches inherit parent trace context | Core parallel requirement |
| 44.2-INT-008 | Integration | P0 | `tokio::spawn` tasks correctly propagate context | Async task handling |
| 44.2-INT-009 | Integration | P1 | Fan-in node receives context from all branches | Context merge at fan-in |
| 44.2-INT-010 | Integration | P1 | Three+ parallel branches all maintain trace | Scale validation |
| 44.2-UNIT-006 | Unit | P1 | `with_trace_context` async wrapper preserves context | Context wrapper correctness |

### AC5: No Orphan Traces - No separate/orphan LLM traces

#### Scenarios

| ID | Level | Priority | Test | Justification |
|----|-------|----------|------|---------------|
| 44.2-INT-011 | Integration | P0 | LLM call without context logs warning but doesn't orphan | Graceful degradation |
| 44.2-E2E-001 | E2E | P0 | Real Opik shows all spans under single trace (manual) | End-to-end validation |
| 44.2-UNIT-007 | Unit | P1 | Missing context scenario handled without panic | Robustness |

### AC6: Sequential Flow Support - Sequential multi-node maintains context

#### Scenarios

| ID | Level | Priority | Test | Justification |
|----|-------|----------|------|---------------|
| 44.2-INT-012 | Integration | P0 | Five-node sequential flow maintains single trace | Long sequence validation |
| 44.2-UNIT-008 | Unit | P1 | Context persists across await points | Async correctness |
| 44.2-UNIT-009 | Unit | P2 | Context survives after long operation delay | Timeout resilience |

### AC7: Backward Compatible - Single-LLM agents work

#### Scenarios

| ID | Level | Priority | Test | Justification |
|----|-------|----------|------|---------------|
| 44.2-INT-013 | Integration | P0 | Single-LLM agent produces valid trace | Regression prevention |
| 44.2-INT-014 | Integration | P1 | Agent without LLM calls works correctly | No-LLM scenario |
| 44.2-E2E-002 | E2E | P1 | Existing examples still produce valid Opik traces | Backward compatibility |

### AC8: Debug Logging - Context logged at key points

#### Scenarios

| ID | Level | Priority | Test | Justification |
|----|-------|----------|------|---------------|
| 44.2-UNIT-010 | Unit | P1 | Debug log outputs trace context before LLM call | Observability |
| 44.2-UNIT-011 | Unit | P1 | Debug log outputs context at node boundaries | Debugging support |
| 44.2-UNIT-012 | Unit | P2 | Debug logging disabled by default (no perf impact) | Performance |
| 44.2-UNIT-013 | Unit | P2 | `RUST_LOG=debug` enables context logging | Configuration |
| 44.2-UNIT-014 | Unit | P2 | Log format matches pattern `[OPIK DEBUG]` | Log parsing |

## Complex Workflow Scenarios

| ID | Level | Priority | Test | Justification |
|----|-------|----------|------|---------------|
| 44.2-E2E-003 | E2E | P1 | Nested parallel-sequential workflow maintains trace | Complex topology |
| 44.2-E2E-004 | E2E | P2 | Workflow with conditional + parallel + loop | Edge case topology |

## Risk Coverage

| Risk | Mitigating Tests |
|------|------------------|
| Orphan traces in production (main failure mode) | 44.2-INT-001-003, 44.2-E2E-001 |
| Context lost across tokio::spawn | 44.2-INT-007-010, 44.2-UNIT-006 |
| Regression in single-LLM agents | 44.2-INT-013, 44.2-E2E-002 |
| Panic on missing context | 44.2-UNIT-007, 44.2-INT-011 |
| Performance degradation from logging | 44.2-UNIT-012-013 |
| Complex workflow context corruption | 44.2-E2E-003-004 |

## Recommended Execution Order

1. **P0 Unit tests** (44.2-UNIT-002, 003, 005) - Context primitives
2. **P0 Integration tests** (44.2-INT-001-002, 004-005, 007-008, 011-013) - Core flows
3. **P0 E2E test** (44.2-E2E-001) - Real Opik validation
4. **P1 tests** - Extended coverage and edge cases
5. **P2 tests** - Debug logging and polish

## Test Implementation Notes

### Unit Test Setup Pattern (TraceContext)

```rust
#[cfg(test)]
mod trace_context_tests {
    use super::*;
    use uuid::Uuid;

    #[test]
    fn test_trace_context_preserves_trace_id() {
        let trace_id = Uuid::new_v4().to_string();
        let ctx = TraceContext {
            trace_id: trace_id.clone(),
            span_id: Uuid::new_v4().to_string(),
            parent_span_id: None,
        };

        // Create child span
        let child = ctx.child_span();

        assert_eq!(child.trace_id, trace_id);
        assert_eq!(child.parent_span_id, Some(ctx.span_id));
    }
}
```

### Integration Test Pattern (Parallel Context)

```rust
#[tokio::test]
async fn test_parallel_branches_inherit_context() {
    let root_ctx = TraceContext::new();
    set_trace_context(root_ctx.clone());

    let handles: Vec<_> = (0..3)
        .map(|_| {
            let ctx = root_ctx.clone();
            tokio::spawn(async move {
                with_trace_context(ctx, async {
                    // Simulated LLM call
                    let current = get_trace_context().unwrap();
                    current.trace_id
                }).await
            })
        })
        .collect();

    for handle in handles {
        let child_trace_id = handle.await.unwrap();
        assert_eq!(child_trace_id, root_ctx.trace_id);
    }
}
```

### Mock OpikHandler Pattern

```rust
struct MockOpikHandler {
    events: Arc<Mutex<Vec<TraceEvent>>>,
}

impl MockOpikHandler {
    fn new() -> Self {
        Self { events: Arc::new(Mutex::new(Vec::new())) }
    }

    fn get_events(&self) -> Vec<TraceEvent> {
        self.events.lock().unwrap().clone()
    }

    fn verify_single_trace(&self) {
        let events = self.get_events();
        let trace_ids: HashSet<_> = events.iter().map(|e| &e.trace_id).collect();
        assert_eq!(trace_ids.len(), 1, "Expected single trace, found {}", trace_ids.len());
    }
}
```

### E2E Test Pattern (Opik Integration)

```rust
#[tokio::test]
#[ignore] // Requires OPIK_API_KEY
async fn test_real_opik_multi_llm_trace() {
    // This test requires manual verification in Opik dashboard
    // 1. Run: OPIK_API_KEY=xxx cargo test test_real_opik_multi_llm_trace -- --ignored
    // 2. Open Opik dashboard
    // 3. Verify trace shows all LLM calls nested under single parent

    let yaml = r#"
        name: multi_llm_test
        nodes:
          - name: first_llm
            actions:
              - llm.generate:
                  prompt: "Say hello"
          - name: second_llm
            actions:
              - llm.generate:
                  prompt: "Say goodbye"
        edges:
          - from: __start__
            to: first_llm
          - from: first_llm
            to: second_llm
          - from: second_llm
            to: __end__
    "#;

    let engine = YamlEngine::from_yaml(yaml).unwrap();
    let result = engine.invoke(json!({})).await;

    assert!(result.is_ok());
    // Manual verification: check Opik dashboard for nested spans
}
```

## Quality Checklist

- [x] Every AC has test coverage
- [x] Test levels are appropriate (integration-heavy due to async context)
- [x] No duplicate coverage across levels
- [x] Priorities align with business risk (orphan traces = main failure)
- [x] Test IDs follow naming convention (44.2-LEVEL-SEQ)
- [x] Scenarios are atomic and independent

## Investigation Phase Tests

**Note:** Task 1 (Investigation) should produce findings that inform the test strategy. The following tests verify the investigation outputs:

| ID | Level | Priority | Test | Justification |
|----|-------|----------|------|---------------|
| 44.2-UNIT-INV-001 | Unit | P0 | Document current trace behavior with debug logging | Investigation validation |
| 44.2-INT-INV-001 | Integration | P0 | Create 2-LLM test agent and verify current behavior | Baseline establishment |

These tests should be run first to confirm whether the fix is needed and guide implementation.
