<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TEA WASM LLM Test Harness</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            max-width: 1000px;
            margin: 0 auto;
            padding: 20px;
            background: #1e1e1e;
            color: #d4d4d4;
        }
        h1 { color: #569cd6; }
        h2 { color: #4ec9b0; margin-top: 30px; }
        .test-result {
            padding: 10px 15px;
            margin: 5px 0;
            border-radius: 5px;
            font-family: 'Consolas', 'Monaco', monospace;
        }
        .pass { background: #1e3a1e; border-left: 4px solid #4ec9b0; }
        .fail { background: #3a1e1e; border-left: 4px solid #f14c4c; }
        .pending { background: #3a3a1e; border-left: 4px solid #dcdcaa; }
        .info { background: #1e2d3a; border-left: 4px solid #569cd6; }
        pre {
            background: #2d2d2d;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
        }
        button {
            background: #0e639c;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            margin: 5px;
        }
        button:hover { background: #1177bb; }
        button:disabled { background: #4a4a4a; cursor: not-allowed; }
        #output {
            margin-top: 20px;
            max-height: 500px;
            overflow-y: auto;
        }
        .stats {
            display: flex;
            gap: 20px;
            margin: 20px 0;
            padding: 15px;
            background: #2d2d2d;
            border-radius: 5px;
        }
        .stat { text-align: center; }
        .stat-value { font-size: 24px; font-weight: bold; }
        .stat-label { font-size: 12px; color: #808080; }
    </style>
</head>
<body>
    <h1>üß™ TEA WASM LLM Test Harness</h1>

    <div class="stats">
        <div class="stat">
            <div class="stat-value" id="total">0</div>
            <div class="stat-label">Total</div>
        </div>
        <div class="stat">
            <div class="stat-value" id="passed" style="color: #4ec9b0;">0</div>
            <div class="stat-label">Passed</div>
        </div>
        <div class="stat">
            <div class="stat-value" id="failed" style="color: #f14c4c;">0</div>
            <div class="stat-label">Failed</div>
        </div>
        <div class="stat">
            <div class="stat-value" id="duration">-</div>
            <div class="stat-label">Duration</div>
        </div>
    </div>

    <div>
        <button id="runAll" onclick="runAllTests()">‚ñ∂Ô∏è Run All Tests</button>
        <button id="runWithModel" onclick="runWithModel()" disabled>üß† Run with Tiny Model</button>
        <button onclick="clearOutput()">üóëÔ∏è Clear</button>
    </div>

    <div id="output"></div>

    <h2>Test Configuration</h2>
    <pre id="config">Loading...</pre>

    <!-- Import maps for external libraries -->
    <script type="importmap">
    {
        "imports": {
            "wasmoon": "https://cdn.jsdelivr.net/npm/wasmoon@1.16.0/+esm",
            "swipl-wasm": "https://cdn.jsdelivr.net/npm/swipl-wasm@3.6.0/+esm"
        }
    }
    </script>

    <script type="module">
        import init, {
            execute_yaml,
            set_llm_handler,
            clear_llm_handler,
            has_llm_handler,
            llm_call_async,
            has_shared_array_buffer,
            version,
            // Lua callback functions
            set_lua_callback,
            clear_lua_callback,
            has_lua_callback,
            lua_eval_async,
            // Prolog handler functions
            set_prolog_handler,
            clear_prolog_handler,
            has_prolog_handler,
            prolog_query_async,
        } from '../pkg/tea_wasm_llm.js';

        // Lua and Prolog engine instances (loaded on demand)
        let luaEngine = null;
        let prologEngine = null;

        // Make functions available globally for buttons
        window.init = init;
        window.execute_yaml = execute_yaml;
        window.set_llm_handler = set_llm_handler;
        window.clear_llm_handler = clear_llm_handler;
        window.has_llm_handler = has_llm_handler;
        window.llm_call_async = llm_call_async;
        window.has_shared_array_buffer = has_shared_array_buffer;
        window.version = version;
        // Lua functions
        window.set_lua_callback = set_lua_callback;
        window.clear_lua_callback = clear_lua_callback;
        window.has_lua_callback = has_lua_callback;
        window.lua_eval_async = lua_eval_async;
        // Prolog functions
        window.set_prolog_handler = set_prolog_handler;
        window.clear_prolog_handler = clear_prolog_handler;
        window.has_prolog_handler = has_prolog_handler;
        window.prolog_query_async = prolog_query_async;

        // Test state
        let testResults = { total: 0, passed: 0, failed: 0 };
        let startTime = 0;

        function log(message, type = 'info') {
            const output = document.getElementById('output');
            const div = document.createElement('div');
            div.className = `test-result ${type}`;
            div.textContent = message;
            output.appendChild(div);
            output.scrollTop = output.scrollHeight;
        }

        function updateStats() {
            document.getElementById('total').textContent = testResults.total;
            document.getElementById('passed').textContent = testResults.passed;
            document.getElementById('failed').textContent = testResults.failed;
            if (startTime > 0) {
                const duration = ((Date.now() - startTime) / 1000).toFixed(2);
                document.getElementById('duration').textContent = duration + 's';
            }
        }

        async function runTest(name, testFn) {
            testResults.total++;
            log(`Running: ${name}...`, 'pending');

            try {
                await testFn();
                testResults.passed++;
                log(`‚úÖ PASS: ${name}`, 'pass');
            } catch (error) {
                testResults.failed++;
                log(`‚ùå FAIL: ${name} - ${error.message}`, 'fail');
                console.error(error);
            }

            updateStats();
        }

        function assert(condition, message) {
            if (!condition) {
                throw new Error(message || 'Assertion failed');
            }
        }

        function assertEqual(actual, expected, message) {
            if (actual !== expected) {
                throw new Error(message || `Expected ${expected}, got ${actual}`);
            }
        }

        // Test functions
        async function testWasmInit() {
            await init();
            assert(typeof version === 'function', 'version function should exist');
        }

        async function testVersion() {
            const v = version();
            assert(typeof v === 'string', 'version should be a string');
            assert(v.length > 0, 'version should not be empty');
            log(`  Version: ${v}`, 'info');
        }

        async function testSharedArrayBufferDetection() {
            const hasShared = has_shared_array_buffer();
            assert(typeof hasShared === 'boolean', 'should return boolean');
            log(`  SharedArrayBuffer: ${hasShared}`, 'info');
        }

        async function testHandlerNotRegistered() {
            clear_llm_handler();
            assert(!has_llm_handler(), 'handler should not be registered initially');
        }

        async function testSetHandler() {
            const mockHandler = async (params) => {
                return JSON.stringify({ content: 'mock response', model: 'test' });
            };
            set_llm_handler(mockHandler);
            assert(has_llm_handler(), 'handler should be registered');
        }

        async function testClearHandler() {
            set_llm_handler(async () => '{}');
            clear_llm_handler();
            assert(!has_llm_handler(), 'handler should be cleared');
        }

        async function testLlmCallNoHandler() {
            clear_llm_handler();
            try {
                await llm_call_async('{"prompt": "test"}', '{}');
                throw new Error('Should have thrown');
            } catch (e) {
                assert(e.toString().includes('handler'), 'should mention handler');
            }
        }

        async function testLlmCallInvalidParams() {
            set_llm_handler(async () => JSON.stringify({ content: 'test' }));
            try {
                await llm_call_async('not json', '{}');
                throw new Error('Should have thrown');
            } catch (e) {
                assert(e.toString().includes('Invalid'), 'should mention invalid');
            }
        }

        async function testLlmCallWithMockHandler() {
            const mockHandler = async (paramsJson) => {
                const params = JSON.parse(paramsJson);
                return JSON.stringify({
                    content: `Response to: ${params.prompt}`,
                    model: 'mock'
                });
            };
            set_llm_handler(mockHandler);

            const result = await llm_call_async(
                JSON.stringify({ prompt: 'Hello', max_tokens: 10 }),
                JSON.stringify({ input: 'test' })
            );

            const parsed = JSON.parse(result);
            assert(parsed.llm_response, 'should have llm_response');
            assert(parsed.llm_response.content.includes('Hello'), 'should include prompt');
        }

        async function testExecuteYamlSimple() {
            // Mock handler that returns the prompt back
            set_llm_handler(async (paramsJson) => {
                const params = JSON.parse(paramsJson);
                return JSON.stringify({
                    content: `Generated: ${params.prompt}`,
                    model: 'mock'
                });
            });

            const yaml = `
name: test-workflow
nodes:
  - name: gen
    action: llm.call
    with:
      prompt: "Hello world"
      max_tokens: 10
edges:
  - from: __start__
    to: gen
  - from: gen
    to: __end__
`;

            const result = await execute_yaml(yaml, '{}');
            const parsed = JSON.parse(result);

            assert(parsed.llm_response, 'should have llm_response');
            assert(parsed.llm_response.content.includes('Hello'), 'should contain prompt text');
        }

        async function testExecuteYamlWithState() {
            set_llm_handler(async (paramsJson) => {
                const params = JSON.parse(paramsJson);
                return JSON.stringify({
                    content: `Got prompt: ${params.prompt}`,
                    model: 'mock'
                });
            });

            const yaml = `
name: test-with-state
variables:
  system_prompt: "You are helpful"
nodes:
  - name: gen
    action: llm.call
    with:
      prompt: "Say hello to {{ state.name }}"
      max_tokens: 20
edges:
  - from: __start__
    to: gen
  - from: gen
    to: __end__
`;

            const result = await execute_yaml(yaml, JSON.stringify({ name: 'Alice' }));
            const parsed = JSON.parse(result);

            assert(parsed.llm_response, 'should have llm_response');
            assert(parsed.llm_response.content.includes('Alice'), 'should contain state value');
        }

        async function testExecuteYamlInvalidYaml() {
            try {
                await execute_yaml('not: valid: yaml: syntax', '{}');
                throw new Error('Should have thrown');
            } catch (e) {
                assert(true, 'should throw on invalid YAML');
            }
        }

        async function testReturnAction() {
            const yaml = `
name: test-return
nodes:
  - name: greet
    action: return
    with:
      value:
        message: "Hello!"
edges:
  - from: __start__
    to: greet
  - from: greet
    to: __end__
`;

            const result = await execute_yaml(yaml, '{}');
            const parsed = JSON.parse(result);

            assert(parsed.message === 'Hello!', 'should have message');
        }

        // ==================== LUA TESTS ====================

        async function initLuaEngine() {
            if (luaEngine) return luaEngine;
            log('  Loading wasmoon (Lua 5.4)...', 'info');
            try {
                const { LuaFactory } = await import('wasmoon');
                const factory = new LuaFactory();
                luaEngine = await factory.createEngine();
                log('  ‚úì Lua engine loaded', 'info');
                return luaEngine;
            } catch (e) {
                log(`  ‚ö† Could not load wasmoon: ${e.message}`, 'pending');
                return null;
            }
        }

        async function testLuaCallbackNotRegistered() {
            clear_lua_callback();
            assert(!has_lua_callback(), 'Lua callback should not be registered initially');
        }

        async function testLuaCallbackRegistration() {
            const mockCallback = async (code, state) => JSON.stringify({ result: 42 });
            set_lua_callback(mockCallback);
            assert(has_lua_callback(), 'Lua callback should be registered');
            clear_lua_callback();
            assert(!has_lua_callback(), 'Lua callback should be cleared');
        }

        async function testLuaEvalWithWasmoon() {
            const lua = await initLuaEngine();
            if (!lua) {
                log('  Skipping (wasmoon not available)', 'pending');
                return;
            }

            // Register real Lua callback using wasmoon
            set_lua_callback(async (code, stateJson) => {
                const state = JSON.parse(stateJson);
                // Set state variables in Lua
                for (const [key, value] of Object.entries(state)) {
                    lua.global.set(key, value);
                }
                // Execute Lua code
                const result = await lua.doString(code);
                return JSON.stringify({ result });
            });

            const result = await lua_eval_async(
                'return value * 2',
                JSON.stringify({ value: 21 })
            );
            const parsed = JSON.parse(result);

            assert(parsed.lua_result === 42, `Expected 42, got ${parsed.lua_result}`);
            log(`  Lua result: ${parsed.lua_result}`, 'info');
            clear_lua_callback();
        }

        async function testLuaWorkflow() {
            const lua = await initLuaEngine();
            if (!lua) {
                log('  Skipping (wasmoon not available)', 'pending');
                return;
            }

            // Register Lua callback
            set_lua_callback(async (code, stateJson) => {
                const state = JSON.parse(stateJson);
                for (const [key, value] of Object.entries(state)) {
                    lua.global.set(key, value);
                }
                const result = await lua.doString(code);
                return JSON.stringify({ result });
            });

            // Mock LLM handler
            set_llm_handler(async () => JSON.stringify({ content: 'test', model: 'mock' }));

            const yaml = `
name: lua-workflow
nodes:
  - name: compute
    action: lua.eval
    with:
      code: |
        return input * input
edges:
  - from: __start__
    to: compute
  - from: compute
    to: __end__
`;

            const result = await execute_yaml(yaml, JSON.stringify({ input: 7 }));
            const parsed = JSON.parse(result);

            assert(parsed.lua_result === 49, `Expected 49, got ${parsed.lua_result}`);
            log(`  7¬≤ = ${parsed.lua_result}`, 'info');

            clear_lua_callback();
        }

        // ==================== PROLOG TESTS ====================

        async function initPrologEngine() {
            if (prologEngine) return prologEngine;
            log('  Loading swipl-wasm (SWI-Prolog)...', 'info');
            try {
                const SWIPL = await import('swipl-wasm');
                prologEngine = await SWIPL.default({ arguments: ['-q'] });
                log('  ‚úì Prolog engine loaded', 'info');
                return prologEngine;
            } catch (e) {
                // swipl-wasm requires Node.js fs module, can't load via CDN
                // Install with: npm install swipl-wasm
                log('  ‚ö† swipl-wasm requires npm install (uses Node.js fs)', 'pending');
                return null;
            }
        }

        async function testPrologHandlerNotRegistered() {
            clear_prolog_handler();
            assert(!has_prolog_handler(), 'Prolog handler should not be registered initially');
        }

        async function testPrologHandlerRegistration() {
            const mockHandler = async (queryJson) => JSON.stringify({ bindings: [], success: true });
            set_prolog_handler(mockHandler);
            assert(has_prolog_handler(), 'Prolog handler should be registered');
            clear_prolog_handler();
            assert(!has_prolog_handler(), 'Prolog handler should be cleared');
        }

        async function testPrologQueryWithSwipl() {
            const pl = await initPrologEngine();
            if (!pl) {
                log('  Skipping (swipl-wasm not available)', 'pending');
                return;
            }

            // Register real Prolog handler
            set_prolog_handler(async (queryJson) => {
                const { code, facts } = JSON.parse(queryJson);
                try {
                    // Consult facts if provided
                    if (facts) {
                        pl.call(`assertz(${facts})`);
                    }
                    // Query
                    const query = pl.query(code);
                    const bindings = [];
                    let result;
                    while ((result = query.next()) && !result.done) {
                        bindings.push(result.value);
                    }
                    query.close();
                    return JSON.stringify({ bindings, success: true });
                } catch (e) {
                    return JSON.stringify({ bindings: [], success: false, error: e.message });
                }
            });

            const result = await prolog_query_async(
                JSON.stringify({ code: 'member(X, [1,2,3])' }),
                '{}'
            );
            const parsed = JSON.parse(result);

            assert(parsed.prolog_result.success, 'Prolog query should succeed');
            log(`  Prolog bindings: ${JSON.stringify(parsed.prolog_result.bindings)}`, 'info');
            clear_prolog_handler();
        }

        async function testPrologWorkflow() {
            // Use mock handler for workflow test (simpler)
            set_prolog_handler(async (queryJson) => {
                const { code } = JSON.parse(queryJson);
                // Mock: simple member query
                if (code.includes('member')) {
                    return JSON.stringify({
                        bindings: [{ X: 1 }, { X: 2 }, { X: 3 }],
                        success: true
                    });
                }
                return JSON.stringify({ bindings: [], success: true });
            });

            const yaml = `
name: prolog-workflow
nodes:
  - name: query
    action: prolog.query
    with:
      code: "member(X, [1,2,3])"
edges:
  - from: __start__
    to: query
  - from: query
    to: __end__
`;

            const result = await execute_yaml(yaml, '{}');
            const parsed = JSON.parse(result);

            assert(parsed.prolog_result, 'Should have prolog_result');
            assert(parsed.prolog_result.bindings.length === 3, 'Should have 3 solutions');
            log(`  Found ${parsed.prolog_result.bindings.length} solutions`, 'info');

            clear_prolog_handler();
        }

        // Run all tests
        window.runAllTests = async function() {
            testResults = { total: 0, passed: 0, failed: 0 };
            document.getElementById('output').innerHTML = '';
            startTime = Date.now();

            log('üöÄ Starting TEA WASM LLM Tests...', 'info');
            log('', 'info');

            await runTest('WASM Initialization', testWasmInit);
            await runTest('Version Check', testVersion);
            await runTest('SharedArrayBuffer Detection', testSharedArrayBufferDetection);
            await runTest('Handler Not Registered Initially', testHandlerNotRegistered);
            await runTest('Set LLM Handler', testSetHandler);
            await runTest('Clear LLM Handler', testClearHandler);
            await runTest('LLM Call Without Handler Errors', testLlmCallNoHandler);
            await runTest('LLM Call Invalid Params Errors', testLlmCallInvalidParams);
            await runTest('LLM Call With Mock Handler', testLlmCallWithMockHandler);
            await runTest('Execute YAML Simple Workflow', testExecuteYamlSimple);
            await runTest('Execute YAML With State', testExecuteYamlWithState);
            await runTest('Execute YAML Invalid YAML Errors', testExecuteYamlInvalidYaml);
            await runTest('Return Action Works', testReturnAction);

            // Lua tests
            log('', 'info');
            log('üåô Lua Tests (wasmoon)', 'info');
            await runTest('Lua Callback Not Registered Initially', testLuaCallbackNotRegistered);
            await runTest('Lua Callback Registration/Clear', testLuaCallbackRegistration);
            await runTest('Lua Eval with wasmoon', testLuaEvalWithWasmoon);
            await runTest('Lua Workflow Execution', testLuaWorkflow);

            // Prolog tests
            log('', 'info');
            log('ü¶â Prolog Tests (swipl-wasm)', 'info');
            await runTest('Prolog Handler Not Registered Initially', testPrologHandlerNotRegistered);
            await runTest('Prolog Handler Registration/Clear', testPrologHandlerRegistration);
            await runTest('Prolog Query with swipl-wasm', testPrologQueryWithSwipl);
            await runTest('Prolog Workflow Execution', testPrologWorkflow);

            log('', 'info');
            log(`‚ú® Tests complete: ${testResults.passed}/${testResults.total} passed`,
                testResults.failed === 0 ? 'pass' : 'fail');

            updateStats();
        };

        window.clearOutput = function() {
            document.getElementById('output').innerHTML = '';
            testResults = { total: 0, passed: 0, failed: 0 };
            startTime = 0;
            updateStats();
            document.getElementById('duration').textContent = '-';
        };

        // Initialize and show config
        (async () => {
            try {
                await init();
                document.getElementById('config').textContent = JSON.stringify({
                    version: version(),
                    sharedArrayBuffer: has_shared_array_buffer(),
                    crossOriginIsolated: window.crossOriginIsolated,
                    callbacks: {
                        llm: has_llm_handler(),
                        lua: has_lua_callback(),
                        prolog: has_prolog_handler(),
                    },
                    userAgent: navigator.userAgent.slice(0, 80) + '...',
                }, null, 2);

                log('‚úÖ WASM module loaded successfully', 'pass');
                log('üì¶ Scripting: wasmoon (Lua) + swipl-wasm (Prolog) via CDN', 'info');
                log('Press "Run All Tests" to begin testing', 'info');
            } catch (error) {
                document.getElementById('config').textContent = `Error: ${error.message}`;
                log(`‚ùå Failed to load WASM: ${error.message}`, 'fail');
            }
        })();
    </script>
</body>
</html>
