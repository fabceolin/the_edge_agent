# Coffee Agent with AI2-THOR: The Wozniak Test (Real Environment)
#
# This agent solves the Wozniak Coffee Test using AI2-THOR simulation.
# Unlike the simulation version, this interacts with a real 3D environment.
#
# PREREQUISITES:
#   pip install ai2thor
#
# RUN (Fixed Scene - for debugging):
#   tea run examples/wozniak-test/coffee-agent-ai2thor.yaml \
#       --input '{"scene": "FloorPlan1", "max_steps": 50}'
#
# RUN (Procedural Scene - true zero-knowledge):
#   tea run examples/wozniak-test/coffee-agent-ai2thor.yaml \
#       --input '{"scene": "Procedural", "max_steps": 100}'

name: coffee-agent-ai2thor
description: Wozniak Coffee Test using AI2-THOR 3D simulation

state_schema:
  # Configuration
  scene: str
  max_steps: int
  headless: bool

  # Environment state
  scene_summary: dict
  visible_objects: list
  coffee_objects: list

  # Task tracking
  required_items: list
  found_items: dict
  missing_items: list

  # Task execution
  current_phase: str
  current_step: int
  action_result: dict

  # Output
  success: bool
  final_result: str

nodes:
  # 1. Initialize AI2-THOR environment
  - name: init_environment
    run: |
      import sys
      sys.path.insert(0, "examples/wozniak-test")
      from ai2thor_helper import AI2THORHelper

      # Get configuration
      scene = state.get("scene", "FloorPlan1")
      headless = state.get("headless", False)

      # Initialize helper (stored globally for subsequent nodes)
      global _helper
      _helper = AI2THORHelper(scene=scene, headless=headless)

      # Get initial scene summary
      summary = _helper.get_scene_summary()
      coffee_objects = _helper.get_coffee_related_objects()

      print(f"[INIT] Scene: {scene}")
      print(f"[INIT] Total objects: {summary['total_objects']}")
      print(f"[INIT] Coffee-related: {len(coffee_objects)}")

      return {
          "scene_summary": summary,
          "coffee_objects": [{"type": o["objectType"], "id": o["objectId"]} for o in coffee_objects],
          "required_items": ["CoffeeMachine", "Mug", "Cup"],
          "found_items": {},
          "missing_items": ["CoffeeMachine", "Mug"],
          "current_phase": "explore",
          "current_step": 0,
          "success": False
      }

  # 2. Scan for coffee-related objects
  - name: scan_environment
    run: |
      global _helper

      # Get all coffee-related objects
      coffee_objects = _helper.get_coffee_related_objects()

      # Categorize found items
      found = state.get("found_items", {})
      required = state.get("required_items", [])

      for obj in coffee_objects:
          obj_type = obj["objectType"]
          if obj_type in required or obj_type in ["CoffeeMachine", "Mug", "Cup"]:
              if obj_type not in found:
                  found[obj_type] = {
                      "id": obj["objectId"],
                      "position": obj["position"],
                      "visible": obj["visible"],
                      "toggleable": obj.get("toggleable", False),
                      "pickupable": obj.get("pickupable", False)
                  }
                  print(f"[FOUND] {obj_type} at {obj['position']}")

      # Update missing items
      missing = [item for item in ["CoffeeMachine", "Mug"] if item not in found and "Cup" not in found]

      # Check if we have a cup instead of mug
      if "Mug" in missing and "Cup" in found:
          missing.remove("Mug")
          print("[INFO] Using Cup instead of Mug")

      return {
          "found_items": found,
          "missing_items": missing,
          "visible_objects": [{"type": o["objectType"], "id": o["objectId"]} for o in _helper.get_visible_objects()]
      }

  # 3. Explore to find missing items
  - name: explore_kitchen
    run: |
      global _helper

      missing = state.get("missing_items", [])
      step = state.get("current_step", 0)
      max_steps = state.get("max_steps", 50)

      if not missing or step >= max_steps:
          return {"current_phase": "gather" if not missing else "failed"}

      # Simple exploration: rotate and look around
      # In a full implementation, this would use proper navigation

      # Try opening cabinets to find hidden items
      all_objects = _helper.get_all_objects()

      # Find closed cabinets
      cabinets = [o for o in all_objects if o["objectType"] == "Cabinet" and not o.get("isOpen", False)]

      if cabinets and step < len(cabinets):
          cabinet = cabinets[step % len(cabinets)]
          print(f"[EXPLORE] Opening cabinet: {cabinet['objectId']}")
          _helper.open_object(cabinet["objectId"])
      else:
          # Rotate to look around
          _helper.rotate_right()
          print(f"[EXPLORE] Rotating to search (step {step})")

      return {
          "current_step": step + 1,
          "current_phase": "scan"  # Go back to scan after exploring
      }

  # 4. Navigate to coffee machine
  - name: navigate_to_coffee_machine
    run: |
      global _helper

      found = state.get("found_items", {})

      if "CoffeeMachine" not in found:
          print("[ERROR] No coffee machine found!")
          return {"current_phase": "failed", "action_result": {"success": False, "error": "No coffee machine"}}

      machine = found["CoffeeMachine"]
      print(f"[NAV] Moving to coffee machine: {machine['id']}")

      success = _helper.navigate_to_object(machine["id"])

      if success:
          _helper.rotate_to_object(machine["id"])
          print("[NAV] Arrived at coffee machine")
      else:
          print("[NAV] Could not navigate to coffee machine")

      return {
          "action_result": {"action": "navigate", "target": "CoffeeMachine", "success": success},
          "current_phase": "pickup_mug" if success else "explore"
      }

  # 5. Pick up mug/cup
  - name: pickup_mug
    run: |
      global _helper

      found = state.get("found_items", {})

      # Try mug first, then cup
      container = found.get("Mug") or found.get("Cup")

      if not container:
          print("[ERROR] No mug or cup found!")
          return {"current_phase": "explore", "action_result": {"success": False, "error": "No container"}}

      print(f"[ACTION] Picking up: {container['id']}")

      # Navigate to the mug first
      _helper.navigate_to_object(container["id"])
      _helper.rotate_to_object(container["id"])

      # Pick it up
      success = _helper.pickup(container["id"])

      if success:
          print("[ACTION] Picked up container successfully")
      else:
          print("[ACTION] Failed to pick up container")
          # Try looking down and picking up again
          _helper.look_down()
          success = _helper.pickup(container["id"])

      return {
          "action_result": {"action": "pickup", "target": container["id"], "success": success},
          "current_phase": "place_mug" if success else "explore"
      }

  # 6. Place mug on/near coffee machine
  - name: place_mug
    run: |
      global _helper

      found = state.get("found_items", {})
      machine = found.get("CoffeeMachine")

      if not machine:
          return {"current_phase": "failed"}

      print(f"[ACTION] Navigating to coffee machine to place mug")

      # Navigate back to coffee machine
      _helper.navigate_to_object(machine["id"])

      # Find a receptacle near the coffee machine (counter top)
      all_objects = _helper.get_all_objects()
      counters = [o for o in all_objects if o["objectType"] == "CounterTop"]

      success = False
      if counters:
          # Find closest counter to coffee machine
          machine_pos = machine["position"]
          counters.sort(key=lambda c: (
              (c["position"]["x"] - machine_pos["x"])**2 +
              (c["position"]["z"] - machine_pos["z"])**2
          )**0.5)

          counter = counters[0]
          print(f"[ACTION] Placing mug on counter: {counter['objectId']}")
          success = _helper.put_on(counter["objectId"])

      return {
          "action_result": {"action": "place", "success": success},
          "current_phase": "toggle_machine" if success else "toggle_machine"  # Try anyway
      }

  # 7. Toggle coffee machine on
  - name: toggle_machine
    run: |
      global _helper

      found = state.get("found_items", {})
      machine = found.get("CoffeeMachine")

      if not machine:
          return {"current_phase": "failed"}

      print(f"[ACTION] Turning on coffee machine: {machine['id']}")

      success = _helper.toggle_on(machine["id"])

      if success:
          print("[SUCCESS] Coffee machine is now ON!")
      else:
          print("[WARNING] Could not turn on coffee machine (may already be on or need other setup)")

      # Check machine state
      machine_state = _helper.get_object_state(machine["id"])
      is_on = machine_state.get("isToggled", False) if machine_state else False

      return {
          "action_result": {"action": "toggle", "target": machine["id"], "success": success, "is_on": is_on},
          "current_phase": "verify"
      }

  # 8. Verify completion (Dona Maria Principle)
  - name: verify_completion
    run: |
      global _helper

      found = state.get("found_items", {})
      machine = found.get("CoffeeMachine")

      # Get final state
      machine_state = _helper.get_object_state(machine["id"]) if machine else None
      scene_summary = _helper.get_scene_summary()

      # Determine success
      has_machine = "CoffeeMachine" in found
      has_container = "Mug" in found or "Cup" in found
      machine_on = machine_state.get("isToggled", False) if machine_state else False

      # Coffee test criteria
      success = has_machine and has_container

      # Build result
      action_history = _helper.get_action_history()

      verification = {
          "coffee_machine_found": has_machine,
          "container_found": has_container,
          "machine_toggled": machine_on,
          "total_actions": len(action_history),
          "scene": state.get("scene", "unknown")
      }

      print(f"\n[VERIFICATION]")
      print(f"  Coffee machine found: {has_machine}")
      print(f"  Container found: {has_container}")
      print(f"  Machine on: {machine_on}")
      print(f"  Actions taken: {len(action_history)}")

      return {
          "success": success,
          "current_phase": "complete",
          "action_result": verification
      }

  # 9. Generate final result
  - name: finalize
    run: |
      global _helper

      success = state.get("success", False)
      verification = state.get("action_result", {})
      found = state.get("found_items", {})

      # Get action history
      history = _helper.get_action_history()

      if success:
          result = f"""
========================================
WOZNIAK COFFEE TEST: PASSED
========================================
Scene: {state.get('scene', 'unknown')}
Coffee Machine: Found at {found.get('CoffeeMachine', {}).get('id', 'N/A')}
Container: {'Mug' if 'Mug' in found else 'Cup'} found
Machine Status: {'ON' if verification.get('machine_toggled') else 'Ready'}
Total Actions: {len(history)}
========================================
"""
      else:
          missing = state.get("missing_items", [])
          result = f"""
========================================
WOZNIAK COFFEE TEST: INCOMPLETE
========================================
Scene: {state.get('scene', 'unknown')}
Missing Items: {', '.join(missing) if missing else 'None'}
Found Items: {', '.join(found.keys())}
Total Actions: {len(history)}
Issue: Could not complete coffee preparation
========================================
"""

      print(result)

      # Cleanup
      _helper.stop()

      return {
          "final_result": result,
          "success": success
      }

edges:
  # Initial flow
  - from: __start__
    to: init_environment

  - from: init_environment
    to: scan_environment

  # Scan -> check if we need to explore
  - from: scan_environment
    to: navigate_to_coffee_machine
    condition: "len(state.get('missing_items', [])) == 0"

  - from: scan_environment
    to: explore_kitchen
    condition: "len(state.get('missing_items', [])) > 0"

  # Explore -> scan again
  - from: explore_kitchen
    to: scan_environment
    condition: "state.get('current_phase') == 'scan'"

  - from: explore_kitchen
    to: finalize
    condition: "state.get('current_phase') == 'failed'"

  - from: explore_kitchen
    to: navigate_to_coffee_machine
    condition: "state.get('current_phase') == 'gather'"

  # Main task flow
  - from: navigate_to_coffee_machine
    to: pickup_mug
    condition: "state.get('current_phase') == 'pickup_mug'"

  - from: navigate_to_coffee_machine
    to: explore_kitchen
    condition: "state.get('current_phase') == 'explore'"

  - from: pickup_mug
    to: place_mug
    condition: "state.get('current_phase') == 'place_mug'"

  - from: pickup_mug
    to: explore_kitchen
    condition: "state.get('current_phase') == 'explore'"

  - from: place_mug
    to: toggle_machine

  - from: toggle_machine
    to: verify_completion

  - from: verify_completion
    to: finalize

  - from: finalize
    to: __end__
