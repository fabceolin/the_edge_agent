# LLM + Prolog Family Reasoning Agent
#
# Demonstrates neurosymbolic AI with TEMPORAL INFERENCE.
#
# KEY PRINCIPLE:
#   LLM extracts OBSERVABLE FACTS (dates, explicit relationships)
#   Prolog DERIVES uncertain relationships (child_of_affair, half_sibling)
#
# ARCHITECTURE:
#   1. LLM extracts: birth_date, mother, father, married(with dates), affair(with dates)
#   2. Prolog derives: child_of_affair (from birth_date + affair period)
#   3. Prolog applies: exclusive relationship premise → father
#   4. Prolog queries: sibling, half_sibling
#
# WHY THIS IS BETTER:
#   - LLM only extracts what's observable in text
#   - Prolog does all logical inference
#   - Each derivation has an explainable reasoning chain
#
# EXAMPLE:
#   Text says: "Camilla had Thomas" + "affair began in early 1970s" + "Thomas born 1974"
#   LLM extracts: mother(camilla, thomas), affair(camilla, charles, 1970, 1995), birth_date(thomas, 1974)
#   Prolog derives: child_of_affair(thomas, charles) because 1974 is in [1970, 1995]
#
# Uses correct YAML syntax: 'uses' for actions, 'with' for params

name: llm-prolog-family-reasoning
description: |
  Neurosymbolic agent using temporal reasoning to derive family relationships.
  LLM extracts facts with dates; Prolog infers uncertain parentage from date ranges.

state_schema:
  text: str
  query_person: str
  query_type: str
  premise: str
  entities: list
  relationships: list
  llm_response: str
  prolog_facts: str
  query_result: list
  derived_facts: list
  reasoning_chain: str
  answer: str

nodes:
  # ============================================================
  # STEP 1: LLM extracts OBSERVABLE FACTS from text
  # ============================================================
  # The LLM extracts ONLY what is explicitly stated or directly observable:
  #   - Entities with birth/death dates
  #   - Explicit relationships (mother, father, married, affair) with dates
  #
  # The LLM does NOT infer:
  #   - child_of_affair (derived by Prolog from dates)
  #   - Uncertain parentage
  # ============================================================
  - name: extract_facts
    uses: llm.call
    with:
      model: gpt-4o
      messages:
        - role: system
          content: |
            You are a fact extraction expert. Extract ONLY OBSERVABLE FACTS from text.

            CRITICAL: Do NOT use external knowledge. Extract ONLY from the provided text.
            CRITICAL: Do NOT infer uncertain relationships. Only extract what is explicit.

            ═══════════════════════════════════════════════════════════════════════
            EXTRACTION SCHEMA
            ═══════════════════════════════════════════════════════════════════════

            OUTPUT FORMAT (JSON only, no markdown):
            {
              "entities": [{"name": "Full Name", "birth_date": "YYYY-MM-DD or null"}],
              "relationships": [
                {"type": "mother|father|married|affair", "subject": "Name", "object": "Name",
                 "start_date": "YYYY-MM-DD or null", "end_date": "YYYY-MM-DD or null"}
              ]
            }

            ═══════════════════════════════════════════════════════════════════════
            RELATIONSHIP TYPES (Extract these)
            ═══════════════════════════════════════════════════════════════════════

            │ Type    │ Subject      │ Object   │ Temporal │ Extract When                    │
            ├─────────┼──────────────┼──────────┼──────────┼─────────────────────────────────┤
            │ mother  │ Mother       │ Child    │ No       │ "X had children", "mother of"   │
            │ father  │ Father       │ Child    │ No       │ "X's sons", explicitly stated   │
            │ parent  │ Parent       │ Child    │ No       │ Gender unknown                  │
            │ married │ Spouse       │ Spouse   │ Yes      │ "married to", wedding date      │
            │ affair  │ Person       │ Partner  │ Yes      │ "affair with", "mistress"       │

            ═══════════════════════════════════════════════════════════════════════
            DATE EXTRACTION RULES
            ═══════════════════════════════════════════════════════════════════════

            • Use ISO 8601: YYYY-MM-DD
            • "born November 14, 1948" → "1948-11-14"
            • "early 1970s" → "1970-01-01"
            • "mid 1980s" → "1985-07-01"
            • "late 1990s" → "1999-12-31"
            • If only year known → "YYYY-01-01"
            • If date unknown → null

            ═══════════════════════════════════════════════════════════════════════
            IMPORTANT: DO NOT EXTRACT
            ═══════════════════════════════════════════════════════════════════════

            • child_of_affair - This will be DERIVED by Prolog from dates
            • Uncertain parentage - Let Prolog infer from temporal overlap
            • Any relationship not explicitly stated in text

            ═══════════════════════════════════════════════════════════════════════

        - role: user
          content: |
            Extract all observable facts from this text:

            ───────────────────────────────────────────────────────────────────────
            {{ state.text }}
            ───────────────────────────────────────────────────────────────────────

            Remember:
            • Extract ONLY from the text above
            • Include birth_date for every person if mentioned
            • Include start_date/end_date for marriages and affairs
            • Do NOT infer child_of_affair - Prolog will derive it

            Return ONLY valid JSON.
      temperature: 0.1
    output: llm_response

  # ============================================================
  # STEP 2: Parse extracted data into entities and relationships
  # ============================================================
  - name: parse_extraction
    run: |
      import json

      llm_response = state.get("llm_response", {})
      content = llm_response.get("content", "") if isinstance(llm_response, dict) else str(llm_response)

      try:
        if "```json" in content:
          content = content.split("```json")[1].split("```")[0]
        elif "```" in content:
          content = content.split("```")[1].split("```")[0]

        data = json.loads(content.strip())
        entities = data.get("entities", [])
        relationships = data.get("relationships", [])
      except Exception as e:
        entities = []
        relationships = []

      return {"entities": entities, "relationships": relationships}

  # ============================================================
  # STEP 3: Convert JSON entities/relationships to Prolog facts
  # ============================================================
  # Generates Prolog-compatible fact assertions:
  #   birth_date(person_name, 'YYYY-MM-DD').
  #   mother(parent_name, child_name).
  #   father(parent_name, child_name).
  #   affair(person, partner, 'start_date', 'end_date').
  # ============================================================
  - name: generate_prolog_facts
    run: |
      entities = state.get("entities", [])
      relationships = state.get("relationships", [])

      prolog_lines = []

      def normalize(name):
        return name.lower().replace(" ", "_").replace("-", "_").replace("'", "").replace(".", "")

      for entity in entities:
        name = normalize(entity.get("name", ""))
        birth = entity.get("birth_date")
        if name and birth:
          prolog_lines.append(f"birth_date({name}, '{birth}').")

      for rel in relationships:
        rel_type = rel.get("type", "")
        subj = normalize(rel.get("subject", ""))
        obj = normalize(rel.get("object", ""))
        start = rel.get("start_date")
        end = rel.get("end_date")

        if rel_type == "mother" and subj and obj:
          prolog_lines.append(f"mother({subj}, {obj}).")
        elif rel_type == "father" and subj and obj:
          prolog_lines.append(f"father({subj}, {obj}).")
        elif rel_type == "affair" and subj and obj:
          start_str = f"'{start}'" if start else "null"
          end_str = f"'{end}'" if end else "null"
          prolog_lines.append(f"affair({subj}, {obj}, {start_str}, {end_str}).")

      return {"prolog_facts": "\n".join(prolog_lines)}

  # ============================================================
  # STEP 4: Prolog DERIVES relationships using temporal inference
  # ============================================================
  # This is where the neurosymbolic magic happens:
  #
  # 1. Load LLM-extracted facts via tea_load_code/1
  # 2. Define inference rules:
  #    - child_of_affair(Child, Partner) ← birth during affair period
  #    - apply_exclusive_premise ← if "one partner", affair child's father = affair partner
  #    - sibling(X, Y) ← same mother AND same father
  #    - half_sibling(X, Y) ← shares ONE parent, not both
  #
  # 3. Apply premise (if exclusive relationship assumed)
  # 4. Query for siblings or half-siblings
  #
  # KEY INSIGHT: The LLM never had to guess parentage.
  #              Prolog derives it from temporal facts.
  # ============================================================
  - name: prolog_reasoning
    language: prolog
    run: |
      :- dynamic mother/2.
      :- dynamic father/2.
      :- dynamic affair/4.
      :- dynamic birth_date/2.

      % Rule definitions (must come before main goal)
      date_in_range(Date, Start, End) :-
          Date @>= Start,
          (End = null -> true ; Date @=< End).

      child_of_affair(Child, AffairPartner) :-
          mother(Mother, Child),
          birth_date(Child, BirthDate),
          affair(Mother, AffairPartner, StartDate, EndDate),
          date_in_range(BirthDate, StartDate, EndDate).
      child_of_affair(Child, AffairPartner) :-
          mother(Mother, Child),
          birth_date(Child, BirthDate),
          affair(AffairPartner, Mother, StartDate, EndDate),
          date_in_range(BirthDate, StartDate, EndDate).

      apply_exclusive_premise :-
          forall(
              child_of_affair(Child, AffairPartner),
              (father(AffairPartner, Child) -> true ; assertz(father(AffairPartner, Child)))
          ).

      sibling(X, Y) :-
          mother(M, X), mother(M, Y),
          father(F, X), father(F, Y),
          X \= Y.

      shares_parent(X, Y) :- mother(M, X), mother(M, Y), X \= Y.
      shares_parent(X, Y) :- father(F, X), father(F, Y), X \= Y.
      not_sibling(X, Y) :- \+ sibling(X, Y).

      half_sibling(X, Y) :-
          shares_parent(X, Y),
          not_sibling(X, Y).

      % Normalize name: lowercase, replace spaces/hyphens with underscores, remove punctuation
      normalize_char(32, 95) :- !.  % space -> underscore
      normalize_char(45, 95) :- !.  % hyphen -> underscore
      normalize_char(C, C).         % default: keep char
      valid_char(C) :- C >= 97, C =< 122, !.  % a-z
      valid_char(95) :- !.                    % underscore
      valid_char(C) :- C >= 48, C =< 57.      % 0-9
      normalize_name(In, Out) :-
          downcase_atom(In, Lower),
          atom_codes(Lower, Codes),
          maplist(normalize_char, Codes, NormCodes),
          include(valid_char, NormCodes, FilteredCodes),
          atom_codes(Out, FilteredCodes).

      % Main execution goal - load facts from state and run queries
      state(prolog_facts, FactsAtom),
      (FactsAtom \= '' -> tea_load_code(FactsAtom) ; true),
      state(query_person, PersonAtom),
      state(query_type, QueryType),
      state(premise, Premise),
      normalize_name(PersonAtom, Person),
      (
        (sub_atom(Premise, _, _, _, 'exclusive') ;
         sub_atom(Premise, _, _, _, 'one partner')) ->
            apply_exclusive_premise
        ; true
      ),
      findall(derived(child_of_affair, C, P), child_of_affair(C, P), DerivedAffair),
      (
        QueryType = 'siblings' ->
          findall(S, sibling(Person, S), Results)
        ; QueryType = 'half_siblings' ->
          findall(H, half_sibling(Person, H), Results)
        ; Results = []
      ),
      length(Results, Count),
      length(DerivedAffair, DerivedCount),
      format(atom(Chain), 'Derived ~w child_of_affair. Found ~w ~w.', [DerivedCount, Count, QueryType]),
      return(query_result, Results),
      return(derived_facts, DerivedAffair),
      return(reasoning_chain, Chain).

  # ============================================================
  # STEP 5: Format human-readable answer
  # ============================================================
  - name: format_answer
    run: |
      query_person = state["query_person"]
      query_type = state["query_type"]
      results = state.get("query_result", [])
      derived = state.get("derived_facts", [])
      reasoning = state.get("reasoning_chain", "")

      def format_name(name):
        return name.replace("_", " ").title()

      formatted = [format_name(r) for r in results]

      if not results:
        answer = f"No {query_type.replace('_', ' ')} found for {query_person}."
      elif query_type == "half_siblings":
        answer = f"**{query_person}'s half-siblings:** {', '.join(formatted)}"
      elif query_type == "siblings":
        answer = f"**{query_person}'s siblings:** {', '.join(formatted)}"
      else:
        answer = f"**Results:** {', '.join(formatted)}"

      if derived:
        answer += f"\n\n**Derived:** {len(derived)} child_of_affair facts from temporal reasoning"

      answer += f"\n\n**Reasoning:** {reasoning}"
      answer += "\n\n---\n*Neurosymbolic AI: LLM extracted facts, Prolog derived relationships*"

      return {"answer": answer}

# Implicit flow: extract_facts -> parse_extraction -> generate_prolog_facts -> prolog_reasoning -> format_answer -> __end__

# ============================================================
# EXAMPLE USAGE
# ============================================================
#
# tea run llm-prolog-family-reasoning.yaml --input '{
#   "text": "Camilla Shand was born in 1947 and married Andrew Parker Bowles in 1973. They had children named Thomas (born 1974) and Laura (born 1978). During her marriage, Camilla had an affair with Prince Charles from the early 1970s until 1999. Diana Spencer was born in 1961 and married Prince Charles in 1981. Diana and Charles had sons Prince William (born 1982) and Prince Harry (born 1984).",
#   "query_person": "Thomas Parker Bowles",
#   "query_type": "half_siblings",
#   "premise": "Camilla only had one partner at a time"
# }'
#
# EXPECTED OUTPUT:
#   **Thomas Parker Bowles's half-siblings:** Prince William, Prince Harry
#
#   **Derived:** 2 child_of_affair facts from temporal reasoning
#
#   **Reasoning:** Derived 2 child_of_affair. Found 2 half_siblings.
#
# REASONING CHAIN:
#   1. LLM extracted: mother(camilla, thomas), affair(camilla, charles, 1970, 1999)
#   2. Prolog derived: child_of_affair(thomas, charles) because 1974 ∈ [1970, 1999]
#   3. Premise applied: father(charles, thomas) (exclusive relationship)
#   4. Query result: half_sibling(thomas, william), half_sibling(thomas, harry)
#      (shares father Charles, different mothers)
#
# ============================================================
