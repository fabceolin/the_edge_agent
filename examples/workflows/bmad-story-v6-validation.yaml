name: bmad-story-v6-validation
description: |
  BMad v6 Validation Workflow - QA Gates Phase using TEA module.

  REQUIREMENT: Install TEA module (Test Architect Enterprise)
  Command: npx bmad-method install → Select "Test Architect (TEA)"

  Validation flow:
  1. PREPARATION PHASE:
     - Resolve story path (story must already exist)

  2. PO VALIDATION PHASE (Story Conformance):
     - PO Validate Story Draft - comprehensive story validation
     - Anti-hallucination verification, template completeness
     - GO/NO-GO decision before TEA QA

  3. QA VALIDATION PHASE (TEA Module):
     - Test Design (TD) - risk assessment + test strategy
     - NFR Assessment (NR) - non-functional requirements
     - Requirements Tracing (TR) - traceability + gate decision
     - Final Validate Story (VS) - checklist

  4. CORRECTION LOOP (if validation failed, max 1 iteration):
     - Correct Course (CC)
     - Re-run validation from PO phase
     - If still fails → INTERRUPT

  Output: Validated story ready for development phase.

  Usage: tea run examples/workflows/bmad-story-v6-validation.yaml --input '{"arg": "epic-1-story-1"}'

state_schema:
  arg: str
  story_path: str
  story_key: str
  # PO Validation phase
  po_validate_output: str
  po_validation_status: str
  po_readiness_score: int
  # QA Validation phase (TEA module)
  test_design_output: str
  risk_level: str
  nfr_output: str
  trace_output: str
  gate_decision: str
  validate_story_output: str
  validation_status: str
  # Correction loop tracking
  correction_attempt: int
  correct_course_output: str

settings:
  shell_providers:
    claude:
      command: claude
      args: ["-p", "{prompt}", "--dangerously-skip-permissions"]
      verbose: true
      timeout: 108000

nodes:
  # ============================================================================
  # NODE 0: Resolve story path
  # ============================================================================
  - name: resolve_story_path
    description: Convert story key to full story path
    run: |
      import os
      import glob
      import yaml

      arg = state.get("arg", "")

      if os.path.isfile(arg):
          story_key = os.path.basename(arg).replace(".md", "")
          return {"story_path": arg, "story_key": story_key}

      config_paths = ["_bmad/bmm/config.yaml", ".bmad/bmm/config.yaml"]
      impl_artifacts = "_bmad-output/implementation-artifacts"

      for config_path in config_paths:
          if os.path.exists(config_path):
              try:
                  with open(config_path, 'r') as f:
                      config = yaml.safe_load(f)
                  impl_artifacts = config.get("implementation_artifacts", impl_artifacts)
                  break
              except:
                  pass

      patterns = [
          os.path.join(impl_artifacts, f"{arg}.md"),
          os.path.join(impl_artifacts, f"*{arg}*.md"),
          f"**/{arg}.md"
      ]

      for pattern in patterns:
          matches = glob.glob(pattern, recursive=True)
          if matches:
              story_path = matches[0]
              story_key = os.path.basename(story_path).replace(".md", "")
              return {"story_path": story_path, "story_key": story_key}

      story_key = arg
      story_path = os.path.join(impl_artifacts, f"{arg}.md")
      return {"story_path": story_path, "story_key": story_key}

  # ============================================================================
  # PO VALIDATION PHASE (Story Conformance)
  # ============================================================================

  - name: po_validate_story_draft
    description: Execute PO validate-story-draft for comprehensive story validation
    uses: llm.call
    with:
      provider: shell
      shell_provider: claude
      timeout: 3600
      messages:
        - role: user
          content: |
            Execute PO Story Draft Validation for: {{ state.story_path }}

            Run command: bmad-bmm-validate-story-draft {{ state.story_path }}

            The PO Validate Story Draft workflow will:
            1. Template completeness validation (all sections present)
            2. File structure and source tree validation
            3. UI/Frontend completeness (if applicable)
            4. Acceptance criteria satisfaction assessment
            5. Testing instructions review
            6. Security considerations assessment
            7. Tasks/subtasks sequence validation
            8. Anti-hallucination verification (source references check)
            9. Dev agent implementation readiness assessment

            INSTRUCTIONS:
            1. Run the workflow completely
            2. Capture the GO/NO-GO decision
            3. Capture the Implementation Readiness Score (1-10)

            After completion, print:
            - PO_VALIDATION_GO or PO_VALIDATION_NOGO
            - READINESS_SCORE:[1-10]
            - Summary of critical issues (if any)
    output: po_validate_output

  - name: check_po_validation
    description: Parse PO validation output and determine if story is ready for TEA QA
    run: |
      import re

      output = state.get("po_validate_output", {})
      if isinstance(output, dict):
          text = output.get("content", "")
      else:
          text = str(output) if output else ""

      # Extract readiness score
      score_match = re.search(r'READINESS_SCORE:\s*(\d+)', text)
      if score_match:
          readiness_score = int(score_match.group(1))
      else:
          readiness_score = 5  # Default to middle score

      # Determine GO/NO-GO
      if "PO_VALIDATION_GO" in text:
          po_validation_status = "GO"
      elif "PO_VALIDATION_NOGO" in text or "NO-GO" in text.upper():
          po_validation_status = "NOGO"
      elif readiness_score >= 7:
          po_validation_status = "GO"
      else:
          po_validation_status = "NOGO"

      correction_attempt = state.get("correction_attempt", 0)

      print(f"""
      ╔════════════════════════════════════════════════════════════╗
      ║              PO VALIDATION PHASE COMPLETE                  ║
      ╠════════════════════════════════════════════════════════════╣
      ║ Story: {state.get('story_key', 'unknown'):<52} ║
      ╠════════════════════════════════════════════════════════════╣
      ║ Implementation Readiness Score: {readiness_score}/10                      ║
      ║ PO Validation Status: {po_validation_status:<37} ║
      ║ Correction Attempts: {correction_attempt:<38} ║
      ╚════════════════════════════════════════════════════════════╝
      """)

      if po_validation_status == "GO":
          print("\n✓ PO VALIDATION PASSED - Proceeding to TEA QA phase...")
      else:
          print("\n⚠️  PO VALIDATION FAILED - Story needs correction before TEA QA...")

      return {
          "po_validation_status": po_validation_status,
          "po_readiness_score": readiness_score
      }

  # ============================================================================
  # QA VALIDATION PHASE (TEA Module)
  # ============================================================================

  # NODE: TEA Test Design (TD) - Risk Assessment + Test Strategy
  - name: tea_test_design
    description: Execute TEA Test Design workflow with risk assessment
    uses: llm.call
    with:
      provider: shell
      shell_provider: claude
      timeout: 3600
      messages:
        - role: user
          content: |
            Execute TEA Test Design (TD) for story: {{ state.story_path }}

            Run command: bmad-tea-test-design

            The Test Design workflow will:
            1. Analyze story requirements
            2. Perform RISK ASSESSMENT (P0-P3 prioritization)
            3. Design test strategy based on risk level
            4. Create test scenarios matrix
            5. Output to test-design folder

            INSTRUCTIONS:
            1. Run the workflow completely
            2. Capture the RISK LEVEL (Critical/High/Medium/Low)
            3. Document test priorities

            After completion, append to story file {{ state.story_path }}:
            ## TEA - Test Design
            - Risk Level: [extracted risk level]
            - Test Strategy: [summary]
            - Priority Tests: [P0/P1 items]

            Print RISK_LEVEL:[Critical|High|Medium|Low] at the end
            Print: TEST_DESIGN_COMPLETED
    output: test_design_output

  # NODE: Extract risk level from test design output
  - name: extract_risk_level
    description: Parse risk level from test design output
    run: |
      import re

      output = state.get("test_design_output", {})
      if isinstance(output, dict):
          text = output.get("content", "")
      else:
          text = str(output) if output else ""

      # Extract risk level
      risk_match = re.search(r'RISK_LEVEL:\s*(Critical|High|Medium|Low)', text, re.IGNORECASE)
      if risk_match:
          risk_level = risk_match.group(1).upper()
      elif "critical" in text.lower():
          risk_level = "CRITICAL"
      elif "high" in text.lower() and "risk" in text.lower():
          risk_level = "HIGH"
      elif "medium" in text.lower():
          risk_level = "MEDIUM"
      else:
          risk_level = "LOW"

      print(f"Risk Level Detected: {risk_level}")
      return {"risk_level": risk_level}

  # NODE: TEA NFR Assessment (NR)
  - name: tea_nfr_assessment
    description: Execute TEA NFR Assessment workflow
    uses: llm.call
    with:
      provider: shell
      shell_provider: claude
      timeout: 3600
      messages:
        - role: user
          content: |
            Execute TEA NFR Assessment (NR) for story: {{ state.story_path }}

            Run command: bmad-tea-nfr

            The NFR Assessment workflow will:
            1. Evaluate non-functional requirements coverage
            2. Check performance requirements
            3. Check security requirements
            4. Check scalability requirements
            5. Check reliability requirements
            6. Identify gaps and recommendations

            INSTRUCTIONS:
            1. Run the workflow completely
            2. Document NFR coverage and gaps

            After completion, append to story file {{ state.story_path }}:
            ## TEA - NFR Assessment
            - Performance: [coverage status]
            - Security: [coverage status]
            - Scalability: [coverage status]
            - Gaps: [identified gaps]

            Print: NFR_ASSESSMENT_COMPLETED
    output: nfr_output

  # NODE: TEA Requirements Tracing (TR) - Gate Decision
  - name: tea_requirements_tracing
    description: Execute TEA Requirements Tracing with gate decision
    uses: llm.call
    with:
      provider: shell
      shell_provider: claude
      timeout: 3600
      messages:
        - role: user
          content: |
            Execute TEA Requirements Tracing (TR) for story: {{ state.story_path }}

            Run command: bmad-tea-trace

            The Requirements Tracing workflow will:
            1. Map all requirements to test coverage
            2. Create traceability matrix
            3. Identify coverage gaps
            4. Make RELEASE GATE DECISION

            INSTRUCTIONS:
            1. Run the workflow completely
            2. Capture the gate decision

            After completion, append to story file {{ state.story_path }}:
            ## TEA - Requirements Trace
            - Coverage: [percentage]
            - Gaps: [identified gaps]
            - Gate Decision: [PASS|CONDITIONAL|FAIL]

            Print GATE_DECISION:[PASS|CONDITIONAL|FAIL] at the end
            Print: TRACE_COMPLETED
    output: trace_output

  # NODE: Extract gate decision
  - name: extract_gate_decision
    description: Parse gate decision from trace output
    run: |
      import re

      output = state.get("trace_output", {})
      if isinstance(output, dict):
          text = output.get("content", "")
      else:
          text = str(output) if output else ""

      gate_match = re.search(r'GATE_DECISION:\s*(PASS|CONDITIONAL|FAIL)', text, re.IGNORECASE)
      if gate_match:
          gate_decision = gate_match.group(1).upper()
      elif "fail" in text.lower() and "gate" in text.lower():
          gate_decision = "FAIL"
      elif "conditional" in text.lower():
          gate_decision = "CONDITIONAL"
      else:
          gate_decision = "PASS"

      print(f"Gate Decision: {gate_decision}")
      return {"gate_decision": gate_decision}

  # NODE: Validate Story (VS) - Final checklist
  - name: validate_story
    description: Execute story validation checklist
    uses: llm.call
    with:
      provider: shell
      shell_provider: claude
      timeout: 3600
      messages:
        - role: user
          content: |
            Execute story validation for: {{ state.story_path }}

            Run command: bmad-bmm-create-story -v {{ state.story_path }}

            QA Gate Status from previous steps:
            - Risk Level: {{ state.risk_level }}
            - Gate Decision: {{ state.gate_decision }}

            VALIDATION CRITERIA:
            1. TEA Test Design section exists
            2. TEA NFR Assessment section exists
            3. TEA Requirements Trace section exists
            4. Gate Decision is PASS or CONDITIONAL
            5. Story meets Definition of Ready

            If gate_decision is FAIL, mark validation as FAILED.
            If all sections exist and gate is PASS/CONDITIONAL, mark as PASSED.

            Print: VALIDATION_PASSED or VALIDATION_FAILED
    output: validate_story_output

  # NODE: Check validation status
  - name: check_validation_status
    description: Determine if story passes QA gates
    run: |
      output = state.get("validate_story_output", {})
      if isinstance(output, dict):
          text = output.get("content", "")
      else:
          text = str(output) if output else ""

      gate_decision = state.get("gate_decision", "UNKNOWN")

      if gate_decision == "FAIL":
          validation_status = "FAILED_GATE"
      elif "VALIDATION_PASSED" in text:
          validation_status = "PASSED"
      elif "VALIDATION_FAILED" in text:
          validation_status = "FAILED"
      else:
          validation_status = "PASSED" if gate_decision in ["PASS", "CONDITIONAL"] else "FAILED"

      correction_attempt = state.get("correction_attempt", 0)

      print(f"""
      ╔════════════════════════════════════════════════════════════╗
      ║              QA VALIDATION PHASE COMPLETE                  ║
      ╠════════════════════════════════════════════════════════════╣
      ║ Story: {state.get('story_key', 'unknown'):<52} ║
      ╠════════════════════════════════════════════════════════════╣
      ║ TEA Test Design:      ✓ Completed                          ║
      ║ TEA NFR Assessment:   ✓ Completed                          ║
      ║ TEA Requirements Trace: ✓ Completed                        ║
      ╠════════════════════════════════════════════════════════════╣
      ║ Risk Level: {state.get('risk_level', 'UNKNOWN'):<47} ║
      ║ Gate Decision: {gate_decision:<44} ║
      ║ VALIDATION STATUS: {validation_status:<40} ║
      ╚════════════════════════════════════════════════════════════╝
      """)

      return {"validation_status": validation_status}

  # ============================================================================
  # CORRECTION LOOP
  # ============================================================================

  - name: correct_course
    description: Execute correct-course to fix validation failures
    uses: llm.call
    with:
      provider: shell
      shell_provider: claude
      timeout: 3600
      messages:
        - role: user
          content: |
            QA Validation FAILED. Execute course correction.

            Run command: bmad-bmm-correct-course

            Story: {{ state.story_path }}
            Gate Decision: {{ state.gate_decision }}
            Risk Level: {{ state.risk_level }}

            ISSUES TO ADDRESS:
            - Review TEA sections in story file
            - Fix requirements coverage gaps
            - Address NFR issues
            - Ensure gate criteria are met

            When done print: CORRECT_COURSE_COMPLETED
    output: correct_course_output

  - name: increment_correction_attempt
    description: Track correction iteration
    run: |
      current = state.get("correction_attempt", 0)
      new_attempt = current + 1

      print(f"""
      ╔════════════════════════════════════════════════════════════╗
      ║        CORRECTION COMPLETED (Attempt {new_attempt})                    ║
      ║ Re-running validation from PO phase...                     ║
      ╚════════════════════════════════════════════════════════════╝
      """)

      return {
          "correction_attempt": new_attempt,
          "po_validate_output": "",
          "po_validation_status": "",
          "po_readiness_score": 0,
          "test_design_output": "",
          "nfr_output": "",
          "trace_output": "",
          "gate_decision": "",
          "validation_status": ""
      }

  - name: validation_failed
    description: Handle validation failure after correction
    run: |
      print(f"""
      ╔════════════════════════════════════════════════════════════╗
      ║           QA GATE FAILED - INTERRUPTED                     ║
      ╠════════════════════════════════════════════════════════════╣
      ║ Story: {state.get('story_key', 'unknown'):<52} ║
      ║ Gate Decision: {state.get('gate_decision', 'FAIL'):<44} ║
      ║ Risk Level: {state.get('risk_level', 'UNKNOWN'):<47} ║
      ╠════════════════════════════════════════════════════════════╣
      ║  ⚠️  Story did not pass QA gates after correction.          ║
      ║  Manual intervention required.                             ║
      ╚════════════════════════════════════════════════════════════╝
      """)
      raise Exception(f"QA Gate FAILED for {state.get('story_key', 'unknown')}")

  # ============================================================================
  # VALIDATION COMPLETE
  # ============================================================================

  - name: validation_complete
    description: Validation phase complete - ready for development
    run: |
      print(f"""
      ╔════════════════════════════════════════════════════════════╗
      ║        VALIDATION PHASE COMPLETE - READY FOR DEV           ║
      ╠════════════════════════════════════════════════════════════╣
      ║ Story: {state.get('story_key', 'unknown'):<52} ║
      ║ Story Path: {state.get('story_path', 'unknown'):<47} ║
      ╠════════════════════════════════════════════════════════════╣
      ║ PO Readiness Score: {state.get('po_readiness_score', 0)}/10                               ║
      ║ PO Validation: {state.get('po_validation_status', 'UNKNOWN'):<44} ║
      ╠════════════════════════════════════════════════════════════╣
      ║ Risk Level: {state.get('risk_level', 'UNKNOWN'):<47} ║
      ║ Gate Decision: {state.get('gate_decision', 'UNKNOWN'):<44} ║
      ║ Validation Status: {state.get('validation_status', 'UNKNOWN'):<40} ║
      ╠════════════════════════════════════════════════════════════╣
      ║ Next: Run bmad-story-v6-development.yaml with same story_path ║
      ╚════════════════════════════════════════════════════════════╝
      """)
      return {}

edges:
  # PREPARATION
  - from: __start__
    to: resolve_story_path
  - from: resolve_story_path
    to: po_validate_story_draft

  # PO VALIDATION ROUTING
  - from: po_validate_story_draft
    to: check_po_validation

  - from: check_po_validation
    to: tea_test_design
    when: "state.get('po_validation_status') == 'GO'"

  - from: check_po_validation
    to: correct_course
    when: "state.get('po_validation_status') != 'GO' and state.get('correction_attempt', 0) == 0"

  - from: check_po_validation
    to: validation_failed
    when: "state.get('po_validation_status') != 'GO' and state.get('correction_attempt', 0) >= 1"

  # QA VALIDATION PHASE (TEA)
  - from: tea_test_design
    to: extract_risk_level
  - from: extract_risk_level
    to: tea_nfr_assessment
  - from: tea_nfr_assessment
    to: tea_requirements_tracing
  - from: tea_requirements_tracing
    to: extract_gate_decision
  - from: extract_gate_decision
    to: validate_story
  - from: validate_story
    to: check_validation_status

  # VALIDATION ROUTING
  - from: check_validation_status
    to: validation_complete
    when: "state.get('validation_status') == 'PASSED'"

  - from: check_validation_status
    to: correct_course
    when: "state.get('validation_status') != 'PASSED' and state.get('correction_attempt', 0) == 0"

  - from: check_validation_status
    to: validation_failed
    when: "state.get('validation_status') != 'PASSED' and state.get('correction_attempt', 0) >= 1"

  # CORRECTION LOOP
  - from: correct_course
    to: increment_correction_attempt
  - from: increment_correction_attempt
    to: po_validate_story_draft
  - from: validation_failed
    to: __end__

  # FINAL
  - from: validation_complete
    to: __end__
