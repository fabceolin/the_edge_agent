name: bmad-story-v6-validation
description: |
  BMad v6 Validation Workflow - QA Gates Phase using TEA module.

  REQUIREMENT: Install TEA module (Test Architect Enterprise)
  Command: npx bmad-method install → Select "Test Architect (TEA)"

  Validation flow:
  1. PREPARATION PHASE:
     - Resolve story path
     - Create Story (CS)

  2. QA VALIDATION PHASE (TEA Module):
     - Test Design (TD) - risk assessment + test strategy
     - NFR Assessment (NR) - non-functional requirements
     - Requirements Tracing (TR) - traceability + gate decision
     - SM Validate Story (VS) - final checklist

  3. CORRECTION LOOP (if validation failed, max 1 iteration):
     - Correct Course (CC)
     - Re-run QA validation
     - If still fails → INTERRUPT

  Output: Validated story ready for development phase.

  Usage: tea run examples/workflows/bmad-story-v6-validation.yaml --input '{"arg": "epic-1-story-1"}'

state_schema:
  arg: str
  story_path: str
  story_key: str
  # QA Validation phase (TEA module)
  test_design_output: str
  risk_level: str
  nfr_output: str
  trace_output: str
  gate_decision: str
  validate_story_output: str
  validation_status: str
  # Correction loop tracking
  correction_attempt: int
  correct_course_output: str

settings:
  shell_providers:
    claude:
      command: claude
      args: ["-p", "{prompt}", "--dangerously-skip-permissions"]
      verbose: true
      timeout: 108000

nodes:
  # ============================================================================
  # NODE 0: Resolve story path
  # ============================================================================
  - name: resolve_story_path
    description: Convert story key to full story path
    run: |
      import os
      import glob
      import yaml

      arg = state.get("arg", "")

      if os.path.isfile(arg):
          story_key = os.path.basename(arg).replace(".md", "")
          return {"story_path": arg, "story_key": story_key}

      config_paths = ["_bmad/bmm/config.yaml", ".bmad/bmm/config.yaml"]
      impl_artifacts = "_bmad-output/implementation-artifacts"

      for config_path in config_paths:
          if os.path.exists(config_path):
              try:
                  with open(config_path, 'r') as f:
                      config = yaml.safe_load(f)
                  impl_artifacts = config.get("implementation_artifacts", impl_artifacts)
                  break
              except:
                  pass

      patterns = [
          os.path.join(impl_artifacts, f"{arg}.md"),
          os.path.join(impl_artifacts, f"*{arg}*.md"),
          f"**/{arg}.md"
      ]

      for pattern in patterns:
          matches = glob.glob(pattern, recursive=True)
          if matches:
              story_path = matches[0]
              story_key = os.path.basename(story_path).replace(".md", "")
              return {"story_path": story_path, "story_key": story_key}

      story_key = arg
      story_path = os.path.join(impl_artifacts, f"{arg}.md")
      return {"story_path": story_path, "story_key": story_key}

  # ============================================================================
  # PREPARATION PHASE
  # ============================================================================

  - name: create_story
    description: Create story if needed using bmad-bmm-create-story
    uses: llm.call
    with:
      provider: shell
      shell_provider: claude
      timeout: 3600
      messages:
        - role: user
          content: |
            Check if story file exists at: {{ state.story_path }}

            If EXISTS with content: Print STORY_EXISTS_SKIPPING_CREATION
            If NOT exists or empty: Run bmad-bmm-create-story for {{ state.story_key }}

            When done with creation print: STORY_CREATED
    output: create_story_output

  # ============================================================================
  # QA VALIDATION PHASE (TEA Module)
  # ============================================================================

  # NODE: TEA Test Design (TD) - Risk Assessment + Test Strategy
  - name: tea_test_design
    description: Execute TEA Test Design workflow with risk assessment
    uses: llm.call
    with:
      provider: shell
      shell_provider: claude
      timeout: 3600
      messages:
        - role: user
          content: |
            Execute TEA Test Design (TD) for story: {{ state.story_path }}

            Run command: bmad-tea-test-design

            The Test Design workflow will:
            1. Analyze story requirements
            2. Perform RISK ASSESSMENT (P0-P3 prioritization)
            3. Design test strategy based on risk level
            4. Create test scenarios matrix
            5. Output to test-design folder

            INSTRUCTIONS:
            1. Run the workflow completely
            2. Capture the RISK LEVEL (Critical/High/Medium/Low)
            3. Document test priorities

            After completion, append to story file {{ state.story_path }}:
            ## TEA - Test Design
            - Risk Level: [extracted risk level]
            - Test Strategy: [summary]
            - Priority Tests: [P0/P1 items]

            Print RISK_LEVEL:[Critical|High|Medium|Low] at the end
            Print: TEST_DESIGN_COMPLETED
    output: test_design_output

  # NODE: Extract risk level from test design output
  - name: extract_risk_level
    description: Parse risk level from test design output
    run: |
      import re

      output = state.get("test_design_output", {})
      if isinstance(output, dict):
          text = output.get("content", "")
      else:
          text = str(output) if output else ""

      # Extract risk level
      risk_match = re.search(r'RISK_LEVEL:\s*(Critical|High|Medium|Low)', text, re.IGNORECASE)
      if risk_match:
          risk_level = risk_match.group(1).upper()
      elif "critical" in text.lower():
          risk_level = "CRITICAL"
      elif "high" in text.lower() and "risk" in text.lower():
          risk_level = "HIGH"
      elif "medium" in text.lower():
          risk_level = "MEDIUM"
      else:
          risk_level = "LOW"

      print(f"Risk Level Detected: {risk_level}")
      return {"risk_level": risk_level}

  # NODE: TEA NFR Assessment (NR)
  - name: tea_nfr_assessment
    description: Execute TEA NFR Assessment workflow
    uses: llm.call
    with:
      provider: shell
      shell_provider: claude
      timeout: 3600
      messages:
        - role: user
          content: |
            Execute TEA NFR Assessment (NR) for story: {{ state.story_path }}

            Run command: bmad-tea-nfr

            The NFR Assessment workflow will:
            1. Evaluate non-functional requirements coverage
            2. Check performance requirements
            3. Check security requirements
            4. Check scalability requirements
            5. Check reliability requirements
            6. Identify gaps and recommendations

            INSTRUCTIONS:
            1. Run the workflow completely
            2. Document NFR coverage and gaps

            After completion, append to story file {{ state.story_path }}:
            ## TEA - NFR Assessment
            - Performance: [coverage status]
            - Security: [coverage status]
            - Scalability: [coverage status]
            - Gaps: [identified gaps]

            Print: NFR_ASSESSMENT_COMPLETED
    output: nfr_output

  # NODE: TEA Requirements Tracing (TR) - Gate Decision
  - name: tea_requirements_tracing
    description: Execute TEA Requirements Tracing with gate decision
    uses: llm.call
    with:
      provider: shell
      shell_provider: claude
      timeout: 3600
      messages:
        - role: user
          content: |
            Execute TEA Requirements Tracing (TR) for story: {{ state.story_path }}

            Run command: bmad-tea-trace

            The Requirements Tracing workflow will:
            1. Map all requirements to test coverage
            2. Create traceability matrix
            3. Identify coverage gaps
            4. Make RELEASE GATE DECISION

            INSTRUCTIONS:
            1. Run the workflow completely
            2. Capture the gate decision

            After completion, append to story file {{ state.story_path }}:
            ## TEA - Requirements Trace
            - Coverage: [percentage]
            - Gaps: [identified gaps]
            - Gate Decision: [PASS|CONDITIONAL|FAIL]

            Print GATE_DECISION:[PASS|CONDITIONAL|FAIL] at the end
            Print: TRACE_COMPLETED
    output: trace_output

  # NODE: Extract gate decision
  - name: extract_gate_decision
    description: Parse gate decision from trace output
    run: |
      import re

      output = state.get("trace_output", {})
      if isinstance(output, dict):
          text = output.get("content", "")
      else:
          text = str(output) if output else ""

      gate_match = re.search(r'GATE_DECISION:\s*(PASS|CONDITIONAL|FAIL)', text, re.IGNORECASE)
      if gate_match:
          gate_decision = gate_match.group(1).upper()
      elif "fail" in text.lower() and "gate" in text.lower():
          gate_decision = "FAIL"
      elif "conditional" in text.lower():
          gate_decision = "CONDITIONAL"
      else:
          gate_decision = "PASS"

      print(f"Gate Decision: {gate_decision}")
      return {"gate_decision": gate_decision}

  # NODE: Validate Story (VS) - Final checklist
  - name: validate_story
    description: Execute story validation checklist
    uses: llm.call
    with:
      provider: shell
      shell_provider: claude
      timeout: 3600
      messages:
        - role: user
          content: |
            Execute story validation for: {{ state.story_path }}

            Run command: bmad-bmm-create-story -v {{ state.story_path }}

            QA Gate Status from previous steps:
            - Risk Level: {{ state.risk_level }}
            - Gate Decision: {{ state.gate_decision }}

            VALIDATION CRITERIA:
            1. TEA Test Design section exists
            2. TEA NFR Assessment section exists
            3. TEA Requirements Trace section exists
            4. Gate Decision is PASS or CONDITIONAL
            5. Story meets Definition of Ready

            If gate_decision is FAIL, mark validation as FAILED.
            If all sections exist and gate is PASS/CONDITIONAL, mark as PASSED.

            Print: VALIDATION_PASSED or VALIDATION_FAILED
    output: validate_story_output

  # NODE: Check validation status
  - name: check_validation_status
    description: Determine if story passes QA gates
    run: |
      output = state.get("validate_story_output", {})
      if isinstance(output, dict):
          text = output.get("content", "")
      else:
          text = str(output) if output else ""

      gate_decision = state.get("gate_decision", "UNKNOWN")

      if gate_decision == "FAIL":
          validation_status = "FAILED_GATE"
      elif "VALIDATION_PASSED" in text:
          validation_status = "PASSED"
      elif "VALIDATION_FAILED" in text:
          validation_status = "FAILED"
      else:
          validation_status = "PASSED" if gate_decision in ["PASS", "CONDITIONAL"] else "FAILED"

      correction_attempt = state.get("correction_attempt", 0)

      print(f"""
      ╔════════════════════════════════════════════════════════════╗
      ║              QA VALIDATION PHASE COMPLETE                  ║
      ╠════════════════════════════════════════════════════════════╣
      ║ Story: {state.get('story_key', 'unknown'):<52} ║
      ╠════════════════════════════════════════════════════════════╣
      ║ TEA Test Design:      ✓ Completed                          ║
      ║ TEA NFR Assessment:   ✓ Completed                          ║
      ║ TEA Requirements Trace: ✓ Completed                        ║
      ╠════════════════════════════════════════════════════════════╣
      ║ Risk Level: {state.get('risk_level', 'UNKNOWN'):<47} ║
      ║ Gate Decision: {gate_decision:<44} ║
      ║ VALIDATION STATUS: {validation_status:<40} ║
      ╚════════════════════════════════════════════════════════════╝
      """)

      return {"validation_status": validation_status}

  # ============================================================================
  # CORRECTION LOOP
  # ============================================================================

  - name: correct_course
    description: Execute correct-course to fix validation failures
    uses: llm.call
    with:
      provider: shell
      shell_provider: claude
      timeout: 3600
      messages:
        - role: user
          content: |
            QA Validation FAILED. Execute course correction.

            Run command: bmad-bmm-correct-course

            Story: {{ state.story_path }}
            Gate Decision: {{ state.gate_decision }}
            Risk Level: {{ state.risk_level }}

            ISSUES TO ADDRESS:
            - Review TEA sections in story file
            - Fix requirements coverage gaps
            - Address NFR issues
            - Ensure gate criteria are met

            When done print: CORRECT_COURSE_COMPLETED
    output: correct_course_output

  - name: increment_correction_attempt
    description: Track correction iteration
    run: |
      current = state.get("correction_attempt", 0)
      new_attempt = current + 1

      print(f"""
      ╔════════════════════════════════════════════════════════════╗
      ║        CORRECTION COMPLETED (Attempt {new_attempt})                    ║
      ║ Re-running QA validation phase...                          ║
      ╚════════════════════════════════════════════════════════════╝
      """)

      return {
          "correction_attempt": new_attempt,
          "test_design_output": "",
          "nfr_output": "",
          "trace_output": "",
          "gate_decision": "",
          "validation_status": ""
      }

  - name: validation_failed
    description: Handle validation failure after correction
    run: |
      print(f"""
      ╔════════════════════════════════════════════════════════════╗
      ║           QA GATE FAILED - INTERRUPTED                     ║
      ╠════════════════════════════════════════════════════════════╣
      ║ Story: {state.get('story_key', 'unknown'):<52} ║
      ║ Gate Decision: {state.get('gate_decision', 'FAIL'):<44} ║
      ║ Risk Level: {state.get('risk_level', 'UNKNOWN'):<47} ║
      ╠════════════════════════════════════════════════════════════╣
      ║  ⚠️  Story did not pass QA gates after correction.          ║
      ║  Manual intervention required.                             ║
      ╚════════════════════════════════════════════════════════════╝
      """)
      raise Exception(f"QA Gate FAILED for {state.get('story_key', 'unknown')}")

  # ============================================================================
  # VALIDATION COMPLETE
  # ============================================================================

  - name: validation_complete
    description: Validation phase complete - ready for development
    run: |
      print(f"""
      ╔════════════════════════════════════════════════════════════╗
      ║        VALIDATION PHASE COMPLETE - READY FOR DEV           ║
      ╠════════════════════════════════════════════════════════════╣
      ║ Story: {state.get('story_key', 'unknown'):<52} ║
      ║ Story Path: {state.get('story_path', 'unknown'):<47} ║
      ║ Risk Level: {state.get('risk_level', 'UNKNOWN'):<47} ║
      ║ Gate Decision: {state.get('gate_decision', 'UNKNOWN'):<44} ║
      ║ Validation Status: {state.get('validation_status', 'UNKNOWN'):<40} ║
      ╠════════════════════════════════════════════════════════════╣
      ║ Next: Run bmad-story-v6-development.yaml with same story_path ║
      ╚════════════════════════════════════════════════════════════╝
      """)
      return {}

edges:
  # PREPARATION
  - from: __start__
    to: resolve_story_path
  - from: resolve_story_path
    to: create_story
  - from: create_story
    to: tea_test_design

  # QA VALIDATION PHASE (TEA)
  - from: tea_test_design
    to: extract_risk_level
  - from: extract_risk_level
    to: tea_nfr_assessment
  - from: tea_nfr_assessment
    to: tea_requirements_tracing
  - from: tea_requirements_tracing
    to: extract_gate_decision
  - from: extract_gate_decision
    to: validate_story
  - from: validate_story
    to: check_validation_status

  # VALIDATION ROUTING
  - from: check_validation_status
    to: validation_complete
    when: "state.get('validation_status') == 'PASSED'"

  - from: check_validation_status
    to: correct_course
    when: "state.get('validation_status') != 'PASSED' and state.get('correction_attempt', 0) == 0"

  - from: check_validation_status
    to: validation_failed
    when: "state.get('validation_status') != 'PASSED' and state.get('correction_attempt', 0) >= 1"

  # CORRECTION LOOP
  - from: correct_course
    to: increment_correction_attempt
  - from: increment_correction_attempt
    to: tea_test_design
  - from: validation_failed
    to: __end__

  # FINAL
  - from: validation_complete
    to: __end__
