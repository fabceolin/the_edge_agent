name: bmad-story-v6-validation
description: |
  BMad v6 Validation Workflow - Full QA Gates Phase using TEA module.

  REQUIREMENT: Install TEA module (Test Architect Enterprise)
  Command: npx bmad-method install → Select "Test Architect (TEA)"

  This workflow creates TEA artifacts (test-design, nfr-assessment, traceability) if they don't exist.
  For simple validation WITHOUT TEA, use bmad-story-v6-validation-simple.yaml instead.

  Skip Logic:
  - Stories in 'done' or 'in-progress' status: Skip all validation
  - Stories in 'ready-for-dev' WITH TEA artifacts: Skip all validation
  - Stories in 'ready-for-dev' WITHOUT TEA artifacts: Run TEA phases to create them

  Validation flow:
  1. PREPARATION PHASE:
     - Resolve story path (story must already exist)
     - Check for existing TEA artifacts

  2. PO VALIDATION PHASE (Story Conformance):
     - Validate story using create-story checklist
     - GO/NO-GO decision before TEA QA

  3. QA VALIDATION PHASE (TEA Module):
     - Test Design (TD) - risk assessment + test strategy
     - NFR Assessment (NR) - non-functional requirements
     - Requirements Tracing (TR) - traceability + gate decision
     - Final Validate Story (VS) - checklist

  4. CORRECTION LOOP (if validation failed, max 1 iteration):
     - Correct Course (CC)
     - Re-run validation from PO phase
     - If still fails → INTERRUPT

  Output: Validated story with TEA artifacts, ready for development phase.

  Usage: tea run examples/workflows/bmad-story-v6-validation.yaml --input '{"arg": "epic-1-story-1"}'

state_schema:
  arg: str
  story_path: str
  story_key: str
  story_id: str
  # Skip validation check
  already_validated: bool
  current_status: str
  # TEA artifacts check
  tea_artifacts_exist: bool
  tea_test_design_path: str
  tea_nfr_path: str
  tea_trace_path: str
  # PO Validation phase
  po_validate_output: str
  po_validation_status: str
  po_readiness_score: int
  # QA Validation phase (TEA module)
  test_design_output: str
  risk_level: str
  nfr_output: str
  trace_output: str
  gate_decision: str
  validate_story_output: str
  validation_status: str
  # Correction loop tracking
  correction_attempt: int
  correct_course_output: str

settings:
  shell_providers:
    claude:
      command: claude
      args: ["-p", "{prompt}", "--dangerously-skip-permissions"]
      verbose: true
      timeout: 108000

nodes:
  # ============================================================================
  # NODE 0: Resolve story path, check status, and check for TEA artifacts
  # ============================================================================
  - name: resolve_story_path
    description: Convert story key to full story path, check status and TEA artifacts
    run: |
      import os
      import glob
      import yaml
      import re

      arg = state.get("arg", "")
      story_path = None
      story_key = None

      if os.path.isfile(arg):
          story_path = arg
          story_key = os.path.basename(arg).replace(".md", "")
      else:
          config_paths = ["_bmad/bmm/config.yaml", ".bmad/bmm/config.yaml"]
          impl_artifacts = "_bmad-output/implementation-artifacts"

          for config_path in config_paths:
              if os.path.exists(config_path):
                  try:
                      with open(config_path, 'r') as f:
                          config = yaml.safe_load(f)
                      impl_artifacts = config.get("implementation_artifacts", impl_artifacts)
                      break
                  except:
                      pass

          patterns = [
              os.path.join(impl_artifacts, f"{arg}.md"),
              os.path.join(impl_artifacts, f"*{arg}*.md"),
              f"**/{arg}.md"
          ]

          for pattern in patterns:
              matches = glob.glob(pattern, recursive=True)
              if matches:
                  story_path = matches[0]
                  story_key = os.path.basename(story_path).replace(".md", "")
                  break

          if not story_path:
              story_key = arg
              story_path = os.path.join(impl_artifacts, f"{arg}.md")

      # Extract story ID (e.g., "1-3" from "1-3-neo4j-connection-management")
      story_id = ""
      if story_key:
          id_match = re.match(r'^(\d+-\d+)', story_key)
          if id_match:
              story_id = id_match.group(1)

      # Check if story is already in ready-for-dev or done status
      already_validated = False
      current_status = "unknown"
      if story_path and os.path.isfile(story_path):
          try:
              with open(story_path, 'r') as f:
                  content = f.read(500)  # Read first 500 chars for status
              status_match = re.search(r'^Status:\s*(\S+)', content, re.MULTILINE)
              if status_match:
                  current_status = status_match.group(1).lower()
          except:
              pass

      # Check for TEA artifacts
      tea_artifacts_dir = "_bmad-output/test-artifacts"
      tea_test_design_path = os.path.join(tea_artifacts_dir, "test-design", f"test-design-story-{story_id}.md")
      tea_nfr_path = os.path.join(tea_artifacts_dir, "nfr-assessments", f"nfr-assessment-story-{story_id}.md")
      tea_trace_path = os.path.join(tea_artifacts_dir, "traceability", f"trace-story-{story_id}.md")

      tea_test_design_exists = os.path.isfile(tea_test_design_path)
      tea_nfr_exists = os.path.isfile(tea_nfr_path)
      tea_trace_exists = os.path.isfile(tea_trace_path)
      tea_artifacts_exist = tea_test_design_exists and tea_nfr_exists and tea_trace_exists

      # Determine if we should skip validation entirely
      # Only skip if status is done or in-progress (actual development states)
      if current_status in ['done', 'in-progress']:
          already_validated = True
          print(f"Story in '{current_status}' status - skipping all validation")

      # For ready-for-dev status, check if TEA artifacts exist
      # If TEA artifacts exist, the story is fully validated
      # If not, we need to run TEA validation to create them
      if current_status == 'ready-for-dev':
          if tea_artifacts_exist:
              already_validated = True
              print(f"Story in 'ready-for-dev' with TEA artifacts - skipping validation")
          else:
              print(f"Story in 'ready-for-dev' but MISSING TEA artifacts - will run TEA validation")

      print(f"""
      ╔════════════════════════════════════════════════════════════╗
      ║              STORY PATH RESOLUTION                         ║
      ╠════════════════════════════════════════════════════════════╣
      ║ Story: {story_key:<52} ║
      ║ Story ID: {story_id:<49} ║
      ║ Status: {current_status:<51} ║
      ╠════════════════════════════════════════════════════════════╣
      ║ TEA Test Design: {'✓ EXISTS' if tea_test_design_exists else '✗ MISSING':<42} ║
      ║ TEA NFR Assessment: {'✓ EXISTS' if tea_nfr_exists else '✗ MISSING':<39} ║
      ║ TEA Traceability: {'✓ EXISTS' if tea_trace_exists else '✗ MISSING':<41} ║
      ╠════════════════════════════════════════════════════════════╣
      ║ All TEA Artifacts: {'✓ COMPLETE' if tea_artifacts_exist else '✗ INCOMPLETE':<40} ║
      ║ Skip Validation: {'YES' if already_validated else 'NO':<42} ║
      ╚════════════════════════════════════════════════════════════╝
      """)

      return {
          "story_path": story_path,
          "story_key": story_key,
          "story_id": story_id,
          "already_validated": already_validated,
          "current_status": current_status,
          "tea_artifacts_exist": tea_artifacts_exist,
          "tea_test_design_path": tea_test_design_path,
          "tea_nfr_path": tea_nfr_path,
          "tea_trace_path": tea_trace_path
      }

  # ============================================================================
  # PO VALIDATION PHASE (Story Conformance)
  # ============================================================================

  - name: po_validate_story_draft
    description: Validate story using create-story checklist
    uses: llm.call
    with:
      provider: shell
      shell_provider: claude
      timeout: 3600
      messages:
        - role: user
          content: |
            Validate this story using the create-story checklist:
            {{ state.story_path }}

            This will:
            1. Load the story file
            2. Load workflow.yaml for variable context
            3. Load source documents (epics, architecture, etc.)
            4. Run the systematic 5-step analysis from the checklist
            5. Present findings with critical/enhancement/optimization categories

            INSTRUCTIONS:
            1. Run the validation completely
            2. Review all findings
            3. If there are CRITICAL issues that block development, note them
            4. If no critical blockers, the story is ready

            After validation, determine readiness:
            - Count critical issues found
            - Assess overall implementation readiness (1-10 scale)

            At the end, print EXACTLY these lines:
            - If ready: PO_VALIDATION_GO
            - If not ready: PO_VALIDATION_NOGO
            - Always print: READINESS_SCORE:[1-10] (e.g., READINESS_SCORE:8)
            - Summary of critical issues if any
    output: po_validate_output

  - name: check_po_validation
    description: Parse PO validation output and determine if story is ready for TEA QA
    run: |
      import re

      output = state.get("po_validate_output", {})
      if isinstance(output, dict):
          text = output.get("content", "")
      else:
          text = str(output) if output else ""

      # Extract readiness score
      score_match = re.search(r'READINESS_SCORE:\s*(\d+)', text)
      if score_match:
          readiness_score = int(score_match.group(1))
      else:
          readiness_score = 5  # Default to middle score

      # Determine GO/NO-GO
      if "PO_VALIDATION_GO" in text:
          po_validation_status = "GO"
      elif "PO_VALIDATION_NOGO" in text or "NO-GO" in text.upper():
          po_validation_status = "NOGO"
      elif readiness_score >= 7:
          po_validation_status = "GO"
      else:
          po_validation_status = "NOGO"

      correction_attempt = state.get("correction_attempt", 0)

      print(f"""
      ╔════════════════════════════════════════════════════════════╗
      ║              PO VALIDATION PHASE COMPLETE                  ║
      ╠════════════════════════════════════════════════════════════╣
      ║ Story: {state.get('story_key', 'unknown'):<52} ║
      ╠════════════════════════════════════════════════════════════╣
      ║ Implementation Readiness Score: {readiness_score}/10                      ║
      ║ PO Validation Status: {po_validation_status:<37} ║
      ║ Correction Attempts: {correction_attempt:<38} ║
      ╚════════════════════════════════════════════════════════════╝
      """)

      if po_validation_status == "GO":
          print("\n✓ PO VALIDATION PASSED - Proceeding to TEA QA phase...")
      else:
          print("\n⚠️  PO VALIDATION FAILED - Story needs correction before TEA QA...")

      return {
          "po_validation_status": po_validation_status,
          "po_readiness_score": readiness_score
      }

  # ============================================================================
  # QA VALIDATION PHASE (TEA Module)
  # ============================================================================

  # NODE: TEA Test Design (TD) - Risk Assessment + Test Strategy
  - name: tea_test_design
    description: Execute TEA Test Design workflow with risk assessment
    uses: llm.call
    with:
      provider: shell
      shell_provider: claude
      timeout: 3600
      messages:
        - role: user
          content: |
            Execute TEA Test Design (TD) for story: {{ state.story_path }}

            Run command: bmad-tea-testarch-test-design

            The Test Design workflow will:
            1. Analyze story requirements
            2. Perform RISK ASSESSMENT (P0-P3 prioritization)
            3. Design test strategy based on risk level
            4. Create test scenarios matrix
            5. Output to test-design folder

            INSTRUCTIONS:
            1. Run the workflow completely
            2. Capture the RISK LEVEL (Critical/High/Medium/Low)
            3. Document test priorities

            After completion, append to story file {{ state.story_path }}:
            ## TEA - Test Design
            - Risk Level: [extracted risk level]
            - Test Strategy: [summary]
            - Priority Tests: [P0/P1 items]

            Print RISK_LEVEL:[Critical|High|Medium|Low] at the end
            Print: TEST_DESIGN_COMPLETED
    output: test_design_output

  # NODE: Extract risk level from test design output
  - name: extract_risk_level
    description: Parse risk level from test design output
    run: |
      import re

      output = state.get("test_design_output", {})
      if isinstance(output, dict):
          text = output.get("content", "")
      else:
          text = str(output) if output else ""

      # Extract risk level
      risk_match = re.search(r'RISK_LEVEL:\s*(Critical|High|Medium|Low)', text, re.IGNORECASE)
      if risk_match:
          risk_level = risk_match.group(1).upper()
      elif "critical" in text.lower():
          risk_level = "CRITICAL"
      elif "high" in text.lower() and "risk" in text.lower():
          risk_level = "HIGH"
      elif "medium" in text.lower():
          risk_level = "MEDIUM"
      else:
          risk_level = "LOW"

      print(f"Risk Level Detected: {risk_level}")
      return {"risk_level": risk_level}

  # NODE: TEA NFR Assessment (NR)
  - name: tea_nfr_assessment
    description: Execute TEA NFR Assessment workflow
    uses: llm.call
    with:
      provider: shell
      shell_provider: claude
      timeout: 3600
      messages:
        - role: user
          content: |
            Execute TEA NFR Assessment (NR) for story: {{ state.story_path }}

            Run command: bmad-tea-testarch-nfr

            The NFR Assessment workflow will:
            1. Evaluate non-functional requirements coverage
            2. Check performance requirements
            3. Check security requirements
            4. Check scalability requirements
            5. Check reliability requirements
            6. Identify gaps and recommendations

            INSTRUCTIONS:
            1. Run the workflow completely
            2. Document NFR coverage and gaps

            After completion, append to story file {{ state.story_path }}:
            ## TEA - NFR Assessment
            - Performance: [coverage status]
            - Security: [coverage status]
            - Scalability: [coverage status]
            - Gaps: [identified gaps]

            Print: NFR_ASSESSMENT_COMPLETED
    output: nfr_output

  # NODE: TEA Requirements Tracing (TR) - Gate Decision
  - name: tea_requirements_tracing
    description: Execute TEA Requirements Tracing with gate decision
    uses: llm.call
    with:
      provider: shell
      shell_provider: claude
      timeout: 3600
      messages:
        - role: user
          content: |
            Execute TEA Requirements Tracing (TR) for story: {{ state.story_path }}

            Run command: bmad-tea-testarch-trace

            The Requirements Tracing workflow will:
            1. Map all requirements to test coverage
            2. Create traceability matrix
            3. Identify coverage gaps
            4. Make RELEASE GATE DECISION

            INSTRUCTIONS:
            1. Run the workflow completely
            2. Capture the gate decision

            After completion, append to story file {{ state.story_path }}:
            ## TEA - Requirements Trace
            - Coverage: [percentage]
            - Gaps: [identified gaps]
            - Gate Decision: [PASS|CONDITIONAL|FAIL]

            Print GATE_DECISION:[PASS|CONDITIONAL|FAIL] at the end
            Print: TRACE_COMPLETED
    output: trace_output

  # NODE: Extract gate decision
  - name: extract_gate_decision
    description: Parse gate decision from trace output
    run: |
      import re

      output = state.get("trace_output", {})
      if isinstance(output, dict):
          text = output.get("content", "")
      else:
          text = str(output) if output else ""

      gate_match = re.search(r'GATE_DECISION:\s*(PASS|CONDITIONAL|FAIL)', text, re.IGNORECASE)
      if gate_match:
          gate_decision = gate_match.group(1).upper()
      elif "fail" in text.lower() and "gate" in text.lower():
          gate_decision = "FAIL"
      elif "conditional" in text.lower():
          gate_decision = "CONDITIONAL"
      else:
          gate_decision = "PASS"

      print(f"Gate Decision: {gate_decision}")
      return {"gate_decision": gate_decision}

  # NODE: Validate Story (VS) - Final checklist
  - name: validate_story
    description: Execute story validation checklist
    uses: llm.call
    with:
      provider: shell
      shell_provider: claude
      timeout: 3600
      messages:
        - role: user
          content: |
            Execute story validation for: {{ state.story_path }}

            Run command: bmad-bmm-create-story -v {{ state.story_path }}

            QA Gate Status from previous steps:
            - Risk Level: {{ state.risk_level }}
            - Gate Decision: {{ state.gate_decision }}

            VALIDATION CRITERIA:
            1. TEA Test Design section exists
            2. TEA NFR Assessment section exists
            3. TEA Requirements Trace section exists
            4. Gate Decision is PASS or CONDITIONAL
            5. Story meets Definition of Ready

            If gate_decision is FAIL, mark validation as FAILED.
            If all sections exist and gate is PASS/CONDITIONAL, mark as PASSED.

            Print: VALIDATION_PASSED or VALIDATION_FAILED
    output: validate_story_output

  # NODE: Check validation status
  - name: check_validation_status
    description: Determine if story passes QA gates
    run: |
      output = state.get("validate_story_output", {})
      if isinstance(output, dict):
          text = output.get("content", "")
      else:
          text = str(output) if output else ""

      gate_decision = state.get("gate_decision", "UNKNOWN")

      if gate_decision == "FAIL":
          validation_status = "FAILED_GATE"
      elif "VALIDATION_PASSED" in text:
          validation_status = "PASSED"
      elif "VALIDATION_FAILED" in text:
          validation_status = "FAILED"
      else:
          validation_status = "PASSED" if gate_decision in ["PASS", "CONDITIONAL"] else "FAILED"

      correction_attempt = state.get("correction_attempt", 0)

      print(f"""
      ╔════════════════════════════════════════════════════════════╗
      ║              QA VALIDATION PHASE COMPLETE                  ║
      ╠════════════════════════════════════════════════════════════╣
      ║ Story: {state.get('story_key', 'unknown'):<52} ║
      ╠════════════════════════════════════════════════════════════╣
      ║ TEA Test Design:      ✓ Completed                          ║
      ║ TEA NFR Assessment:   ✓ Completed                          ║
      ║ TEA Requirements Trace: ✓ Completed                        ║
      ╠════════════════════════════════════════════════════════════╣
      ║ Risk Level: {state.get('risk_level', 'UNKNOWN'):<47} ║
      ║ Gate Decision: {gate_decision:<44} ║
      ║ VALIDATION STATUS: {validation_status:<40} ║
      ╚════════════════════════════════════════════════════════════╝
      """)

      return {"validation_status": validation_status}

  # ============================================================================
  # CORRECTION LOOP
  # ============================================================================

  - name: correct_course
    description: Execute correct-course to fix validation failures
    uses: llm.call
    with:
      provider: shell
      shell_provider: claude
      timeout: 3600
      messages:
        - role: user
          content: |
            QA Validation FAILED. Execute course correction.

            Run command: bmad-bmm-correct-course

            Story: {{ state.story_path }}
            Gate Decision: {{ state.gate_decision }}
            Risk Level: {{ state.risk_level }}

            ISSUES TO ADDRESS:
            - Review TEA sections in story file
            - Fix requirements coverage gaps
            - Address NFR issues
            - Ensure gate criteria are met

            When done print: CORRECT_COURSE_COMPLETED
    output: correct_course_output

  - name: increment_correction_attempt
    description: Track correction iteration
    run: |
      current = state.get("correction_attempt", 0)
      new_attempt = current + 1

      print(f"""
      ╔════════════════════════════════════════════════════════════╗
      ║        CORRECTION COMPLETED (Attempt {new_attempt})                    ║
      ║ Re-running validation from PO phase...                     ║
      ╚════════════════════════════════════════════════════════════╝
      """)

      return {
          "correction_attempt": new_attempt,
          "po_validate_output": "",
          "po_validation_status": "",
          "po_readiness_score": 0,
          "test_design_output": "",
          "nfr_output": "",
          "trace_output": "",
          "gate_decision": "",
          "validation_status": ""
      }

  - name: validation_failed
    description: Handle validation failure after correction
    run: |
      print(f"""
      ╔════════════════════════════════════════════════════════════╗
      ║           QA GATE FAILED - INTERRUPTED                     ║
      ╠════════════════════════════════════════════════════════════╣
      ║ Story: {state.get('story_key', 'unknown'):<52} ║
      ║ Gate Decision: {state.get('gate_decision', 'FAIL'):<44} ║
      ║ Risk Level: {state.get('risk_level', 'UNKNOWN'):<47} ║
      ╠════════════════════════════════════════════════════════════╣
      ║  ⚠️  Story did not pass QA gates after correction.          ║
      ║  Manual intervention required.                             ║
      ╚════════════════════════════════════════════════════════════╝
      """)
      raise Exception(f"QA Gate FAILED for {state.get('story_key', 'unknown')}")

  # ============================================================================
  # VALIDATION COMPLETE
  # ============================================================================

  - name: validation_complete
    description: Validation phase complete - ready for development
    run: |
      already_validated = state.get('already_validated', False)
      current_status = state.get('current_status', 'unknown')
      tea_artifacts_exist = state.get('tea_artifacts_exist', False)

      if already_validated:
          print(f"""
      ╔════════════════════════════════════════════════════════════╗
      ║        VALIDATION SKIPPED - ALREADY READY FOR DEV          ║
      ╠════════════════════════════════════════════════════════════╣
      ║ Story: {state.get('story_key', 'unknown'):<52} ║
      ║ Story Path: {state.get('story_path', 'unknown')[:47]:<47} ║
      ╠════════════════════════════════════════════════════════════╣
      ║ Current Status: {current_status:<43} ║
      ║ TEA Artifacts: {'✓ COMPLETE' if tea_artifacts_exist else '✗ INCOMPLETE':<48} ║
      ║ Validation: SKIPPED (already in valid state)               ║
      ╠════════════════════════════════════════════════════════════╣
      ║ Next: Run development workflow with same story             ║
      ╚════════════════════════════════════════════════════════════╝
          """)
      else:
          print(f"""
      ╔════════════════════════════════════════════════════════════╗
      ║        TEA VALIDATION COMPLETE - READY FOR DEV             ║
      ╠════════════════════════════════════════════════════════════╣
      ║ Story: {state.get('story_key', 'unknown'):<52} ║
      ║ Story Path: {state.get('story_path', 'unknown')[:47]:<47} ║
      ╠════════════════════════════════════════════════════════════╣
      ║ PO Readiness Score: {state.get('po_readiness_score', 0)}/10                               ║
      ║ PO Validation: {state.get('po_validation_status', 'UNKNOWN'):<44} ║
      ╠════════════════════════════════════════════════════════════╣
      ║ TEA Test Design: ✓ Created                                 ║
      ║ TEA NFR Assessment: ✓ Created                              ║
      ║ TEA Traceability: ✓ Created                                ║
      ╠════════════════════════════════════════════════════════════╣
      ║ Risk Level: {state.get('risk_level', 'UNKNOWN'):<47} ║
      ║ Gate Decision: {state.get('gate_decision', 'UNKNOWN'):<44} ║
      ║ Validation Status: {state.get('validation_status', 'UNKNOWN'):<40} ║
      ╠════════════════════════════════════════════════════════════╣
      ║ Next: Run development workflow with same story             ║
      ╚════════════════════════════════════════════════════════════╝
          """)
      return {}

edges:
  # PREPARATION
  - from: __start__
    to: resolve_story_path

  # Skip validation completely if story already validated AND TEA artifacts exist
  - from: resolve_story_path
    to: validation_complete
    when: "state.get('already_validated', False) == True and state.get('tea_artifacts_exist', False) == True"

  # If already validated but no TEA artifacts, run TEA phases only to create them
  - from: resolve_story_path
    to: tea_test_design
    when: "state.get('already_validated', False) == True and state.get('tea_artifacts_exist', False) != True"

  # Normal flow: proceed to PO validation if not already validated
  - from: resolve_story_path
    to: po_validate_story_draft
    when: "state.get('already_validated', False) != True"

  # PO VALIDATION ROUTING
  - from: po_validate_story_draft
    to: check_po_validation

  - from: check_po_validation
    to: tea_test_design
    when: "state.get('po_validation_status') == 'GO'"

  - from: check_po_validation
    to: correct_course
    when: "state.get('po_validation_status') != 'GO' and state.get('correction_attempt', 0) == 0"

  - from: check_po_validation
    to: validation_failed
    when: "state.get('po_validation_status') != 'GO' and state.get('correction_attempt', 0) >= 1"

  # QA VALIDATION PHASE (TEA)
  - from: tea_test_design
    to: extract_risk_level
  - from: extract_risk_level
    to: tea_nfr_assessment
  - from: tea_nfr_assessment
    to: tea_requirements_tracing
  - from: tea_requirements_tracing
    to: extract_gate_decision
  - from: extract_gate_decision
    to: validate_story
  - from: validate_story
    to: check_validation_status

  # VALIDATION ROUTING
  - from: check_validation_status
    to: validation_complete
    when: "state.get('validation_status') == 'PASSED'"

  - from: check_validation_status
    to: correct_course
    when: "state.get('validation_status') != 'PASSED' and state.get('correction_attempt', 0) == 0"

  - from: check_validation_status
    to: validation_failed
    when: "state.get('validation_status') != 'PASSED' and state.get('correction_attempt', 0) >= 1"

  # CORRECTION LOOP
  - from: correct_course
    to: increment_correction_attempt
  - from: increment_correction_attempt
    to: po_validate_story_draft
  - from: validation_failed
    to: __end__

  # FINAL
  - from: validation_complete
    to: __end__
