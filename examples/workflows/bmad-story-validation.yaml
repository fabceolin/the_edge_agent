name: bmad-story-validation
description: |
  BMad Story Validation Workflow - Sequential QA and SM checks using BMad slash commands.

  Sequence:
  1. QA risk-profile → update story QA notes
  2. QA nfr-assess → update story QA notes
  3. QA test-design → update story QA notes
  4. QA trace-requirements → update story QA notes (RTM)
  5. SM story-checklist → update story status

  Uses BMad agents directly via slash commands for simplified context loading.

state_schema:
  arg: str
  story_path: str
  risk_profile_output: str
  nfr_assess_output: str
  test_design_output: str
  trace_requirements_output: str
  sm_checklist_output: str
  final_status: str

# TEA-RALPHY-002.3: Enable verbose output for Claude Code shell provider
settings:
  shell_providers:
    claude:
      command: claude
      args: ["-p", "{prompt}", "--dangerously-skip-permissions"]
      verbose: true
      timeout: 108000

nodes:
  # ============================================================================
  # NODE 0: Resolve story path from arg (handles both short labels and full paths)
  # ============================================================================
  - name: resolve_story_path
    description: Convert short label to full story path if needed
    run: |
      import os
      import glob

      arg = state.get("arg", "")

      # If arg is already a full path that exists, use it directly
      if os.path.isfile(arg):
          return {"story_path": arg}

      # Otherwise, search for matching story file
      # arg could be: "PIR.1.person-table-row-level-accept-reject" or "PIR.1"
      stories_dir = "docs/stories"

      # Try exact match first
      pattern = os.path.join(stories_dir, f"{arg}.md")
      matches = glob.glob(pattern)
      if matches:
          return {"story_path": matches[0]}

      # Try prefix match (e.g., "PIR.1" matches "PIR.1.person-table-row-level-accept-reject.md")
      pattern = os.path.join(stories_dir, f"{arg}*.md")
      matches = glob.glob(pattern)
      if matches:
          return {"story_path": matches[0]}

      # Fallback: return arg as-is and let downstream handle the error
      return {"story_path": arg}

  # ============================================================================
  # NODE 1: QA risk-profile using BMad slash command
  # ============================================================================
  - name: qa_risk_profile
    description: Execute QA risk-profile and update story QA notes
    uses: llm.call
    with:
      provider: shell
      shell_provider: claude
      model: claude
      timeout: 3600
      messages:
        - role: user
          content: |
            /BMad:agents:qa *risk-profile {{ state.story_path }} YOLO mode

            AFTER completing the risk-profile analysis, you MUST:
            1. Append a "## QA Notes - Risk Profile" section to the story file {{ state.story_path }}
            2. Include: Risk level, identified risks, mitigations, testing priorities
            3. VERIFY the section was written by reading the file

            When done print: RISK_PROFILE_COMPLETED
    output: risk_profile_output

  # ============================================================================
  # NODE 2: QA nfr-assess using BMad slash command
  # ============================================================================
  - name: qa_nfr_assess
    description: Execute QA NFR assessment and update story QA notes
    uses: llm.call
    with:
      provider: shell
      shell_provider: claude
      model: claude
      timeout: 3600
      messages:
        - role: user
          content: |
            /BMad:agents:qa *nfr-assess {{ state.story_path }} YOLO mode

            AFTER completing the NFR assessment, you MUST:
            1. Append a "## QA Notes - NFR Assessment" section to the story file {{ state.story_path }}
            2. Include: NFR coverage, missing considerations, test recommendations, acceptance criteria
            3. VERIFY the section was written by reading the file

            When done print: NFR_ASSESS_COMPLETED
    output: nfr_assess_output

  # ============================================================================
  # NODE 3: QA test-design using BMad slash command
  # ============================================================================
  - name: qa_test_design
    description: Execute QA test-design and update story QA notes
    uses: llm.call
    with:
      provider: shell
      shell_provider: claude
      model: claude
      timeout: 3600
      messages:
        - role: user
          content: |
            /BMad:agents:qa *test-design {{ state.story_path }} YOLO mode

            AFTER completing the test design, you MUST:
            1. Append a "## QA Notes - Test Design" section to the story file {{ state.story_path }}
            2. Include: Test coverage matrix, scenarios with expected results, test data/environment requirements
            3. VERIFY the section was written by reading the file

            When done print: TEST_DESIGN_COMPLETED
    output: test_design_output

  # ============================================================================
  # NODE 4: QA trace-requirements using BMad slash command
  # ============================================================================
  - name: qa_trace_requirements
    description: Execute QA requirements tracing and update story QA notes
    uses: llm.call
    with:
      provider: shell
      shell_provider: claude
      model: claude
      timeout: 3600
      messages:
        - role: user
          content: |
            /BMad:agents:qa *trace {{ state.story_path }} YOLO mode

            AFTER completing the requirements tracing, you MUST:
            1. Append a "## QA Notes - Requirements Trace" section to the story file {{ state.story_path }}
            2. Include: Requirements coverage, traceability matrix, gaps identified, recommendations
            3. VERIFY the section was written by reading the file

            When done print: TRACE_REQUIREMENTS_COMPLETED
    output: trace_requirements_output

  # ============================================================================
  # NODE 5: SM story validation using BMad slash command
  # ============================================================================
  - name: sm_story_checklist
    description: Execute SM story-checklist and update story status
    uses: llm.call
    with:
      provider: shell
      shell_provider: claude
      model: claude
      timeout: 3600
      messages:
        - role: user
          content: |
            /BMad:agents:sm YOLO mode

            Execute the story validation checklist for {{ state.story_path }}

            Validate against Definition of Ready:
            - Story has clear title and description
            - Acceptance criteria are defined and testable
            - Dependencies are identified
            - Technical approach is documented
            - Story is properly sized
            - QA notes sections are present (Risk Profile, NFR, Test Design, Requirements Trace)
            - No blocking issues or unknowns

            AFTER completing validation, you MUST update the story file {{ state.story_path }}:
            1. Add "## SM Validation" section with checklist results
            2. Update "## Status" section:
               - If ALL criteria passed: Set to "Ready for Development"
               - If ANY criteria failed: Set to "Needs Revision" with notes
            3. VERIFY the sections were written by reading the file

            When done print: SM_CHECKLIST_COMPLETED
    output: sm_checklist_output

  # ============================================================================
  # NODE 6: Summary
  # ============================================================================
  - name: summary
    description: Generate final summary of the validation pipeline
    run: |
      import os
      import re
      import glob

      arg = state.get("arg", "unknown")
      story_path = state.get("story_path", "unknown")

      # ========================================================================
      # Helper functions for artifact-based detection (TEA-RALPHY-002.4)
      # ========================================================================

      def check_story_section(story_path, section_name):
          """Check if a section exists in the story file."""
          try:
              with open(story_path, 'r') as f:
                  content = f.read()
              return section_name in content
          except Exception:
              return False

      def extract_story_status(story_path):
          """Extract raw status string from story file."""
          try:
              with open(story_path, 'r') as f:
                  content = f.read()

              status_raw = None

              # Format 1: Status on separate line (## Status\n\nValue)
              match = re.search(r'^## Status\s*\n+(.+?)$', content, re.MULTILINE)
              if match:
                  status_raw = match.group(1).strip()
                  if status_raw.startswith('|'):
                      status_raw = None

              # Format 2: Status with colon on same line
              if not status_raw:
                  match = re.search(r'^## Status:\s*(.+?)$', content, re.MULTILINE)
                  if match:
                      status_raw = match.group(1).strip()

              # Format 3-6: Tables under various sections
              for section in ['Status', 'Epic Overview', 'Story Metadata', 'Story Overview']:
                  if not status_raw:
                      match = re.search(
                          rf'^## {section}\s*\n+\|.*?\*\*Status\*\*\s*\|\s*(.+?)\s*\|',
                          content, re.MULTILINE | re.DOTALL
                      )
                      if match:
                          status_raw = match.group(1).strip()

              return status_raw
          except Exception:
              pass
          return None

      def categorize_status(status_raw):
          """Categorize status using same logic as story_status_audit.py."""
          if not status_raw:
              return "no_status"

          status_lower = status_raw.lower()

          # Order matters: more specific patterns first
          STATUS_CATEGORIES = {
              "ready_review": ["ready for review", "ready for merge"],
              "ready_done": ["ready for done"],
              "ready_dev": [
                  "ready for dev", "ready for development", "ready to develop",
                  "approved - ready for development", "ready",
              ],
              "draft": ["draft", "planned"],
              "backlog": ["backlog", "proposed", "pending"],
              "done": [
                  "done", "complete", "completed", "merged", "superseded",
                  "qa approved", "qa pass", "qa approved - ready for deployment",
              ],
              "approved": ["approved"],
              "in_progress": ["in progress", "wip", "work in progress"],
              "needs_revision": ["needs revision", "changes required"],
          }

          for category, keywords in STATUS_CATEGORIES.items():
              for keyword in keywords:
                  if keyword in status_lower:
                      return category

          return "other"

      def check_story_status(story_path, expected_categories):
          """Check if story status matches expected categories."""
          status_raw = extract_story_status(story_path)
          if not status_raw:
              return False
          category = categorize_status(status_raw)
          return category in expected_categories

      def check_artifact_file(pattern):
          """Check if artifact file(s) matching glob pattern exist."""
          return len(glob.glob(pattern)) > 0

      def get_story_id(story_path):
          """Extract story ID from path (e.g., 'TEA-RALPHY-002.4' from 'docs/stories/TEA-RALPHY-002.4-name.md')."""
          basename = os.path.basename(story_path).replace(".md", "")
          # Match pattern like TEA-XXX-NNN.N or similar
          match = re.match(r'^([A-Z]+-[A-Z]+-\d+\.\d+)', basename)
          if match:
              return match.group(1)
          return basename

      # Helper to extract content from output objects
      # llm.call stores {"content": "...", "usage": {}, "provider": "..."} objects
      def get_content(output):
          if isinstance(output, dict):
              return output.get("content", "")
          return str(output) if output else ""

      risk_output = get_content(state.get("risk_profile_output", ""))
      nfr_output = get_content(state.get("nfr_assess_output", ""))
      test_output = get_content(state.get("test_design_output", ""))
      trace_output = get_content(state.get("trace_requirements_output", ""))
      sm_output = get_content(state.get("sm_checklist_output", ""))

      story_id = get_story_id(story_path) if story_path != "unknown" else ""

      # ========================================================================
      # Detection logic: marker-first, artifact-fallback (AC 9)
      # ========================================================================

      # Risk Profile detection (AC 5): Check marker first, then story section or assessment file
      risk_marker = "RISK_PROFILE_COMPLETED" in risk_output
      risk_section = check_story_section(story_path, "## QA Notes - Risk Profile") if story_path != "unknown" else False
      risk_file = check_artifact_file(f"docs/qa/assessments/{story_id}-risk-*.md") if story_id else False
      risk_artifact = risk_section or risk_file
      risk_done = risk_marker or risk_artifact
      risk_method = "(via marker)" if risk_marker else "(via artifact)" if risk_artifact else ""

      # NFR Assessment detection (AC 6): Check marker first, then story section or assessment file
      nfr_marker = "NFR_ASSESS_COMPLETED" in nfr_output
      nfr_section = check_story_section(story_path, "## QA Notes - NFR Assessment") if story_path != "unknown" else False
      nfr_file = check_artifact_file(f"docs/qa/assessments/{story_id}-nfr-*.md") if story_id else False
      nfr_artifact = nfr_section or nfr_file
      nfr_done = nfr_marker or nfr_artifact
      nfr_method = "(via marker)" if nfr_marker else "(via artifact)" if nfr_artifact else ""

      # Test Design detection (AC 7): Check marker first, then story section or assessment file
      test_marker = "TEST_DESIGN_COMPLETED" in test_output
      test_section = check_story_section(story_path, "## QA Notes - Test Design") if story_path != "unknown" else False
      test_file = check_artifact_file(f"docs/qa/assessments/{story_id}-test-design-*.md") if story_id else False
      test_artifact = test_section or test_file
      test_done = test_marker or test_artifact
      test_method = "(via marker)" if test_marker else "(via artifact)" if test_artifact else ""

      # Trace Requirements detection: Check marker first, then story section or assessment file
      trace_marker = "TRACE_REQUIREMENTS_COMPLETED" in trace_output
      trace_section = check_story_section(story_path, "## QA Notes - Requirements Trace") if story_path != "unknown" else False
      trace_file = check_artifact_file(f"docs/qa/assessments/{story_id}-trace-*.md") if story_id else False
      trace_artifact = trace_section or trace_file
      trace_done = trace_marker or trace_artifact
      trace_method = "(via marker)" if trace_marker else "(via artifact)" if trace_artifact else ""

      # SM Checklist detection (AC 8): Check marker first, then story section AND status
      sm_marker = "SM_CHECKLIST_COMPLETED" in sm_output
      sm_section = check_story_section(story_path, "## SM Validation") if story_path != "unknown" else False
      sm_status = check_story_status(story_path, ["ready_dev", "needs_revision"]) if story_path != "unknown" else False
      # Relaxed: sm_done is True if marker OR section exists OR status is ready/needs_revision
      sm_done = sm_marker or sm_section or sm_status
      sm_method = "(via marker)" if sm_marker else "(via artifact)" if sm_artifact else ""

      # ========================================================================
      # Generate summary with detection method indicators (AC 12)
      # ========================================================================

      risk_status = f"{'✓ Completed' if risk_done else '✗ Failed'} {risk_method}"
      nfr_status = f"{'✓ Completed' if nfr_done else '✗ Failed'} {nfr_method}"
      test_status = f"{'✓ Completed' if test_done else '✗ Failed'} {test_method}"
      trace_status = f"{'✓ Completed' if trace_done else '✗ Failed'} {trace_method}"
      sm_status_str = f"{'✓ Completed' if sm_done else '✗ Failed'} {sm_method}"

      all_phases_passed = all([risk_done, nfr_done, test_done, trace_done, sm_done])
      final_status = "completed" if all_phases_passed else "incomplete"

      summary = f"""
      ╔════════════════════════════════════════════════════════════╗
      ║           BMad Story Validation Pipeline Complete           ║
      ╠════════════════════════════════════════════════════════════╣
      ║ Story: {arg:<52} ║
      ║ Path:  {story_path:<52} ║
      ╠════════════════════════════════════════════════════════════╣
      ║ Phase              │ Status                                ║
      ╠════════════════════╪═══════════════════════════════════════╣
      ║ QA Risk Profile    │ {risk_status:<37} ║
      ║ QA NFR Assessment  │ {nfr_status:<37} ║
      ║ QA Test Design     │ {test_status:<37} ║
      ║ QA Req Tracing     │ {trace_status:<37} ║
      ║ SM Story Checklist │ {sm_status_str:<37} ║
      ╚════════════════════════════════════════════════════════════╝
      """

      # TEA-CLI-008: Print summary first, then raise exception if incomplete for non-zero exit
      print(summary)

      if final_status == "incomplete":
          raise Exception(f"Validation incomplete - one or more phases failed for {arg}")

      return {"final_status": final_status}

edges:
  - from: __start__
    to: resolve_story_path
  - from: resolve_story_path
    to: qa_risk_profile
  - from: qa_risk_profile
    to: qa_nfr_assess
  - from: qa_nfr_assess
    to: qa_test_design
  - from: qa_test_design
    to: qa_trace_requirements
  - from: qa_trace_requirements
    to: sm_story_checklist
  - from: sm_story_checklist
    to: summary
  - from: summary
    to: __end__
