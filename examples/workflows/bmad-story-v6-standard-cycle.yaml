name: bmad-v6-story-cycle
description: |
  BMad v6 Standard Story Cycle - Development workflow WITHOUT formal TEA QA gates.

  PREREQUISITE: Story must already exist (created via bmad-bmm-create-story)

  Use this workflow for rapid development cycles where TEA validation is not required.
  For formal QA gates (risk assessment, NFR, traceability), use bmad-story-v6-full-with-qa-cycle.yaml instead.

  Flow:
  1. PREPARATION PHASE:
     - Resolve story path (story must already exist)
     - Validate Story (VS) - competitive quality checklist

  2. CORRECTION LOOP (if validation failed, max 1 iteration):
     - Correct Course (CC) - analyze impact and propose solutions
     - Re-run validation
     - If still fails → INTERRUPT

  3. DEVELOPMENT PHASE:
     - Dev Story (DS) - implement with Definition of Done
     - Code Review (CR) - adversarial review (3-10 issues minimum)
     - If CHANGES_REQUESTED → DS (fixes) → CR (re-review, max 2 attempts)
     - Sprint Status (SS) - finalize status

  Differences from v6-full-qa-cycle:
  - NO TEA phases (risk-profile, nfr-assess, test-design, trace, atdd, test-automation, test-review)
  - Faster cycle for stories that don't require formal QA gates
  - Same correction and review loops

  Usage: tea run examples/workflows/bmad-story-v6-standard-cycle.yaml --input '{"arg": "epic-1-story-1"}'

state_schema:
  arg: str
  story_path: str
  story_key: str
  # Skip validation check
  already_validated: bool
  current_status: str
  story_exists: bool
  # Validation phase
  validate_story_output: str
  validation_status: str
  # Correction loop tracking (max 1 iteration)
  correction_attempt: int
  correct_course_output: str
  # Development phase
  dev_output: str
  review_output: str
  review_status: str
  # Review fix loop tracking (max 2 iterations)
  review_fix_attempt: int
  sprint_status_output: str
  final_status: str

settings:
  shell_providers:
    claude:
      command: claude
      args: ["-p", "{prompt}", "--dangerously-skip-permissions"]
      verbose: true
      timeout: 108000

nodes:
  # ============================================================================
  # NODE 0: Resolve story path from arg, check if already validated
  # ============================================================================
  - name: resolve_story_path
    description: Convert story key to full story path, verify story exists, check validation status
    run: |
      import os
      import glob
      import yaml
      import re

      arg = state.get("arg", "")
      story_path = None
      story_key = None
      story_exists = False

      # If arg is already a full path that exists, use it
      if os.path.isfile(arg):
          story_path = arg
          story_key = os.path.basename(arg).replace(".md", "")
          story_exists = True
      else:
          # Try to find config to get implementation_artifacts path
          config_paths = [
              "_bmad/bmm/config.yaml",
              ".bmad/bmm/config.yaml"
          ]

          impl_artifacts = "_bmad-output/implementation-artifacts"
          for config_path in config_paths:
              if os.path.exists(config_path):
                  try:
                      with open(config_path, 'r') as f:
                          config = yaml.safe_load(f)
                      impl_artifacts = config.get("implementation_artifacts", impl_artifacts)
                      break
                  except:
                      pass

          # Search for story file
          patterns = [
              os.path.join(impl_artifacts, f"{arg}.md"),
              os.path.join(impl_artifacts, f"*{arg}*.md"),
              f"**/{arg}.md",
              f"**/*{arg}*.md"
          ]

          for pattern in patterns:
              matches = glob.glob(pattern, recursive=True)
              if matches:
                  story_path = matches[0]
                  story_key = os.path.basename(story_path).replace(".md", "")
                  story_exists = True
                  break

          if not story_path:
              # Story not found
              story_key = arg
              story_path = os.path.join(impl_artifacts, f"{arg}.md")
              story_exists = False

      # Check if story is already in ready-for-dev, done, review, or in-progress status
      already_validated = False
      current_status = "unknown"
      if story_path and os.path.isfile(story_path):
          try:
              with open(story_path, 'r') as f:
                  content = f.read(500)  # Read first 500 chars for status
              status_match = re.search(r'^Status:\s*(\S+)', content, re.MULTILINE)
              if status_match:
                  current_status = status_match.group(1).lower()
                  if current_status in ['ready-for-dev', 'done', 'review', 'in-progress']:
                      already_validated = True
          except:
              pass

      print(f"""
      ╔════════════════════════════════════════════════════════════╗
      ║              STANDARD CYCLE - PREPARATION                  ║
      ╠════════════════════════════════════════════════════════════╣
      ║ Story: {story_key:<52} ║
      ║ Status: {current_status:<51} ║
      ║ Story Exists: {'✓ YES' if story_exists else '✗ NO':<44} ║
      ╠════════════════════════════════════════════════════════════╣
      ║ Already Validated: {'YES - skipping validation' if already_validated else 'NO - will validate':<40} ║
      ╚════════════════════════════════════════════════════════════╝
      """)

      if not story_exists:
          print("\n⚠️  WARNING: Story file not found. Create it first with bmad-bmm-create-story")

      return {
          "story_path": story_path,
          "story_key": story_key,
          "already_validated": already_validated,
          "current_status": current_status,
          "story_exists": story_exists
      }

  # ============================================================================
  # PREPARATION PHASE
  # ============================================================================

  # NODE: Handle missing story
  - name: story_not_found_error
    description: Handle missing story file
    run: |
      print(f"""
      ╔════════════════════════════════════════════════════════════╗
      ║           CANNOT START WORKFLOW - STORY NOT FOUND          ║
      ╠════════════════════════════════════════════════════════════╣
      ║ Story: {state.get('story_key', 'unknown'):<52} ║
      ╠════════════════════════════════════════════════════════════╣
      ║  ⚠️  Story file does not exist!                             ║
      ║                                                            ║
      ║  Please create the story first:                            ║
      ║  bmad-bmm-create-story {state.get('story_key', 'story-key'):<33} ║
      ╚════════════════════════════════════════════════════════════╝
      """)
      raise Exception(f"Story not found: {state.get('story_key', 'unknown')}. Create it first with bmad-bmm-create-story")

  # NODE: Validate Story (VS) - Using create-story checklist
  - name: validate_story
    description: Validate story using create-story checklist
    uses: llm.call
    with:
      provider: shell
      shell_provider: claude
      timeout: 3600
      messages:
        - role: user
          content: |
            Validate this story using the create-story checklist:
            {{ state.story_path }}

            This will:
            1. Load the story file
            2. Load workflow.yaml for variable context
            3. Load source documents (epics, architecture, etc.)
            4. Run the systematic 5-step analysis from the checklist
            5. Present findings with critical/enhancement/optimization categories

            INSTRUCTIONS:
            1. Run the validation completely
            2. If critical issues are found, apply the fixes
            3. Record the validation result

            When done, determine validation status:
            - If all critical issues were fixed or none found: Print VALIDATION_PASSED
            - If critical issues remain unfixed: Print VALIDATION_FAILED

            Print the validation summary at the end.
    output: validate_story_output

  # NODE 3: Check validation status
  - name: check_validation_status
    description: Parse validation output and determine if story is ready for development
    run: |
      import re

      output = state.get("validate_story_output", {})
      if isinstance(output, dict):
          text = output.get("content", "")
      else:
          text = str(output) if output else ""

      # Check for explicit status markers
      if "VALIDATION_PASSED" in text:
          validation_status = "PASSED"
      elif "VALIDATION_FAILED" in text:
          validation_status = "FAILED"
      elif "Story Ready for Review" in text or "PASS" in text.upper():
          validation_status = "PASSED"
      elif "critical issues" in text.lower() and "unfixed" in text.lower():
          validation_status = "FAILED"
      else:
          # Default to passed if no clear failure indicators
          validation_status = "PASSED"

      correction_attempt = state.get("correction_attempt", 0)

      print(f"""
      ╔════════════════════════════════════════════════════════════╗
      ║              STORY VALIDATION COMPLETE                     ║
      ╠════════════════════════════════════════════════════════════╣
      ║ Story: {state.get('story_key', 'unknown'):<52} ║
      ║ Path:  {state.get('story_path', 'unknown')[:52]:<52} ║
      ╠════════════════════════════════════════════════════════════╣
      ║ VALIDATION STATUS: {validation_status:<40} ║
      ║ Correction Attempts: {correction_attempt:<38} ║
      ╚════════════════════════════════════════════════════════════╝
      """)

      if validation_status != "PASSED":
          print("\n⚠️  VALIDATION FAILED - Will attempt correction...")
      else:
          print("\n✓ VALIDATION PASSED - Proceeding to development phase...")

      return {"validation_status": validation_status}

  # ============================================================================
  # CORRECTION LOOP
  # ============================================================================

  # NODE 4: Correct Course (unified architect + pm corrections)
  - name: correct_course
    description: Execute bmad-bmm-correct-course to fix story issues
    uses: llm.call
    with:
      provider: shell
      shell_provider: claude
      timeout: 3600
      messages:
        - role: user
          content: |
            The story validation FAILED. Execute course correction.

            Run command: bmad-bmm-correct-course

            Story file: {{ state.story_path }}

            The Correct Course workflow will:
            1. Analyze the impact of required changes
            2. Review PRD, epics, architecture for alignment
            3. Propose solutions for the validation failures
            4. Update the story with corrections

            INSTRUCTIONS:
            1. Run the correct-course workflow completely
            2. Apply the recommended corrections to the story
            3. Ensure both technical (architecture) and product (requirements) issues are addressed

            When done print: CORRECT_COURSE_COMPLETED
    output: correct_course_output

  # NODE 5: Increment correction attempt counter
  - name: increment_correction_attempt
    description: Track correction iteration and clear previous outputs
    run: |
      current = state.get("correction_attempt", 0)
      new_attempt = current + 1

      print(f"""
      ╔════════════════════════════════════════════════════════════╗
      ║        CORRECTION LOOP COMPLETED (Attempt {new_attempt})               ║
      ╠════════════════════════════════════════════════════════════╣
      ║ Correct Course: ✓ Done                                     ║
      ╠════════════════════════════════════════════════════════════╣
      ║ Re-running story validation...                             ║
      ╚════════════════════════════════════════════════════════════╝
      """)

      return {
          "correction_attempt": new_attempt,
          "validate_story_output": "",
          "validation_status": ""
      }

  # NODE 6: Validation failed after correction
  - name: validation_failed
    description: Handle validation failure after correction attempt
    run: |
      story_path = state.get("story_path", "unknown")
      correction_attempt = state.get("correction_attempt", 0)

      print(f"""
      ╔════════════════════════════════════════════════════════════╗
      ║           BMad v6 Story Cycle - INTERRUPTED                ║
      ╠════════════════════════════════════════════════════════════╣
      ║ Story: {state.get('story_key', 'unknown'):<52} ║
      ║ Path:  {story_path[:52]:<52} ║
      ╠════════════════════════════════════════════════════════════╣
      ║ VALIDATION: FAILED (after {correction_attempt} correction attempt)       ║
      ║ DEVELOPMENT: SKIPPED                                       ║
      ╠════════════════════════════════════════════════════════════╣
      ║                                                            ║
      ║  ⚠️  Story did not pass validation after correction.        ║
      ║                                                            ║
      ║  Next steps (manual intervention required):                ║
      ║  1. Review the story file for remaining issues             ║
      ║  2. Run: bmad-bmm-create-story -v {state.get('story_key', '')}             ║
      ║  3. Fix issues manually                                    ║
      ║  4. Re-run this workflow                                   ║
      ║                                                            ║
      ╚════════════════════════════════════════════════════════════╝
      """)

      raise Exception(f"Validation failed after correction for {state.get('story_key', 'unknown')}")

  # ============================================================================
  # DEVELOPMENT PHASE
  # ============================================================================

  # NODE 7: Dev Story (DS)
  - name: dev_story
    description: Execute bmad-bmm-dev-story to implement the story
    uses: llm.call
    with:
      provider: shell
      shell_provider: claude
      timeout: 7200
      messages:
        - role: user
          content: |
            Execute story development for: {{ state.story_path }}

            Run command: bmad-bmm-dev-story {{ state.story_path }}

            The Dev Story workflow will:
            1. Read each task from the story
            2. Implement task and all subtasks
            3. Write comprehensive tests
            4. Execute validations
            5. Mark checkbox [x] only if ALL validations pass
            6. Update File List with new/modified/deleted files
            7. Repeat until all tasks complete

            INSTRUCTIONS:
            1. Follow the workflow order-of-execution EXACTLY
            2. Do NOT skip any steps
            3. Write proper tests for EACH implementation
            4. Update the File List section accurately
            5. Set story status to "review" when complete

            CRITICAL: Implement ALL tasks sequentially. No shortcuts.

            When done print: DEV_STORY_COMPLETED
    output: dev_output

  # NODE 8: Code Review (CR) - Adversarial review
  - name: code_review
    description: Execute bmad-bmm-code-review for adversarial senior dev review
    uses: llm.call
    with:
      provider: shell
      shell_provider: claude
      timeout: 3600
      messages:
        - role: user
          content: |
            Execute adversarial code review for: {{ state.story_path }}

            Run command: bmad-bmm-code-review {{ state.story_path }}

            The Code Review workflow performs ADVERSARIAL Senior Developer review that:
            - Finds 3-10 specific problems in EVERY story
            - Challenges code quality, test coverage, architecture compliance
            - Reviews security and performance
            - NEVER accepts "looks good" - must find minimum issues
            - Can auto-fix issues with user approval

            INSTRUCTIONS:
            1. Run the code review workflow completely
            2. Document all issues found
            3. Apply auto-fixes if approved
            4. Record the review outcome

            Review outcomes:
            - APPROVED: Print REVIEW_APPROVED
            - CHANGES_REQUESTED: Print REVIEW_CHANGES_REQUESTED
            - BLOCKED: Print REVIEW_BLOCKED

            Print the review summary with all issues found.
    output: review_output

  # NODE 9: Check review status
  - name: check_review_status
    description: Parse review output and determine next action
    run: |
      import re

      output = state.get("review_output", {})
      if isinstance(output, dict):
          text = output.get("content", "")
      else:
          text = str(output) if output else ""

      review_fix_attempt = state.get("review_fix_attempt", 0)

      # Check for explicit status markers
      if "REVIEW_APPROVED" in text or "Approve" in text:
          review_status = "APPROVED"
      elif "REVIEW_BLOCKED" in text or "Blocked" in text:
          review_status = "BLOCKED"
      elif "REVIEW_CHANGES_REQUESTED" in text or "Changes Requested" in text:
          review_status = "CHANGES_REQUESTED"
      else:
          # Default based on content
          if "changes required" in text.lower() or "must fix" in text.lower():
              review_status = "CHANGES_REQUESTED"
          else:
              review_status = "APPROVED"

      # Force exit after max attempts regardless of status
      if review_fix_attempt >= 2 and review_status not in ["APPROVED", "BLOCKED"]:
          print(f"Review Status: {review_status} (Max attempts {review_fix_attempt} reached - forcing exit)")
          review_status = "MAX_ATTEMPTS_REACHED"
      else:
          print(f"Review Status: {review_status} (Attempt: {review_fix_attempt}/2)")

      print(f"""
      ╔════════════════════════════════════════════════════════════╗
      ║              CODE REVIEW COMPLETE                          ║
      ╠════════════════════════════════════════════════════════════╣
      ║ Story: {state.get('story_key', 'unknown'):<52} ║
      ║ REVIEW STATUS: {review_status:<44} ║
      ║ Fix Attempts: {review_fix_attempt}/2{' (MAX REACHED)' if review_fix_attempt >= 2 else '':<40} ║
      ╚════════════════════════════════════════════════════════════╝
      """)

      return {"review_status": review_status}

  # NODE 10: Dev fixes review issues
  - name: dev_fix_review
    description: Dev addresses code review issues
    uses: llm.call
    with:
      provider: shell
      shell_provider: claude
      timeout: 3600
      messages:
        - role: user
          content: |
            The code review found issues that need to be fixed.

            Story file: {{ state.story_path }}

            INSTRUCTIONS:
            1. Read the "Senior Developer Review (AI)" section in the story file
            2. Address EACH issue raised by the reviewer:
               - Fix code issues
               - Add missing tests
               - Update documentation as needed
            3. Run ALL tests and confirm they pass
            4. Update the Dev Agent Record with your fixes
            5. Mark review follow-up tasks as completed

            CRITICAL: Address ALL review concerns before completing.

            When done print: DEV_FIXES_COMPLETED
    output: dev_output

  # NODE 11: Increment review fix attempt
  - name: increment_review_fix_attempt
    description: Track review fix iteration
    run: |
      current = state.get("review_fix_attempt", 0)
      new_attempt = current + 1

      print(f"""
      ╔════════════════════════════════════════════════════════════╗
      ║        REVIEW FIXES COMPLETED (Attempt {new_attempt})                  ║
      ╠════════════════════════════════════════════════════════════╣
      ║ Dev Fixes: ✓ Done                                          ║
      ╠════════════════════════════════════════════════════════════╣
      ║ Re-running code review...                                  ║
      ╚════════════════════════════════════════════════════════════╝
      """)

      # Don't clear review_status here - let check_review_status handle it
      return {"review_fix_attempt": new_attempt, "review_output": ""}

  # NODE 12: Sprint Status update
  - name: sprint_status
    description: Execute bmad-bmm-sprint-status to finalize story status
    uses: llm.call
    with:
      provider: shell
      shell_provider: claude
      timeout: 600
      messages:
        - role: user
          content: |
            Update sprint status after story completion.

            Run command: bmad-bmm-sprint-status

            The Sprint Status workflow will:
            1. Summarize current sprint status
            2. Update the sprint-status.yaml file
            3. Route to next workflow if needed

            Story completed: {{ state.story_key }}
            Review status: {{ state.review_status }}

            INSTRUCTIONS:
            1. Run the sprint status workflow
            2. Mark the story as complete in sprint tracking
            3. Report the overall sprint progress

            When done print: SPRINT_STATUS_UPDATED
    output: sprint_status_output

  # NODE 13: Final Summary
  - name: summary
    description: Generate final summary of the story cycle
    run: |
      import os

      story_key = state.get("story_key", "unknown")
      story_path = state.get("story_path", "unknown")
      validation_status = state.get("validation_status", "UNKNOWN")
      review_status = state.get("review_status", "UNKNOWN")
      correction_attempt = state.get("correction_attempt", 0)
      review_fix_attempt = state.get("review_fix_attempt", 0)

      def get_content(output):
          if isinstance(output, dict):
              return output.get("content", "")
          return str(output) if output else ""

      dev_output = get_content(state.get("dev_output", ""))
      review_output = get_content(state.get("review_output", ""))

      # Detection
      dev_done = "DEV_STORY_COMPLETED" in dev_output or "DEV_FIXES_COMPLETED" in dev_output
      review_approved = review_status == "APPROVED"

      all_done = validation_status == "PASSED" and dev_done and review_approved

      # Partial success if max attempts reached
      partial_success = (
          validation_status == "PASSED" and
          dev_done and
          review_status == "MAX_ATTEMPTS_REACHED"
      )

      final_result = "SUCCESS" if all_done else ("PARTIAL (max review attempts)" if partial_success else "INCOMPLETE")

      summary = f"""
      ╔════════════════════════════════════════════════════════════╗
      ║           BMad v6 Story Cycle Complete                     ║
      ╠════════════════════════════════════════════════════════════╣
      ║ Story: {story_key:<52} ║
      ║ Path:  {story_path[:52]:<52} ║
      ╠════════════════════════════════════════════════════════════╣
      ║                    VALIDATION PHASE                        ║
      ╠════════════════════════════════════════════════════════════╣
      ║ Story Validation: {'✓ PASSED' if validation_status == 'PASSED' else '✗ ' + validation_status:<40} ║
      ║ Corrections Applied: {correction_attempt:<38} ║
      ╠════════════════════════════════════════════════════════════╣
      ║                    DEVELOPMENT PHASE                       ║
      ╠════════════════════════════════════════════════════════════╣
      ║ Dev Story: {'✓ Completed' if dev_done else '✗ Failed':<48} ║
      ║ Code Review: {review_status:<46} ║
      ║ Review Fixes: {review_fix_attempt:<45} ║
      ╠════════════════════════════════════════════════════════════╣
      ║ FINAL RESULT: {final_result:<45} ║
      ╚════════════════════════════════════════════════════════════╝
      """

      print(summary)
      final = "completed" if all_done else ("partial" if partial_success else "incomplete")
      return {"final_status": final}

edges:
  # ============================================================================
  # PREPARATION PHASE
  # ============================================================================
  - from: __start__
    to: resolve_story_path

  # Story not found: error
  - from: resolve_story_path
    to: story_not_found_error
    when: "state.get('story_exists', False) != True"

  - from: story_not_found_error
    to: __end__

  # Skip to development if story already validated (ready-for-dev, done, review, in-progress)
  - from: resolve_story_path
    to: dev_story
    when: "state.get('story_exists', False) == True and state.get('already_validated', False) == True"

  # Normal flow: proceed to validate_story if not already validated
  - from: resolve_story_path
    to: validate_story
    when: "state.get('story_exists', False) == True and state.get('already_validated', False) != True"

  - from: validate_story
    to: check_validation_status

  # ============================================================================
  # VALIDATION ROUTING
  # ============================================================================

  # If validation PASSED: proceed to development
  - from: check_validation_status
    to: dev_story
    when: "state.get('validation_status') == 'PASSED'"

  # If validation FAILED and NO correction attempt yet: try correction
  - from: check_validation_status
    to: correct_course
    when: "state.get('validation_status') != 'PASSED' and state.get('correction_attempt', 0) == 0"

  # If validation FAILED and already tried correction: give up
  - from: check_validation_status
    to: validation_failed
    when: "state.get('validation_status') != 'PASSED' and state.get('correction_attempt', 0) >= 1"

  # ============================================================================
  # CORRECTION LOOP
  # ============================================================================
  - from: correct_course
    to: increment_correction_attempt
  - from: increment_correction_attempt
    to: validate_story
  - from: validation_failed
    to: __end__

  # ============================================================================
  # DEVELOPMENT PHASE
  # ============================================================================
  - from: dev_story
    to: code_review
  - from: code_review
    to: check_review_status

  # ============================================================================
  # REVIEW ROUTING
  # ============================================================================

  # Exit conditions: APPROVED, BLOCKED, or MAX_ATTEMPTS_REACHED
  - from: check_review_status
    to: sprint_status
    when: "state.get('review_status') in ['APPROVED', 'MAX_ATTEMPTS_REACHED', 'BLOCKED']"

  # Continue fixing only if CHANGES_REQUESTED (max attempts check is in check_review_status node)
  - from: check_review_status
    to: dev_fix_review
    when: "state.get('review_status') == 'CHANGES_REQUESTED'"

  # Review fix loop
  - from: dev_fix_review
    to: increment_review_fix_attempt
  - from: increment_review_fix_attempt
    to: code_review

  # ============================================================================
  # FINAL
  # ============================================================================
  - from: sprint_status
    to: summary
  - from: summary
    to: __end__
